<!-- CONTROLE MANUAL v3.3 (Trystero/Chat Bus; clique = comando unico; segurar = HOLD; sem Firebase) -->
<style>
  #remoteControlWrapper {
    position: fixed;
    bottom: 12px;
    z-index: 900;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 0 8px;
    pointer-events: none; /* evita bloquear cliques fora do controle */
  }
  .toggle-bar {
    width: 100%;
    max-width: 1100px;
    display: flex;
    justify-content: flex-end;
    padding: 0;
    margin-bottom: 0;
    pointer-events: auto;
  }
  #controlShell {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    pointer-events: auto;
    min-width: 32%;
    max-width: 100%;
    position: relative;
  }
  #remoteControlCard {
    width: auto;
    min-width: 300px;
    max-width: 1100px;
    border-radius: 16px;
  }
  @media (max-width: 640px) {
    #remoteControlWrapper {
      position: static;
      padding: 0;
    }
    #controlShell {
      flex-direction: column;
      align-items: stretch;
      max-width: none;
    }
    #remoteControlCard {
      width: 100%;
      min-width: unset;
    }
  }
  .toggle-handle {
    position: relative;
    width: 32px;
    height: 32px;
    border-radius: 16px 16px 1px 1px;
    padding: 0;
    border: 1px solid rgba(255,255,255,0.12);
    background: linear-gradient(135deg, #4d71ff, #6c8dff);
    color: #fff;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 10px 24px rgba(0,0,0,0.28), 0 4px 12px rgba(77,113,255,0.25);
    align-self: flex-start;
    z-index: 5;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  .toggle-handle:hover {
    transform: translateY(-1px);
    box-shadow: 0 12px 26px rgba(0,0,0,0.32), 0 6px 14px rgba(77,113,255,0.3);
  }
  .control-row {
    display: grid;
    grid-template-columns: 1fr auto auto auto auto auto;
    gap: 10px;
    align-items: center;
  }
  @media (max-width: 640px) {
  .control-row {
      grid-template-columns: 1fr;
      align-items: stretch;
    }
  }
  .mode-toggle { max-width: 220px; width: 100%; }
  .mode-toggle .btn {
    border-radius: 10px;
    padding: 6px 10px;
    border: 1px solid #343a4a;
    color: #e7eaee;
    background: #1b1f2a;
  }
  .mode-toggle .btn:hover { border-color: #4d71ff; color: #ffffff; }
  .mode-toggle .btn.active { background: #4d71ff; border-color: #4d71ff; color: #fff; }
  .level-wrap { min-width: 200px; position: relative; }
  .level-tooltip-anchor {
    position: absolute;
    top: -4px;
    width: 1px;
    height: 1px;
    pointer-events: none;
  }
  .level-slider {
    --lvl: 0%;
    --lvlColor: #ff6b6b;
    --thumb: #ff6b6b;
    appearance: none;
    width: 100%;
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--lvlColor) 0%, var(--lvlColor) var(--lvl), #2c3040 var(--lvl), #2c3040 100%);
    outline: none;
  }
  .level-slider::-webkit-slider-runnable-track {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--lvlColor) 0%, var(--lvlColor) var(--lvl), #2c3040 var(--lvl), #2c3040 100%);
  }
  .level-slider::-moz-range-track {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--lvlColor) 0%, var(--lvlColor) var(--lvl), #2c3040 var(--lvl), #2c3040 100%);
  }
  .level-slider::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid #0f111a;
    background: var(--thumb);
    box-shadow: 0 0 0 2px #1b1f2a;
    margin-top: -4px;
  }
  .level-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid #0f111a;
    background: var(--thumb);
    box-shadow: 0 0 0 2px #1b1f2a;
  }
  .level-input {
    background: #1f2430;
    color: #e7eaee;
    border: 1px solid rgba(255,255,255,0.12);
    min-width: 48px;
    width: 64px;
    text-align: center;
    font-size: 1rem;
    font-weight: 600;
    padding: 3px 6px;
    flex: 0 0 auto;
  }
  .btn-send {
    width: auto;
    border-radius: 12px;
    font-weight: 600;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
  }
  .btn-send.pressed { transform: translateY(1px); }
  .btn-send.holding { background: #dc3545 !important; border-color: #dc3545 !important; color: #fff !important; box-shadow: 0 0 0 0.2rem rgba(220,53,69,0.25); }
  .level-tooltip .tooltip-inner { font-weight: 700; }
  .glass-background {
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    background-color: rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 16px;
    background-image: url();
    background-blend-mode: overlay;
  }
  .advanced-panel {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 14px;
    padding: 12px;
    overflow: hidden;
    transition: max-height .24s ease, opacity .18s ease, transform .24s ease, padding .18s ease;
  }
  .advanced-panel.adv-collapsed {
    max-height: 0;
    opacity: 0;
    transform: translateY(-6px);
    padding-top: 0;
    padding-bottom: 0;
    pointer-events: none;
  }
  .advanced-panel.adv-open {
    max-height: 1200px;
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }
  .advanced-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
  }
  .advanced-note {
    font-size: .85rem;
    color: #9ca3af;
  }
  .advanced-status {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 8px 10px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    color: #e5e7eb;
    font-size: 0.9rem;
  }
  .advanced-status .pill {
    padding: 4px 8px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.85rem;
  }
  .adv-led {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.35);
    box-shadow: 0 0 12px rgba(0,0,0,0.35);
    flex-shrink: 0;
  }
  .led-off { background: #6b7280; }
  .led-on  { background: #22c55e; box-shadow: 0 0 10px rgba(34,197,94,0.8); }
  .led-gap { background: #ef4444; box-shadow: 0 0 10px rgba(239,68,68,0.8); }
  .pill-idle { background: #1f2937; color: #e5e7eb; }
  .pill-run { background: #2563eb; color: #ffffff; }
  .pill-done { background: #16a34a; color: #ffffff; }
  .number-spinner {
    display: grid;
    grid-template-columns: 54px 1fr 54px;
    align-items: stretch;
    border-radius: 14px;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,0.08);
    background: linear-gradient(180deg, #1c202d 0%, #131722 100%);
    box-shadow: 0 6px 12px rgba(0,0,0,0.28);
  }
  .number-spinner:focus-within {
    border-color: #4d71ff;
    box-shadow: 0 0 0 3px rgba(77,113,255,0.18);
  }
  .number-spinner .spin-btn {
    border: none;
    background: #2b3040;
    color: #d1d5db;
    font-size: 1.2rem;
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: background 0.12s ease, color 0.12s ease;
  }
  .number-spinner .spin-btn:first-child { border-right: 1px solid rgba(255,255,255,0.08); }
  .number-spinner .spin-btn:last-child { border-left: 1px solid rgba(255,255,255,0.08); }
  .number-spinner .spin-btn:hover { background: #343a4d; color: #ffffff; }
  .number-spinner .spin-btn:active { background: #41495e; }
  .number-spinner input[type="number"] {
    border: none;
    background: #0f131d;
    color: #e7eaee;
    text-align: center;
    font-weight: 700;
    font-size: 1rem;
    width: 100%;
    padding: 8px 6px;
    box-shadow: none;
  }
  .number-spinner input[type="number"]::-webkit-outer-spin-button,
  .number-spinner input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  .number-spinner input[type="number"] {
    -moz-appearance: textfield;
  }
  .number-spinner input[type="number"]:focus {
    outline: none;
    box-shadow: none;
  }
  .roleta-shortcut-btn {
    min-width: auto !important;
    width: auto;
    max-width: none;
    flex: 0 0 auto;
    padding-left: 12px;
    padding-right: 12px;
  }
  .roleta-shortcut-btn .fa-dice {
    font-size: 1.35rem;
  }
</style>
<div id="remoteControlWrapper">
  <div class="toggle-bar">
    <button id="toggleControl" class="toggle-handle" aria-label="Recolher controle" title="Recolher controle" data-bs-toggle="tooltip">
      <i class="fa-solid fa-xmark"></i>
    </button>
  </div>
  <div id="controlShell">
    <div id="remoteControlCard" class="card p-3 shadow-lg flex-grow-1 glass-background">
      <div id="controlContent" class="control-row">
    <div class="btn-group mode-toggle" role="group" aria-label="Modo">
      <button class="btn btn-outline-light mode-btn" data-mode="SHOCK" title="Choque" data-bs-toggle="tooltip">
        <i class="fa-solid fa-bolt-lightning"></i>
      </button>
      <button class="btn btn-outline-light mode-btn" data-mode="VIBRATION" title="Vibracao" data-bs-toggle="tooltip">
        <i class="fa-solid fa-mobile-screen-button"></i>
      </button>
      <button class="btn btn-outline-light mode-btn" data-mode="LIGHT" title="Luz (LED)" data-bs-toggle="tooltip">
        <i class="fa-solid fa-lightbulb"></i>
      </button>
      <button class="btn btn-outline-light mode-btn" data-mode="BEEP" title="Som (Beep)" data-bs-toggle="tooltip">
        <i class="fa-solid fa-volume-high"></i>
      </button>
    </div>

    <div id="levelRow" class="d-flex align-items-center gap-2 level-wrap">
      <i class="fa-solid fa-gauge-high text-light" title="Intensidade" data-bs-toggle="tooltip"></i>
      <input type="range" class="form-range level-slider" min="0" max="100" step="1" id="levelSlider" data-bs-toggle="tooltip" data-bs-placement="top"/>
      <input id="levelValue" class="form-control form-control-sm level-input" type="text" inputmode="numeric" pattern="[0-9]*" title="Nivel (0 a 100)" data-bs-toggle="tooltip" value="000"/>
    </div>

    <div class="ms-auto d-flex align-items-center gap-2 justify-content-end host-only">
      <div class="form-check form-switch m-0">
        <input class="form-check-input" type="checkbox" id="chanSwitch" aria-label="Canal 1 ou 2" title="Canal 1 ou 2 (host-only)" data-bs-toggle="tooltip"/>
      </div>
    </div>

    <button id="btnSend" class="btn btn-primary btn-send px-3" title="Enviar comando" data-bs-toggle="tooltip">
      <i class="fa-solid fa-power-off"></i>
    </button>

    <button id="btnAdvancedToggle" class="btn btn-dark btn-send px-2 border-0" title="Opcoes avancadas" data-bs-toggle="tooltip" aria-expanded="false">
      <i class="fa-solid fa-chevron-down"></i>
    </button>

    <button id="roletaShortcutBtn" class="btn r3-btn-hold roleta-shortcut-btn fw-semibold px-3" type="button" title="Atalho: girar roleta" data-bs-toggle="tooltip" aria-pressed="false" aria-label="Atalho: girar roleta">
      <span class="r3BtnMask" aria-hidden="true"></span>
      <span class="r3BtnContent"><i class="fa-solid fa-dice"></i></span>
    </button>
  </div>

  <div id="advancedPanel" class="advanced-panel adv-collapsed mt-3">
    <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap mb-2">
      <div class="fw-semibold text-light">Opcoes avancadas</div>
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <div class="advanced-note">Opcoes extras de controle</div>
        <button id="advResetBtn" class="btn btn-sm btn-outline-light py-1 px-2" type="button" title="Restaurar valores padrao" data-bs-toggle="tooltip">
          Reset
        </button>
      </div>
    </div>
    <div class="advanced-status">
      <div id="advLed" class="adv-led led-off" title="Estado do pulso"></div>
      <div id="advStatusPill" class="pill pill-idle">Pronto</div>
      <div class="flex-grow-1 text-end small" id="advCountdownText">-</div>
      <button id="advStopBtn" class="btn btn-danger btn-sm ms-2 d-none" type="button" title="Parar agora">
        <i class="fa-solid fa-stop"></i>
      </button>
    </div>
      <div class="advanced-grid">
        <div>
          <label for="advPulses" class="form-label small text-secondary mb-1">Numero de pulsos</label>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir numero de pulsos">-</button>
            <input id="advPulses" class="form-control form-control-sm" type="number" min="1" step="1" value="1" title="Quantidade de pulsos automaticos ao clicar" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar numero de pulsos">+</button>
          </div>
        </div>
        <div>
          <label for="advDuration" class="form-label small text-secondary mb-1">Duracao (s)</label>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir duracao">-</button>
            <input id="advDuration" class="form-control form-control-sm" type="number" min="0.05" step="0.05" value="0.18" title="Duracao de cada pulso (segundos)" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar duracao">+</button>
          </div>
        </div>
        <div>
          <label for="advDelay" class="form-label small text-secondary mb-1">Intervalo entre pulsos (s)</label>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir intervalo entre pulsos">-</button>
            <input id="advDelay" class="form-control form-control-sm" type="number" min="0" step="0.05" value="1.00" title="Intervalo entre pulsos automaticos (segundos)" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar intervalo entre pulsos">+</button>
          </div>
        </div>
        <div>
          <label for="advPreDelay" class="form-label small text-secondary mb-1">Atraso inicial (s)</label>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir atraso inicial">-</button>
            <input id="advPreDelay" class="form-control form-control-sm" type="number" min="0" step="0.05" value="0.00" title="Tempo antes de iniciar os pulsos (segundos)" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar atraso inicial">+</button>
          </div>
        </div>
        <div>
          <label for="advMirrorChan2" class="form-label small text-secondary mb-1">Espelhar canal oposto</label>
          <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="advMirrorChan2" title="Duplicar todos os comandos no canal oposto" data-bs-toggle="tooltip"/>
            <label class="form-check-label small text-secondary" for="advMirrorChan2">Duplicar todos os comandos no canal oposto</label>
          </div>
        </div>
      </div>
  </div>
</div>
</div>
</div>

<script>
(() => {
  // ===== Bus cross-document =====
  if (!window.__FS_BUS__) {
    (function(){
      const CHANNEL = 'fs-score-channel';
      let bc = null;
      try { bc = new BroadcastChannel(CHANNEL); } catch(e){ bc = null; }
      function _onMessage(msg){
        try {
          const data = (typeof msg === 'string') ? JSON.parse(msg) : msg;
          window.dispatchEvent(new CustomEvent('fs-score:global', { detail: data }));
        } catch(_){ }
      }
      if (bc) bc.onmessage = (ev)=> _onMessage(ev.data);
      window.addEventListener('message', (ev)=>{ if (ev.data && ev.data.__fs_score_msg) _onMessage(ev.data.payload); });
      window.addEventListener('storage', (ev)=>{ if (ev.key === CHANNEL && ev.newValue) _onMessage(JSON.parse(ev.newValue)); });
      window.__FS_BUS__ = {
        send(payload){
          const data = payload || {};
          if (bc) try { bc.postMessage(data); } catch(_){}
          try { if (window.parent && window.parent !== window) window.parent.postMessage({ __fs_score_msg: true, payload: data }, '*'); } catch(_){}
          try { (document.querySelectorAll('iframe')||[]).forEach(f=>{ try{ f.contentWindow.postMessage({ __fs_score_msg: true, payload: data }, '*'); }catch(_){} }); } catch(_){}
          try { localStorage.setItem(CHANNEL, JSON.stringify(data)); localStorage.removeItem(CHANNEL); } catch(_){}
          try { _onMessage(data); } catch(_){}
        },
        on(cb){ if (typeof cb !== 'function') return; window.addEventListener('fs-score:global', (ev)=> cb(ev.detail)); }
      };
    })();
  }

  // ===== Estado =====
  let currentMode = "SHOCK";
  let level = 0;
  let channel = 1;
  const STORAGE_KEY = "remote_control_state_v1";
  const MODES = ["SHOCK", "VIBRATION", "LIGHT", "BEEP"];
  let levelTooltip = null;
  let levelTooltipAnchor = null;
  const LEVEL_PATCH_REASON = "remote-level";
  const CONTROL_ORIGIN = (() => {
    try {
      if (window.__TRYSTERO_STABLE_ID) return String(window.__TRYSTERO_STABLE_ID);
    } catch {}
    try {
      const key = "remote_control_origin_v1";
      let cached = localStorage.getItem(key);
      if (!cached) {
        cached = `rc-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
        localStorage.setItem(key, cached);
      }
      return cached;
    } catch {}
    return `rc-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
  })();
  const lastControlTs = new Map(); // origin -> ts
  let trysteroControlSend = null;
  let trysteroControlGen = 0;
  let levelDebounce = null;
  const ADV_DEFAULTS = { pulses: 1, durationMs: 180, delayMs: 1000, preDelayMs: 0, mirrorChan2: false };
  const ADV_LIMITS = {
    pulses: { min: 1, max: Infinity },
    durationMs: { min: 50, max: Infinity },
    delayMs: { min: 0, max: Infinity },
    preDelayMs: { min: 0, max: Infinity }
  };
  let advanced = { ...ADV_DEFAULTS };
  let advancedOpen = false;

  const HOLD_THRESHOLD_MS = 220; // abaixo disso: clique unico; acima: HOLD
  const GLOBAL_HARD_LIMIT = 15;  // failsafe geral (mantido)

  window.currentMode = currentMode;
  window.level = level;
  window.channel = channel;

  const $  = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const advancedPanelEl = $("#advancedPanel");
  const advancedToggleBtn = $("#btnAdvancedToggle");
  const advancedInputs = {
    pulses: $("#advPulses"),
    duration: $("#advDuration"),
    delay: $("#advDelay"),
    preDelay: $("#advPreDelay"),
    mirrorChan2: $("#advMirrorChan2")
  };
  const advLed = $("#advLed");
  const advStatusPill = $("#advStatusPill");
  const advCountdownText = $("#advCountdownText");
  const advStopBtn = $("#advStopBtn");
  const roletaShortcutBtn = $("#roletaShortcutBtn");
  let advCountdownTimer = null;
  let advCountdownEndAt = 0;
  let advStopSignal = { stop: false };

  function log(msg, lvl="info"){
    try { window.appLog ? window.appLog(msg, lvl) : console.log(msg); } catch {}
  }

  const clampNum = (v, min, max) => {
    const n = Number(v) || 0;
    const upper = Number.isFinite(max) ? max : n;
    return Math.max(min, Math.min(upper, n));
  };
  const msToSecStr = (ms, key="durationMs") => {
    const lim = ADV_LIMITS[key] || ADV_LIMITS.durationMs;
    const upper = Number.isFinite(lim.max) ? lim.max : Number(ms)||0;
    return (clampNum(Number(ms)||0, lim.min, upper) / 1000).toFixed(2);
  };
  const secToMs = (s, key="durationMs") => {
    const lim = ADV_LIMITS[key] || ADV_LIMITS.durationMs;
    const upper = Number.isFinite(lim.max) ? lim.max/1000 : Number(s)||0;
    return Math.round(clampNum(Number(s)||0, lim.min/1000, upper) * 1000);
  };
  const fmtRemain = (ms)=> `${(Math.max(0, ms)/1000).toFixed(ms > 10000 ? 1 : 2)}s`;
  function calcBurstTotalMs(plan){
    const pulses = Math.max(1, Math.round(plan?.pulses || 1));
    const dur = Math.max(0, Math.round(plan?.durationMs || ADV_DEFAULTS.durationMs));
    const gap = Math.max(0, Math.round(plan?.delayMs || ADV_DEFAULTS.delayMs));
    const pre = Math.max(0, Math.round(plan?.preDelayMs || 0));
    // total = pre-delay + (dur+gap) for each pulse, gap skipped after last
    return pre + (pulses * dur) + (Math.max(0, pulses - 1) * gap);
  }

  // ===== Username (mesmo padrao do widget Trystero) =====
  function getUsername(){
    try {
      const u = new URL(location.href);
      const fromUrl = (u.searchParams.get('name') || '').trim();
      if (fromUrl) return fromUrl;
    } catch {}

    // state do widget de conexao
    try {
      const keys = ['trystero_widget_state_v5', 'trystero_widget_state_v2'];
      for (const key of keys) {
        const st = JSON.parse(localStorage.getItem(key) || '{}') || {};
        const name = (st.name || '').trim();
        if (name) return name;
      }
    } catch {}

    return 'eu';
  }

  // ===== Trystero Send + Bridge Local =====
  function makeLocalId(){
    return `local:${Date.now()}:${Math.random().toString(36).slice(2)}`;
  }

  function emitChatBridge(detail){
    // Para widgets/executor locais (contrato do projeto)
    try { window.dispatchEvent(new CustomEvent('chat:message', { detail })); } catch {}
  }

  function sendViaTrystero(text){
    const room = window.__TRYSTERO_ROOM__;
    if (!room || typeof room.makeAction !== 'function') return false;

    try {
      const [sendChat] = room.makeAction('chat');
      if (typeof sendChat !== 'function') return false;

      const username = getUsername();
      const payload = {
        text: String(text).slice(0, 400),
        name: username,
        timestamp: Date.now(),
        id: makeLocalId()
      };

      // 1) envia na rede (Trystero)
      sendChat(payload);

      // 2) tambem emite no bus local (identico ao bridge do widget de chat)
      emitChatBridge({
        id: payload.id,
        key: payload.id,
        text: payload.text,
        peerId: '',
        username,
        raw: payload,
        ts: payload.timestamp,
        origin: 'widget'
      });

      log(`CHAT(TRYSTERO) -> ${payload.text}`);
      return true;
    } catch (e) {
      log(`Falha ao enviar via Trystero: ${e && e.message || e}`, "error");
      return false;
    }
  }

  function bindTrysteroControl(room){
    trysteroControlSend = null;
    trysteroControlGen += 1;
    const gen = trysteroControlGen;

    if (!room || typeof room.makeAction !== "function") return;

    try {
      const pair = room.makeAction('fs-control');
      if (Array.isArray(pair) && typeof pair[0] === "function") {
        trysteroControlSend = pair[0];
      }
      const getControl = Array.isArray(pair) ? pair[1] : null;
      if (typeof getControl === "function") {
        getControl((payload, peerId) => {
          if (gen !== trysteroControlGen) return;
          handleControlPayload(payload, { source: "trystero", peerId });
        });
      }
    } catch (e) {
      log(`fs-control indisponivel (trystero): ${e && e.message || e}`, "warn");
    }
  }

  // ===== Persistencia =====
  function loadState(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return null;
      parsed.advanced = { ...ADV_DEFAULTS, ...(parsed.advanced || {}) };
      parsed.advancedOpen = !!parsed.advancedOpen;
      return parsed;
    } catch(e){
      log(`Falha ao carregar estado: ${e && e.message || e}`, "warn");
      return null;
    }
  }
  function normalizeAdvancedState(next){
    const target = next || advanced || { ...ADV_DEFAULTS };
    target.pulses = clampNum(Math.round(target.pulses || ADV_DEFAULTS.pulses), ADV_LIMITS.pulses.min, ADV_LIMITS.pulses.max);
    target.durationMs = clampNum(Math.round(target.durationMs || ADV_DEFAULTS.durationMs), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
    target.delayMs = clampNum(Math.round(target.delayMs || ADV_DEFAULTS.delayMs), ADV_LIMITS.delayMs.min, ADV_LIMITS.delayMs.max);
    target.preDelayMs = clampNum(Math.round(target.preDelayMs || ADV_DEFAULTS.preDelayMs), ADV_LIMITS.preDelayMs.min, ADV_LIMITS.preDelayMs.max);
    target.mirrorChan2 = !!target.mirrorChan2;
    return target;
  }
  function persistState(){
    try {
      advanced = normalizeAdvancedState(advanced);
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        mode: currentMode,
        level,
        channel,
        advanced,
        advancedOpen
      }));
    } catch(e){
      log(`Falha ao salvar estado: ${e && e.message || e}`, "warn");
    }
  }

  function controlSnapshot(reason){
    return {
      mode: currentMode,
      level,
      channel,
      gapMs: advanced.delayMs,
      baseMs: advanced.durationMs,
      preDelayMs: advanced.preDelayMs,
      mirrorChan2: advanced.mirrorChan2,
      reason: reason || "snapshot"
    };
  }

  function sendControlSnapshot(reason){
    emitControlPatch(controlSnapshot(reason));
  }

  function requestControlSync(reason){
    const from = reason || "remote-control";
    try {
      if (window.__FS_BUS__ && typeof window.__FS_BUS__.send === "function") {
        window.__FS_BUS__.send({ type: "request-control", origin: CONTROL_ORIGIN, from });
      }
    } catch(_){}
    try {
      if (trysteroControlSend) {
        trysteroControlSend({ __fs_req: "control-state", origin: CONTROL_ORIGIN, ts: Date.now(), from });
      }
    } catch(_){}
  }

  function emitControlPatch(patch){
    if (!patch || typeof patch !== "object") return;
    const ts = Date.now();
    const payload = { ...patch, origin: CONTROL_ORIGIN, ts };
    try {
      if (window.__FS_BUS__ && typeof window.__FS_BUS__.send === "function") {
        window.__FS_BUS__.send({ type: "fs-control", payload });
      }
    } catch(_){}
    try {
      if (trysteroControlSend) trysteroControlSend(payload);
    } catch(_){}
  }

  function sendCommand(text){
    if (!text || !String(text).trim()) return;

    // Preferencia: Trystero conectado
    const ok = sendViaTrystero(text);

    // Se nao estiver conectado, ao menos emite local (util para debug/admin)
    if (!ok) {
      const username = getUsername();
      const ts = Date.now();
      const id = makeLocalId();

      emitChatBridge({
        id, key: id,
        text: String(text).slice(0, 400),
        peerId: '',
        username,
        raw: { text, name: username, timestamp: ts, id },
        ts,
        origin: 'widget-local-only'
      });

      log('Trystero desconectado: comando emitido apenas no bus local (chat:message).', "warn");
    }
  }

  // ===== Helpers UI =====
  function initTooltips(){
    if (!(window.bootstrap && window.bootstrap.Tooltip)) return;
    $$('#remoteControlCard [data-bs-toggle="tooltip"]').forEach(el => {
      if (el.id === "levelSlider") return; // slider tem tooltip manual
      new window.bootstrap.Tooltip(el);
    });
  }

  function ensureAnchor(slider){
    if (levelTooltipAnchor && levelTooltipAnchor.isConnected) return levelTooltipAnchor;
    const anchor = document.createElement("span");
    anchor.className = "level-tooltip-anchor";
    slider.parentElement && slider.parentElement.appendChild(anchor);
    levelTooltipAnchor = anchor;
    return anchor;
  }

  function ensureSliderTooltip(text){
    const slider = $("#levelSlider");
    if (!slider || !(window.bootstrap && window.bootstrap.Tooltip)) return;
    const anchor = ensureAnchor(slider);
    if (anchor) {
      const rect = slider.getBoundingClientRect();
      const parentRect = slider.parentElement?.getBoundingClientRect();
      const min = Number(slider.min) || 0;
      const max = Number(slider.max) || 100;
      const val = Math.max(min, Math.min(max, Number(slider.value) || 0));
      const pct = (val - min) / (max - min || 1);
      const thumbW = 18; // conforme CSS
      const offsetLeft = parentRect ? rect.left - parentRect.left : 0;
      const x = offsetLeft + (rect.width - thumbW) * pct + thumbW / 2;
      anchor.style.left = `${x}px`;
    }
    const target = anchor || slider;
    if (!levelTooltip) {
      levelTooltip = new window.bootstrap.Tooltip(target, {
        title: text,
        placement: "top",
        trigger: "manual",
        customClass: "level-tooltip",
        container: slider.parentElement
      });
    }
    if (typeof levelTooltip.setContent === "function") {
      levelTooltip.setContent({ ".tooltip-inner": text });
    } else if (levelTooltip.tip) {
      const inner = levelTooltip.tip.querySelector(".tooltip-inner");
      if (inner) inner.textContent = text;
    } else if (levelTooltip._config) {
      levelTooltip._config.title = text;
    }
    target.setAttribute("data-bs-original-title", text);
    target.setAttribute("title", text);
    if (levelTooltip._element !== target) {
      levelTooltip._element = target;
    }
    levelTooltip._activeTrigger = { manual: true };
    levelTooltip.show();
    levelTooltip.update && levelTooltip.update();
    if (levelTooltip.tip) {
      levelTooltip.tip.classList.add("show");
      levelTooltip.tip.setAttribute("data-popper-placement", "top");
    }
  }

  function updateSliderTooltip(n){
    const slider = $("#levelSlider");
    const text = String(n).padStart(3, "0");
    if (slider) {
      slider.setAttribute("data-bs-original-title", text);
      slider.setAttribute("title", text);
    }
    ensureSliderTooltip(text);
  }

  function updateLevelUi(n){
    const slider = $("#levelSlider");
    const levelInput = $("#levelValue");
    if (slider) {
      // gradiente reativo: verde -> amarelo -> vermelho
      const hue = 120 - Math.round((n/100) * 120); // 120=verde, 0=vermelho
      const color = `hsl(${hue}, 90%, 55%)`;
      slider.style.setProperty('--lvl', `${n}%`);
      slider.style.setProperty('--lvlColor', color);
      slider.style.setProperty('--thumb', color);
      slider.style.background = `linear-gradient(90deg, ${color} 0%, ${color} ${n}%, #2c3040 ${n}%, #2c3040 100%)`;
    }
    if (levelInput) {
      levelInput.value = String(n).padStart(3, "0");
    }
    updateSliderTooltip(n);
  }

  function broadcastBasics(reason){
    emitControlPatch({
      mode: currentMode,
      level,
      channel,
      gapMs: advanced.delayMs,
      baseMs: advanced.durationMs,
      preDelayMs: advanced.preDelayMs,
      mirrorChan2: advanced.mirrorChan2,
      reason: reason || "remote-basic"
    });
  }

  function syncModeUi(){
    $$(".mode-btn").forEach(b => b.classList.toggle("active", b.dataset.mode === currentMode));
  }

  function syncAdvancedUi(){
    advanced = normalizeAdvancedState(advanced);
    if (advancedInputs.pulses) advancedInputs.pulses.value = advanced.pulses;
    if (advancedInputs.duration) advancedInputs.duration.value = msToSecStr(advanced.durationMs, "durationMs");
    if (advancedInputs.delay) advancedInputs.delay.value = msToSecStr(advanced.delayMs, "delayMs");
    if (advancedInputs.preDelay) advancedInputs.preDelay.value = msToSecStr(advanced.preDelayMs, "preDelayMs");
    if (advancedInputs.mirrorChan2) advancedInputs.mirrorChan2.checked = !!advanced.mirrorChan2;
  }

  function getLiveAdvanced(){
    const next = { ...advanced };
    if (advancedInputs.pulses && advancedInputs.pulses.value !== "") {
      const v = parseInt(advancedInputs.pulses.value, 10);
      if (Number.isFinite(v)) next.pulses = v;
    }
    if (advancedInputs.duration && advancedInputs.duration.value !== "") {
      const v = parseFloat(advancedInputs.duration.value);
      if (Number.isFinite(v)) next.durationMs = secToMs(v, "durationMs");
    }
    if (advancedInputs.delay && advancedInputs.delay.value !== "") {
      const v = parseFloat(advancedInputs.delay.value);
      if (Number.isFinite(v)) next.delayMs = secToMs(v, "delayMs");
    }
    if (advancedInputs.preDelay && advancedInputs.preDelay.value !== "") {
      const v = parseFloat(advancedInputs.preDelay.value);
      if (Number.isFinite(v)) next.preDelayMs = secToMs(v, "preDelayMs");
    }
    if (advancedInputs.mirrorChan2) {
      next.mirrorChan2 = !!advancedInputs.mirrorChan2.checked;
    }
    return normalizeAdvancedState(next);
  }

  function updateAdvancedValue(key, raw){
    if (!advanced) advanced = { ...ADV_DEFAULTS };
    if (key === "durationMs" || key === "delayMs" || key === "preDelayMs") {
      advanced[key] = secToMs(raw, key);
    } else {
      advanced[key] = raw;
    }
    advanced = normalizeAdvancedState(advanced);
    syncAdvancedUi();
    persistState();
    broadcastBasics("advanced-change");
  }

  function resetAdvanced(){
    advanced = { ...ADV_DEFAULTS };
    syncAdvancedUi();
    persistState();
    broadcastBasics("advanced-reset");
    stopAdvCountdown(false);
  }

  function getStepDecimals(input){
    const rawStep = (input && input.step) ? input.step.toString() : "1";
    if (!rawStep || rawStep === "any") return 0;
    const parts = rawStep.split(".");
    return parts[1] ? parts[1].length : 0;
  }

  function initNumberSpinners(){
    $$(".number-spinner").forEach(spinner => {
      const input = spinner.querySelector('input[type="number"]');
      if (!input) return;
      const decimals = getStepDecimals(input);
      const step = Number.parseFloat(input.step) || 1;
      const parseVal = () => Number.parseFloat(input.value) || 0;
      const clamp = (v) => {
        let next = v;
        if (input.min !== "" && !Number.isNaN(Number(input.min))) next = Math.max(Number(input.min), next);
        if (input.max !== "" && !Number.isNaN(Number(input.max))) next = Math.min(Number(input.max), next);
        return next;
      };
      const format = (v) => decimals > 0 ? v.toFixed(decimals) : String(Math.round(v));
      const bump = (dir) => {
        const next = clamp(parseVal() + dir * step);
        input.value = format(next);
        input.dispatchEvent(new Event("change", { bubbles: true }));
      };
      let holdDelayTimer = null;
      let holdInterval = null;
      let suppressClick = false;
      const clearHoldTimers = () => {
        if (holdDelayTimer) clearTimeout(holdDelayTimer);
        if (holdInterval) clearInterval(holdInterval);
        holdDelayTimer = null;
        holdInterval = null;
      };
      const startHold = (dir) => {
        bump(dir); // primeira interação imediata
        clearHoldTimers();
        holdDelayTimer = setTimeout(() => {
          holdInterval = setInterval(() => bump(dir), 90);
        }, 320);
      };
      spinner.querySelectorAll("button[data-spin]").forEach(btn => {
        const dir = btn.dataset.spin === "inc" ? 1 : -1;
        btn.addEventListener("pointerdown", e => {
          e.preventDefault();
          suppressClick = true;
          startHold(dir);
        });
        ["pointerup","pointerleave","pointercancel"].forEach(ev => {
          btn.addEventListener(ev, () => {
            clearHoldTimers();
            suppressClick = false;
          });
        });
        // fallback para teclado/space/enter
        btn.addEventListener("click", () => {
          if (suppressClick) { suppressClick = false; return; }
          bump(dir);
        });
      });
      window.addEventListener("pointerup", () => {
        clearHoldTimers();
        suppressClick = false;
      }, { passive: true });
    });
  }

  function setAdvStatus(text, state="idle"){
    if (!advStatusPill) return;
    advStatusPill.textContent = text;
    advStatusPill.className = "pill " + (state === "run" ? "pill-run" : state === "done" ? "pill-done" : "pill-idle");
    setAdvLedPhase(state === "run" ? "on" : "off");
    if (advStopBtn) advStopBtn.classList.toggle("d-none", state !== "run");
  }

  function setAdvLedPhase(phase){
    if (!advLed) return;
    advLed.classList.remove("led-on", "led-off", "led-gap");
    const cls = phase === "on" ? "led-on" : (phase === "gap" ? "led-gap" : "led-off");
    advLed.classList.add(cls);
  }

  function stopAdvCountdown(done=false){
    if (advCountdownTimer) clearInterval(advCountdownTimer);
    advCountdownTimer = null;
    advCountdownEndAt = 0;
    advStopSignal.stop = false;
    if (advCountdownText) advCountdownText.textContent = "-";
    setAdvStatus(done ? "Concluido" : "Pronto", done ? "done" : "idle");
  }

  function startAdvCountdown(plan){
    if (!advCountdownText || !advStatusPill) return;
    stopAdvCountdown(false);
    const total = calcBurstTotalMs(plan);
    const endAt = Date.now() + total;
    advCountdownEndAt = endAt;
    setAdvStatus("Executando", "run");
    const tick = ()=>{
      const remain = Math.max(0, advCountdownEndAt - Date.now());
      if (advCountdownText) advCountdownText.textContent = remain <= 0 ? "0.00s" : fmtRemain(remain);
      if (remain <= 0) stopAdvCountdown(true);
    };
    tick();
    advCountdownTimer = setInterval(tick, 120);
  }

  function setAdvancedOpen(open){
    advancedOpen = !!open;
    if (advancedPanelEl) {
      advancedPanelEl.classList.toggle("adv-open", advancedOpen);
      advancedPanelEl.classList.toggle("adv-collapsed", !advancedOpen);
    }
    if (advancedToggleBtn) {
      advancedToggleBtn.setAttribute("aria-expanded", open ? "true" : "false");
      const icon = advancedToggleBtn.querySelector("i");
      if (icon) icon.className = open ? "fa-solid fa-chevron-up" : "fa-solid fa-chevron-down";
    }
    persistState();
    if (!advancedOpen) stopAdvCountdown(false);
  }

  function shouldUseAdvancedBurst(cfg){
    if (!advancedOpen) return false;
    const normalized = normalizeAdvancedState(cfg || { ...advanced });
    return normalized.pulses > 1
      || normalized.durationMs !== ADV_DEFAULTS.durationMs
      || normalized.delayMs !== ADV_DEFAULTS.delayMs
      || normalized.preDelayMs !== ADV_DEFAULTS.preDelayMs;
  }

  function setMode(m, opts = {}){
    const broadcast = opts.broadcast !== false;
    currentMode = m; window.currentMode = m;
    const showLevel = (m==="SHOCK"||m==="VIBRATION");
    $("#levelRow").classList.toggle("d-none", !showLevel);
    $("#levelSlider").disabled = !showLevel;
    if (!showLevel){
      setLevel(0, { broadcast:false, reason:"mode-no-level" });
    }
    syncModeUi();
    log(`Modo: ${m}`);
    persistState();
    if (broadcast) broadcastBasics("mode-change");
  }
  function cycleMode(direction=1){
    const idx = MODES.indexOf(currentMode);
    const next = MODES[(idx + direction + MODES.length) % MODES.length] || MODES[0];
    setMode(next);
  }

  function setLevel(v, opts = {}){
    const n = Math.max(0, Math.min(100, Number(v)||0));
    const broadcast = opts.broadcast !== false;
    const changed = n !== level;
    level = n; window.level = n;
    $("#levelSlider").value=n;
    updateLevelUi(n);
    if (broadcast && changed) {
      clearTimeout(levelDebounce);
      levelDebounce = setTimeout(()=> emitControlPatch({ level: n, reason: opts.reason || LEVEL_PATCH_REASON }), 80);
    }
    persistState();
    syncModeUi(); // garante que UI de modo não seja alterada por efeitos colaterais
    if (!changed && broadcast === false) return; // evita refazer tooltip em loop de mesma leitura
  }

  function setChannel(c, opts = {}){
    const broadcast = opts.broadcast !== false;
    channel = c; window.channel = c;
    const sw = $("#chanSwitch");
    if (sw) sw.checked = channel === 2;
    log(`Canal: ${channel}`);
    persistState();
    if (broadcast) broadcastBasics("channel-change");
  }

  function buildCmdLine(durationOverride){
    const lvl = (currentMode==="SHOCK"||currentMode==="VIBRATION") ? level : 0;
    const base = `${currentMode},${lvl},${channel}`;
    const dur = Number(durationOverride);
    if (Number.isFinite(dur) && dur > 0) {
      const clamped = clampNum(Math.round(dur), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
      return `${base},${clamped}`;
    }
    return base;
  }

  async function pulseForDuration(durationMs, useHold){
    const dur = clampNum(Math.round(durationMs || 0), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
    if (!useHold) {
      sendCommand(buildCmdLine(dur));
      await sleep(dur);
      return;
    }
    sendCommand(`HOLDON ${buildCmdLine()}`);
    await sleep(dur);
    sendCommand("HOLDOFF");
  }

  // ===== Envio =====
  const btnSend = $("#btnSend");
  const sleep = (ms)=> new Promise(r => setTimeout(r, Math.max(0, ms || 0)));
  function runBurst(cfg){
    advStopSignal = { stop: false };
    const normalized = normalizeAdvancedState(cfg || { ...ADV_DEFAULTS });
    const pulses = clampNum(Math.round(normalized.pulses || 1), ADV_LIMITS.pulses.min, ADV_LIMITS.pulses.max);
    const dur = clampNum(Math.round(normalized.durationMs || ADV_DEFAULTS.durationMs), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
    const gap = clampNum(Math.round(normalized.delayMs || ADV_DEFAULTS.delayMs), ADV_LIMITS.delayMs.min, ADV_LIMITS.delayMs.max);
    const preDelay = clampNum(Math.round(normalized.preDelayMs || ADV_DEFAULTS.preDelayMs), ADV_LIMITS.preDelayMs.min, ADV_LIMITS.preDelayMs.max);
    const useHold = dur !== ADV_DEFAULTS.durationMs;
    startAdvCountdown({ preDelayMs: preDelay, pulses, durationMs: dur, delayMs: gap });
    (async ()=>{
      try {
        if (preDelay > 0 && !advStopSignal.stop) {
          setAdvLedPhase("gap");
          await sleep(preDelay);
        }
        for (let i=0;i<pulses && !advStopSignal.stop;i++){
          setAdvLedPhase("on");
          // usa estado atual (modo/level/canal) a cada pulso
          await pulseForDuration(dur, useHold);
          const isLast = i === pulses - 1;
          if (!isLast && gap > 0 && !advStopSignal.stop) {
            setAdvLedPhase("gap");
            await sleep(gap);
          }
        }
        stopAdvCountdown(!advStopSignal.stop);
      } catch(_){
        stopAdvCountdown(false);
      }
    })();
  }
  function sendOnce(){
    const liveCfg = getLiveAdvanced();
    advanced = liveCfg;
    persistState();
    if (!advancedOpen) {
      stopAdvCountdown(false);
      sendCommand(buildCmdLine());
      return;
    }
    if (!shouldUseAdvancedBurst(liveCfg)) {
      stopAdvCountdown(false);
      const useHold = liveCfg.durationMs !== ADV_DEFAULTS.durationMs;
      if (useHold) {
        pulseForDuration(liveCfg.durationMs, true);
      } else {
        sendCommand(buildCmdLine());
      }
      return;
    }
    runBurst(liveCfg);
  }
  function holdOn(){ if (btnSend) btnSend.classList.add("holding"); sendCommand(`HOLDON ${buildCmdLine()}`); }
  function holdOff(){ if (btnSend) btnSend.classList.remove("holding"); sendCommand("HOLDOFF"); }

  // ===== Botao: clique unico vs segurar =====
  let pressActive = false;
  let holdStarted = false;
  let holdIntentTimer = null;
  let globalFailSafeTimer = null;
  let lastPointerId = null;

  function armGlobalFailsafe(){
    clearTimeout(globalFailSafeTimer);
    globalFailSafeTimer = setTimeout(() => {
      if (pressActive) stopPress(true);
    }, GLOBAL_HARD_LIMIT * 1000);
  }
  function disarmGlobalFailsafe(){
    clearTimeout(globalFailSafeTimer);
    globalFailSafeTimer = null;
  }

  function startPress(e){
    if (pressActive) return;
    pressActive = true;
    holdStarted = false;

    try {
      if (e && e.pointerId != null && btnSend.setPointerCapture) {
        lastPointerId = e.pointerId;
        btnSend.setPointerCapture(e.pointerId);
      }
    } catch(_) {}

    btnSend.classList.add("pressed");

    clearTimeout(holdIntentTimer);
    holdIntentTimer = setTimeout(() => {
      if (!pressActive || holdStarted) return;
      holdStarted = true;
      holdOn();
      armGlobalFailsafe();
    }, HOLD_THRESHOLD_MS);
  }

  function stopPress(fromFailsafe=false){
    if (!pressActive) return;
    pressActive = false;

    clearTimeout(holdIntentTimer);
    disarmGlobalFailsafe();
    btnSend.classList.remove("pressed");
    btnSend.classList.remove("holding");

    try {
      if (lastPointerId != null && btnSend.releasePointerCapture) {
        btnSend.releasePointerCapture(lastPointerId);
      }
    } catch(_) {}
    lastPointerId = null;

    if (holdStarted) holdOff();
    else sendOnce();
  }

  // Eventos
  btnSend.addEventListener("pointerdown", startPress);
  btnSend.addEventListener("pointerup",   () => stopPress(false));
  btnSend.addEventListener("pointerleave",() => stopPress(false));
  btnSend.addEventListener("pointercancel",() => stopPress(false));

  // Redes de seguranca
  window.addEventListener("pointerup",   () => stopPress(false), { passive: true });
  window.addEventListener("mouseup",     () => stopPress(false), { passive: true });
  window.addEventListener("touchend",    () => stopPress(false), { passive: true });
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState !== "visible") stopPress(false);
  });
  window.addEventListener("blur",        () => stopPress(false));
  window.addEventListener("pagehide",    () => stopPress(false));
  window.addEventListener("beforeunload",() => stopPress(false));

  // Toggle de exibicao
  const toggleBtn = $("#toggleControl");
  const content = $("#controlContent");
  const card = $("#remoteControlCard");
  if (toggleBtn && content && card) {
    toggleBtn.addEventListener("click", () => {
      const hidden = card.classList.toggle("d-none");
      content.classList.toggle("d-none", hidden);
      const icon = toggleBtn.querySelector("i");
      if (icon) {
        icon.className = hidden ? "fa-solid fa-gamepad" : "fa-solid fa-xmark";
      }
      toggleBtn.setAttribute("aria-label", hidden ? "Exibir controle" : "Recolher controle");
    });
  }

  // Controles
  $$(".mode-btn").forEach(b => b.addEventListener("click", () => setMode(b.dataset.mode)));
  $("#chanSwitch").addEventListener("change", e => setChannel(e.target.checked ? 2 : 1));
  $("#levelSlider").addEventListener("input", e => setLevel(e.target.value));
  if (advancedToggleBtn) advancedToggleBtn.addEventListener("click", () => setAdvancedOpen(!advancedOpen));
  if (advancedInputs.pulses) advancedInputs.pulses.addEventListener("change", e => updateAdvancedValue("pulses", parseInt(e.target.value,10)));
  if (advancedInputs.duration) advancedInputs.duration.addEventListener("change", e => updateAdvancedValue("durationMs", parseFloat(e.target.value)));
  if (advancedInputs.delay) advancedInputs.delay.addEventListener("change", e => updateAdvancedValue("delayMs", parseFloat(e.target.value)));
  if (advancedInputs.preDelay) advancedInputs.preDelay.addEventListener("change", e => updateAdvancedValue("preDelayMs", parseFloat(e.target.value)));
  if (advancedInputs.mirrorChan2) advancedInputs.mirrorChan2.addEventListener("change", e => updateAdvancedValue("mirrorChan2", !!e.target.checked));
  initNumberSpinners();
  const advResetBtn = $("#advResetBtn");
  if (advResetBtn) advResetBtn.addEventListener("click", resetAdvanced);
  if (advStopBtn) advStopBtn.addEventListener("click", ()=> { advStopSignal.stop = true; stopAdvCountdown(false); setAdvLedPhase("off"); });
  initTooltips();
  const levelInputEl = $("#levelValue");
  if (levelInputEl) {
    const commitLevelInput = () => {
      const raw = (levelInputEl.value || "").replace(/\D/g, "");
      setLevel(raw === "" ? 0 : raw);
    };
    levelInputEl.addEventListener("change", commitLevelInput);
    levelInputEl.addEventListener("blur", commitLevelInput);
    levelInputEl.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        commitLevelInput();
      }
    });
  }

  function getRoletaBtn(){
    return document.getElementById("r3Btn");
  }
  function showRoletaShortcutMessage(msg, duration=1400){
    if (!roletaShortcutBtn) return;
    const original = roletaShortcutBtn.dataset.originalLabel || roletaShortcutBtn.getAttribute("aria-label") || "Atalho: girar roleta";
    roletaShortcutBtn.dataset.originalLabel = original;
    const text = msg || original;
    roletaShortcutBtn.setAttribute("aria-label", text);
    roletaShortcutBtn.setAttribute("title", text);
    if (msg) {
      setTimeout(() => {
        roletaShortcutBtn.setAttribute("aria-label", roletaShortcutBtn.dataset.originalLabel || original);
        roletaShortcutBtn.setAttribute("title", roletaShortcutBtn.dataset.originalLabel || original);
      }, duration);
    }
  }
  function setRoletaShortcutPressed(state){
    if (!roletaShortcutBtn) return;
    roletaShortcutBtn.classList.toggle("r3-pressing", !!state);
    roletaShortcutBtn.setAttribute("aria-pressed", state ? "true" : "false");
  }
  function forwardRoletaEvent(type, srcEvt){
    const target = getRoletaBtn();
    if (!target) return false;
    const opts = { bubbles: true, cancelable: true };
    if (srcEvt && srcEvt.pointerType) opts.pointerType = srcEvt.pointerType;
    if (srcEvt && srcEvt.isPrimary != null) opts.isPrimary = srcEvt.isPrimary;
    let ev;
    try { ev = new PointerEvent(type, opts); } catch(_){ ev = new Event(type, { bubbles: true }); }
    try { return target.dispatchEvent(ev); } catch(_){ return false; }
  }
  function bindRoletaShortcut(){
    if (!roletaShortcutBtn) return;
    let active = false;
    const release = () => {
      if (!active) return;
      active = false;
      setRoletaShortcutPressed(false);
      forwardRoletaEvent("pointerup");
      window.removeEventListener("pointerup", release);
      window.removeEventListener("pointercancel", release);
      window.removeEventListener("blur", release);
    };
    roletaShortcutBtn.addEventListener("pointerdown", e => {
      e.preventDefault();
      if (active) return;
      const ok = forwardRoletaEvent("pointerdown", e);
      if (!ok) {
        showRoletaShortcutMessage("Roleta indisponivel");
        return;
      }
      active = true;
      setRoletaShortcutPressed(true);
      window.addEventListener("pointerup", release, { once: true, passive: true });
      window.addEventListener("pointercancel", release, { once: true, passive: true });
      window.addEventListener("blur", release, { once: true });
    });
    ["pointerup","pointerleave","pointercancel"].forEach(ev => {
      roletaShortcutBtn.addEventListener(ev, release);
    });
  }
  bindRoletaShortcut();

  function shouldIgnoreKey(e){
    const el = e.target;
    if (!el) return false;
    if (el.isContentEditable) return true;
    if (el.tagName === "TEXTAREA") return true;
    if (el.tagName === "INPUT") {
      const type = (el.getAttribute("type") || "").toLowerCase();
      if (["text","search","number","email","password","tel","url"].includes(type)) return true;
    }
    return false;
  }

  document.addEventListener("keydown", e => {
    if (shouldIgnoreKey(e)) return;
    const key = e.key.toLowerCase();
    if (key === "m") {
      e.preventDefault();
      cycleMode(1);
      return;
    }
    if (key === "c") {
      e.preventDefault();
      setChannel(channel === 1 ? 2 : 1);
      return;
    }
    if (key === " " || e.code === "Space") {
      e.preventDefault();
      startPress();
    }
  });

  document.addEventListener("keyup", e => {
    if (shouldIgnoreKey(e)) return;
    if (e.key === " " || e.code === "Space") {
      e.preventDefault();
      stopPress(false);
    }
  });

  function applyAdvancedPatch(payload){
    let changed = false;
    if (payload.baseMs != null) {
      advanced.durationMs = clampNum(Math.round(payload.baseMs), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
      changed = true;
    }
    if (payload.gapMs != null) {
      advanced.delayMs = clampNum(Math.round(payload.gapMs), ADV_LIMITS.delayMs.min, ADV_LIMITS.delayMs.max);
      changed = true;
    }
    if (payload.preDelayMs != null) {
      advanced.preDelayMs = clampNum(Math.round(payload.preDelayMs), ADV_LIMITS.preDelayMs.min, ADV_LIMITS.preDelayMs.max);
      changed = true;
    }
    if (payload.mirrorChan2 != null) {
      advanced.mirrorChan2 = !!payload.mirrorChan2;
      changed = true;
    }
    if (changed) {
      advanced = normalizeAdvancedState(advanced);
      syncAdvancedUi();
      persistState();
    }
  }

  function handleControlPayload(payload, meta = {}){
    if (!payload || typeof payload !== "object") return;
    if (payload.__fs_req === "control-state") {
      const origin = payload.origin || meta.peerId || "unknown";
      if (origin === CONTROL_ORIGIN) return;
      sendControlSnapshot("sync-response");
      return;
    }
    const ts = Number.isFinite(payload.ts) ? payload.ts : (payload.ts ? Number(payload.ts) : 0);
    const origin = payload.origin || meta.peerId || "unknown";
    if (origin === CONTROL_ORIGIN) return;
    const prev = lastControlTs.get(origin) || 0;
    if (ts && ts <= prev) return;
    if (ts) lastControlTs.set(origin, ts);

    if (payload.mode && MODES.includes(payload.mode)) {
      setMode(payload.mode, { broadcast:false });
    }
    if (payload.channel != null) {
      const ch = Number(payload.channel);
      if (Number.isFinite(ch)) setChannel(ch === 2 ? 2 : 1, { broadcast:false });
    }
    const allowLevel = currentMode === "SHOCK" || currentMode === "VIBRATION";
    if (payload.level != null && (allowLevel || Number(payload.level) === 0)) {
      setLevel(payload.level, { broadcast:false, reason:"bus-sync" });
    }
    applyAdvancedPatch(payload);
  }

  function handleControlMessage(msg){
    if (!msg || typeof msg !== "object") return;
    if (msg.type === "fs-control" && msg.payload) {
      handleControlPayload(msg.payload, { source: "bus" });
      return;
    }
    if (msg.type === "request-control") {
      if (msg.origin && msg.origin === CONTROL_ORIGIN) return;
      sendControlSnapshot("request-control");
    }
  }
  if (window.__FS_BUS__ && typeof window.__FS_BUS__.on === "function") {
    window.__FS_BUS__.on(handleControlMessage);
    requestControlSync("remote-control");
  }

  function bindTrysteroRoom(ev){
    const room = ev?.detail?.room || null;
    bindTrysteroControl(room);
    if (room) requestControlSync("trystero-connect");
  }
  window.addEventListener("trystero:room", bindTrysteroRoom);
  if (window.__TRYSTERO_ROOM__) {
    bindTrysteroControl(window.__TRYSTERO_ROOM__);
    requestControlSync("trystero-boot");
  }

  // Inicial
  const savedState = loadState();
  if (savedState?.advanced) {
    advanced = normalizeAdvancedState({ ...ADV_DEFAULTS, ...savedState.advanced });
  }
  advancedOpen = !!savedState?.advancedOpen;
  const initialMode = savedState?.mode || "SHOCK";
  const initialLevel = savedState?.level ?? 0;
  const initialChannel = savedState?.channel || 1;
  setMode(initialMode);
  setLevel(initialLevel, { broadcast:false });
  setChannel(initialChannel);
  syncAdvancedUi();
  setAdvancedOpen(advancedOpen);
  stopAdvCountdown(false);
  ensureSliderTooltip(String(initialLevel).padStart(3, "0"));
  broadcastBasics("remote-init");
})();
</script>
