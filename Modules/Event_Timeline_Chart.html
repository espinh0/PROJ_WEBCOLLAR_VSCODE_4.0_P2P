<!-- GRAFICO EXECUCOES x INTENSIDADE (SHOCK/VIBRATION/LIGHT/BEEP) -->
<div class="card shadow-sm" id="collarEventChartCard" style="background:transparent;border:none;border-radius:.75rem;color:#e5e7eb;">
  <div class="card-body">
    <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap mb-2">
      <span id="collarEventStatus" class="small text-secondary">Carregando Chart.js...</span>
      <button id="collarEventClear" class="btn btn-sm btn-outline-light" type="button">
        <i class="fa-solid fa-eraser me-1"></i>Limpar
      </button>
    </div>
    <div class="position-relative" style="min-height:280px;">
      <canvas id="collarEventCanvas" height="320" role="img" aria-label="Grafico de eventos do collar"></canvas>
    </div>
  </div>
</div>

<script>
(() => {
  if (!window.__FS_BUS__) {
    (function(){
      const CHANNEL = "fs-score-channel";
      let bc = null;
      try { bc = new BroadcastChannel(CHANNEL); } catch (e) { bc = null; }
      function _onMessage(msg){
        try {
          const data = (typeof msg === "string") ? JSON.parse(msg) : msg;
          window.dispatchEvent(new CustomEvent("fs-score:global", { detail: data }));
        } catch(_) {}
      }
      if (bc) bc.onmessage = (ev)=> _onMessage(ev.data);
      window.addEventListener("message", (ev)=>{ if (ev.data && ev.data.__fs_score_msg) _onMessage(ev.data.payload); });
      window.addEventListener("storage", (ev)=>{ if (ev.key === CHANNEL && ev.newValue) _onMessage(JSON.parse(ev.newValue)); });
      window.__FS_BUS__ = {
        send(payload){
          const data = payload || {};
          if (bc) try { bc.postMessage(data); } catch(_) {}
          try { if (window.parent && window.parent !== window) window.parent.postMessage({ __fs_score_msg: true, payload: data }, "*"); } catch(_) {}
          try { (document.querySelectorAll("iframe") || []).forEach((f)=>{ try { f.contentWindow.postMessage({ __fs_score_msg: true, payload: data }, "*"); } catch(_) {} }); } catch(_) {}
          try { localStorage.setItem(CHANNEL, JSON.stringify(data)); localStorage.removeItem(CHANNEL); } catch(_) {}
          try { _onMessage(data); } catch(_) {}
        },
        on(cb){ if (typeof cb !== "function") return; window.addEventListener("fs-score:global", (ev)=> cb(ev.detail)); }
      };
    })();
  }
  const STATUS_EL = document.getElementById("collarEventStatus");
  const CANVAS = document.getElementById("collarEventCanvas");
  const CLEAR_BTN = document.getElementById("collarEventClear");

  if (!CANVAS || !STATUS_EL || !CLEAR_BTN) return;
  CANVAS.style.backgroundColor = "transparent";

  const TYPES = {
    SHOCK:     { label: "SHOCK",     color: "#f97316", iconClass: "fa-bolt-lightning", glyph: "\u26A1" },
    VIBRATION: { label: "VIBRATION", color: "#10b981", iconClass: "fa-mobile-screen-button", glyph: "\u{1F4F3}" },
    LIGHT:     { label: "LIGHT",     color: "#facc15", iconClass: "fa-lightbulb", glyph: "\u{1F4A1}" },
    BEEP:      { label: "BEEP",      color: "#60a5fa", iconClass: "fa-volume-high", glyph: "\u{1F50A}" },
    BTN_STATE: { label: "BTN STATE", color: "#f43f5e", iconClass: "fa-toggle-on", glyph: "\u23FB" }
  };
  const MAX_POINTS = 1000;

  const state = {
    chart: null,
    iconCache: {},
    pending: [],
    counters: {},
    activeHold: null,
    holdSeq: 0,
    serialListener: null,
    serialBusUnsub: null,
    serialBusReadyHandler: null,
    serialStats: {
      seen: 0,
      parsed: 0,
      ignored: 0,
      lastLine: "",
      lastOkSig: "",
      lastOkTs: 0
    }
  };

  const CHART_ORIGIN_KEY = "chart_origin_v1";
  const CHART_ORIGIN = (() => {
    try {
      let id = sessionStorage.getItem(CHART_ORIGIN_KEY);
      if (!id) {
        id = `chart-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
        sessionStorage.setItem(CHART_ORIGIN_KEY, id);
      }
      return id;
    } catch (_) {
      return `chart-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
    }
  })();

  function resetCounters() {
    state.counters = { SHOCK: 0, VIBRATION: 0, LIGHT: 0, BEEP: 0, BTN_STATE: 0 };
  }
  resetCounters();

  function setStatus(text) {
    try { STATUS_EL.textContent = text; } catch(_) {}
  }

  function debugLog(msg) {
    if (!window.__CHART_SERIAL_DEBUG__) return;
    try {
      if (window.appLog) window.appLog(msg, "info");
      else console.log(msg);
    } catch(_) {}
  }

  function loadChartJs() {
    if (window.Chart) return Promise.resolve(window.Chart);
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = "https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js";
      s.async = true;
      s.onload = () => resolve(window.Chart);
      s.onerror = () => reject(new Error("Falha ao carregar Chart.js"));
      document.head.appendChild(s);
    });
  }

  function createIconCanvas(glyph, color) {
    const size = 28;
    const c = document.createElement("canvas");
    c.width = size;
    c.height = size;
    const ctx = c.getContext("2d");

    ctx.fillStyle = "rgba(15, 17, 26, 0.9)";
    ctx.beginPath();
    ctx.arc(size / 2, size / 2, (size / 2) - 1, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = color;
    ctx.font = '900 16px "Font Awesome 6 Free", "Segoe UI Symbol", "Apple Color Emoji", "Noto Color Emoji", sans-serif';
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(glyph, size / 2, size / 2 + 1);

    return c;
  }

  function ensureIcons() {
    Object.entries(TYPES).forEach(([key, cfg]) => {
      if (!state.iconCache[key]) {
        state.iconCache[key] = createIconCanvas(cfg.glyph, cfg.color);
      }
    });
  }

  function isLastPoint(ctx) {
    if (!ctx || !ctx.dataset || !Array.isArray(ctx.dataset.data)) return false;
    return ctx.dataIndex === ctx.dataset.data.length - 1;
  }

  function isSeedPoint(ctx) {
    return !!(ctx && ctx.raw && ctx.raw._seed);
  }

  function makeDatasets() {
    return Object.entries(TYPES).map(([key, cfg]) => ({
      label: cfg.label,
      mode: key,
      data: [],
      borderColor: cfg.color,
      backgroundColor: cfg.color,
      tension: 0.25,
      pointRadius: (ctx) => isSeedPoint(ctx) ? 0 : (isLastPoint(ctx) ? 8 : 0),
      pointHoverRadius: (ctx) => isSeedPoint(ctx) ? 0 : (isLastPoint(ctx) ? 9 : 0),
      pointHitRadius: (ctx) => isSeedPoint(ctx) ? 0 : (isLastPoint(ctx) ? 16 : 10), // permite hover/crosshair em todos os pontos
      borderWidth: 2,
      cubicInterpolationMode: "monotone",
      pointStyle: (ctx) => isLastPoint(ctx) ? (state.iconCache[key] || "circle") : "circle",
      spanGaps: true
    }));
  }

  function clampLevel(n) {
    const num = Number(n);
    if (!Number.isFinite(num)) return 0;
    return Math.max(0, Math.min(100, Math.round(num)));
  }

  function parseBtnState(raw) {
    const match = String(raw || "").match(/\bBTN\s*STATE\s*->\s*(ON|OFF)\b/i);
    if (!match) return null;
    const stateText = match[1].toUpperCase();
    return {
      kind: "pulse",
      mode: "BTN_STATE",
      level: stateText === "ON" ? 100 : 0,
      channel: "-",
      btnState: stateText
    };
  }

  function parseCommand(text, opts = {}) {
    if (!text) return null;
    const raw = String(text || "").trim();
    const btn = parseBtnState(raw);
    if (btn) return btn;
    const requireOk = opts.requireOk !== false;
    const ok = /^OK\b/i.test(raw);
    if (requireOk && !ok) return null;
    const cleaned = ok ? raw.replace(/^OK\s+/i, "").trim() : raw;

    const isHoldOff = /\bHOLDOFF\b/i.test(cleaned);
    const isHoldOn = /\bHOLDON\b/i.test(cleaned);

    if (isHoldOff) return { kind: "holdoff" };

    const match = cleaned.match(/\b(SHOCK|BEEP|BIP|VIBRATION|LIGHT|LUZ)\b\s*,\s*([+-]?\d+(?:\.\d+)?)\s*,\s*(\d+)/i);
    if (!match) return null;

    const rawMode = match[1].toUpperCase();
    const mode =
      rawMode === "BIP" ? "BEEP" :
      rawMode === "LUZ" ? "LIGHT" :
      rawMode;

    const level = clampLevel(match[2]);
    const channel = Math.max(1, Math.min(2, Number(match[3]) || 1));

    return { kind: isHoldOn ? "holdon" : "pulse", mode, level, channel };
  }

  function emitChartEvent(payload, meta = {}) {
    if (!payload || typeof payload !== "object") return;
    if (!window.__FS_BUS__ || typeof window.__FS_BUS__.send !== "function") return;
    const ts = Number(meta.ts) || Date.now();
    const source = meta.source || "serial";
    const eventPayload = { ...payload, ts, origin: CHART_ORIGIN, source };
    try { window.__FS_BUS__.send({ type: "fs-chart", payload: eventPayload }); } catch(_) {}
  }

  function applyChartEvent(payload) {
    if (!payload || typeof payload !== "object") return;
    if (payload.origin && payload.origin === CHART_ORIGIN) return;
    const ts = Number(payload.ts) || Date.now();
    if (payload.kind === "holdoff") {
      finalizeHold(ts);
      return;
    }
    if (!payload.mode) return;
    const parsed = {
      kind: payload.kind || "pulse",
      mode: payload.mode,
      level: payload.level ?? 0,
      channel: payload.channel ?? "-"
    };
    if (payload.btnState) parsed.btnState = payload.btnState;
    enqueuePoint(makePoint(parsed, { ts, source: payload.source || "peer" }));
    flushPending();
  }

  function onSerialLine(line) {
    const text = String(line || "").trim();
    if (!text) return;
    state.serialStats.seen += 1;
    const now = Date.now();
    state.serialStats.lastLine = text;
    if (/^OK\b/i.test(text)) {
      if (state.serialStats.lastOkSig === text && (now - state.serialStats.lastOkTs) < 250) {
        debugLog(`Chart serial OK duplicado em ${now - state.serialStats.lastOkTs}ms: ${text}`);
      }
      state.serialStats.lastOkSig = text;
      state.serialStats.lastOkTs = now;
    }
    const parsed = parseCommand(text, { requireOk: true });
    if (!parsed) {
      state.serialStats.ignored += 1;
      debugLog(`Chart serial ignorado: ${text}`);
      setStatus(`Serial RX ${state.serialStats.seen} (validos: ${state.serialStats.parsed}).`);
      return;
    }
    state.serialStats.parsed += 1;
    const ts = Date.now();
    if (parsed.kind === "holdoff") {
      finalizeHold(ts);
      emitChartEvent({ kind: "holdoff" }, { ts, source: "serial" });
      return;
    }
    emitChartEvent(parsed, { ts, source: "serial" });
    enqueuePoint(makePoint(parsed, { ts, source: "serial" }));
    flushPending();
  }

  function hasFanout(fn) {
    let cur = fn;
    let guard = 0;
    while (cur && guard < 12) {
      if (cur._chartFanout) return true;
      cur = cur._orig;
      guard += 1;
    }
    return false;
  }

  function ensureSerialHook(reason) {
    if (!window.__SERIAL_LINE_LISTENERS__) {
      window.__SERIAL_LINE_LISTENERS__ = [];
    }

    const current = window.logSerialLine;
    if (!current || !hasFanout(current)) {
      const original = current;
      const wrapped = function(line) {
        try {
          const list = window.__SERIAL_LINE_LISTENERS__ || [];
          for (const cb of list) cb(line);
        } catch(_) {}
        if (typeof original === "function") original(line);
      };
      wrapped._chartFanout = true;
      wrapped._orig = original;
      window.logSerialLine = wrapped;
      debugLog(`Chart serial hook aplicado (${reason || "init"}).`);
    } else {
      debugLog(`Chart serial hook ja presente (${reason || "init"}).`);
    }

    const handler = state.serialListener;
    const list = window.__SERIAL_LINE_LISTENERS__;
    if (Array.isArray(list) && handler && !list.includes(handler)) {
      list.push(handler);
    }
  }

  function detachFanoutListener() {
    try {
      const list = window.__SERIAL_LINE_LISTENERS__;
      if (Array.isArray(list) && state.serialListener) {
        const idx = list.indexOf(state.serialListener);
        if (idx >= 0) list.splice(idx, 1);
      }
    } catch(_) {}
  }

  function attachSerialBus(handler) {
    detachFanoutListener();
    if (typeof state.serialBusUnsub === "function") {
      try { state.serialBusUnsub(); } catch(_) {}
    }
    state.serialListener = handler;
    state.serialBusUnsub = window.addSerialRxListener(handler);
    if (state.serialBusReadyHandler) {
      window.removeEventListener("serial-bus-ready", state.serialBusReadyHandler);
      state.serialBusReadyHandler = null;
    }
    setStatus("Escutando serial (bus).");
  }

  function bindSerialMonitor() {
    const handler = (line) => onSerialLine(line);

    if (typeof window.addSerialRxListener === "function") {
      attachSerialBus(handler);
      return;
    }

    state.serialListener = handler;
    ensureSerialHook("bind");
    setStatus("Escutando monitor serial.");

    if (!state.serialBusReadyHandler) {
      state.serialBusReadyHandler = () => {
        if (typeof window.addSerialRxListener === "function") {
          attachSerialBus(handler);
        }
      };
      window.addEventListener("serial-bus-ready", state.serialBusReadyHandler);
    }
  }

  function setBounds() {
    if (!state.chart) return;
    const counts = Object.values(state.counters);
    const maxCount = counts.length ? Math.max(...counts) : 0;
    const min = Math.max(0, maxCount - MAX_POINTS);
    const max = Math.max(min + 6, maxCount + 1);
    state.chart.options.scales.x.suggestedMin = min;
    state.chart.options.scales.x.suggestedMax = max;
  }

  function addPointToChart(payload) {
    if (!payload || !payload.mode || !state.chart) {
      if (payload) state.pending.push(payload);
      return;
    }
    const ds = state.chart.data.datasets.find((d) => d.mode === payload.mode);
    if (!ds) return;

    if (!ds.data.length) {
      ds.data.push({
        x: 0,
        y: 0,
        ch: "-",
        ts: payload.ts,
        source: "seed",
        hold: false,
        holdId: null,
        durationSec: null,
        exec: 0,
        _seed: true
      });
    }

    ds.data.push({
      x: payload.idx,
      y: payload.level,
      ch: payload.channel,
      ts: payload.ts,
      source: payload.source || "bus",
      hold: payload.hold || false,
      holdId: payload.holdId || null,
      durationSec: payload.durationSec ?? null,
      exec: payload.exec ?? null
    });
    if (ds.data.length > MAX_POINTS) {
      ds.data.splice(0, ds.data.length - MAX_POINTS);
    }
  }

  function flushPending() {
    if (!state.chart || !state.pending.length) return;
    const queue = state.pending.slice();
    state.pending.length = 0;
    queue.forEach(addPointToChart);
    setBounds();
    state.chart.update("none");
    const last = queue[queue.length - 1];
    if (last) setStatus(`Exec #${last.exec ?? last.idx} - ${last.mode} ${last.level}% ch${last.channel}`);
  }

  function enqueuePoint(payload) {
    if (!payload) return;
    addPointToChart(payload);
    setBounds();
    setStatus(`Exec #${payload.exec ?? payload.idx} - ${payload.mode} ${payload.level}% ch${payload.channel}`);
    if (state.chart) {
      state.chart.update("none");
    }
  }

  function makePoint(parsed, meta) {
    const mode = parsed.mode;
    if (!(mode in state.counters)) state.counters[mode] = 0;
    const isHold = parsed.kind === "holdon";
    const isPulse = parsed.kind === "pulse";
    let holdId = null;
    if (isHold) {
      holdId = ++state.holdSeq;
      state.activeHold = { id: holdId, mode, channel: parsed.channel, ts: Number(meta && meta.ts) || Date.now() };
    }
    return {
      ...parsed,
      idx: ++state.counters[mode],
      exec: state.counters[mode],
      ts: Number(meta && meta.ts) || Date.now(),
      source: meta && meta.source ? meta.source : "bus",
      hold: isHold,
      holdId,
      durationSec: isPulse ? 0.05 : null
    };
  }

  function finalizeHold(endTs) {
    const active = state.activeHold;
    if (!active) return;
    const ds = state.chart?.data?.datasets?.find((d) => d.mode === active.mode);
    if (ds && Array.isArray(ds.data)) {
      for (let i = ds.data.length - 1; i >= 0; i--) {
        const p = ds.data[i];
        if (p && p.holdId === active.id) {
          p.durationSec = Math.max(0, (endTs - active.ts) / 1000);
          break;
        }
      }
    }
    state.activeHold = null;
    if (state.chart) state.chart.update("none");
  }

  function resetChart() {
    if (state.chart) {
      state.chart.data.datasets.forEach((ds) => { ds.data = []; });
      state.chart.update("none");
    }
    state.pending.length = 0;
    resetCounters();
    setBounds();
    setStatus("Limpo. Aguardando eventos.");
  }

  function initChart(Chart) {
    ensureIcons();

    let cursorX = null;
    const crosshairPlugin = {
      id: "collarCrosshair",
      afterEvent(chart, args) {
        const e = args?.event;
        const area = chart.chartArea;
        if (!area || !e) return;
        const inside = e.x >= area.left && e.x <= area.right && e.y >= area.top && e.y <= area.bottom;
        if (e.type === "mouseout" || e.type === "pointerout" || e.type === "pointerleave" || !inside) {
          cursorX = null;
          return;
        }
        if (e.type === "mousemove" || e.type === "pointermove" || e.type === "pointerdown" || e.type === "touchmove" || e.type === "touchstart") {
          const hits = chart.getElementsAtEventForMode(
            e,
            "nearest",
            { intersect: false, axis: "x" },
            false
          );
          cursorX = hits[0]?.element?.x ?? e.x;
        }
      },
      afterDraw(chart) {
        if (cursorX == null) return;
        const area = chart.chartArea;
        if (!area) return;
        const { ctx } = chart;
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cursorX, area.top);
        ctx.lineTo(cursorX, area.bottom);
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 3]);
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.stroke();
        ctx.restore();
      }
    };

    const pointsOnTopPlugin = {
      id: "collarPointsOnTop",
      afterDatasetsDraw(chart) {
        const { ctx } = chart;
        chart.data.datasets.forEach((_, i) => {
          const meta = chart.getDatasetMeta(i);
          if (!meta || meta.hidden) return;
          const points = meta.data || [];
          for (const pt of points) {
            if (!pt || pt.skip || typeof pt.draw !== "function") continue;
            pt.draw(ctx);
          }
        });
      }
    };

    state.chart = new Chart(CANVAS.getContext("2d"), {
      type: "line",
      data: { datasets: makeDatasets() },
      options: {
        backgroundColor: "transparent",
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        interaction: {
          mode: "nearest",
          intersect: false,
          axis: "x"
        },
        hover: {
          mode: "nearest",
          intersect: false,
          axis: "x"
        },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const ds = ctx.dataset;
                if (ctx.raw && ctx.raw._seed) return "";
                const ch = ctx.raw && ctx.raw.ch ? ctx.raw.ch : "-";
                const base = `${ds.label}: ${ctx.parsed.y}% (ch ${ch})`;
                let total = 0;
                if (Array.isArray(ds.data)) {
                  for (const p of ds.data) {
                    if (!p || !Number.isFinite(p.durationSec)) continue;
                    if (typeof p.x === "number" && p.x <= ctx.parsed.x) {
                      total += p.durationSec;
                    }
                  }
                }
                if (ctx.raw && ctx.raw.hold && Number.isFinite(ctx.raw.durationSec)) {
                  return [
                    base,
                    `Duracao: ${ctx.raw.durationSec.toFixed(2)}s`,
                    `Total acumulado: ${total.toFixed(2)}s`
                  ];
                }
                return [
                  base,
                  `Total acumulado: ${total.toFixed(2)}s`
                ];
              },
              title: (items) => {
                if (!items?.length) return "";
                const idx = items[0].parsed.x;
                const exec = items[0].raw && Number.isFinite(items[0].raw.exec)
                  ? items[0].raw.exec
                  : (Number.isFinite(idx) ? idx + 1 : idx);
                return `Execucao #${exec}`;
              }
            },
            intersect: false,
            mode: "nearest"
          }
        },
        scales: {
          x: {
            type: "linear",
            title: { display: true, text: "Execucao (#)" },
            ticks: { stepSize: 1, autoSkip: true, autoSkipPadding: 12 },
            grid: { color: "rgba(255,255,255,0.05)" }
          },
          y: {
            beginAtZero: true,
            suggestedMax: 100,
            title: { display: true, text: "Intensidade" },
            ticks: { stepSize: 10 },
            grid: { color: "rgba(255,255,255,0.05)" }
          }
        }
      },
      plugins: [crosshairPlugin, pointsOnTopPlugin]
    });
    setBounds();
    flushPending();
    setStatus("Pronto. Aguardando eventos (SHOCK/VIBRATION/LIGHT/BEEP/BTN STATE).");
  }

  CLEAR_BTN.addEventListener("click", resetChart);
  bindSerialMonitor();
  window.addEventListener("serial-connected", () => {
    const usingBus = typeof window.addSerialRxListener === "function" && typeof state.serialBusUnsub === "function";
    if (!usingBus) ensureSerialHook("serial-connected");
  });
  window.addEventListener("beforeunload", () => {
    try {
      if (typeof state.serialBusUnsub === "function") {
        state.serialBusUnsub();
        state.serialBusUnsub = null;
      }
      if (state.serialBusReadyHandler) {
        window.removeEventListener("serial-bus-ready", state.serialBusReadyHandler);
        state.serialBusReadyHandler = null;
      }
    } catch(_){ }
    try {
      const list = window.__SERIAL_LINE_LISTENERS__;
      if (Array.isArray(list) && state.serialListener) {
        const idx = list.indexOf(state.serialListener);
        if (idx >= 0) list.splice(idx, 1);
      }
    } catch(_){}
  });

  if (window.__FS_BUS__ && typeof window.__FS_BUS__.on === "function") {
    window.__FS_BUS__.on((msg) => {
      if (!msg || msg.type !== "fs-chart" || !msg.payload) return;
      applyChartEvent(msg.payload);
    });
  }

  loadChartJs()
    .then((Chart) => initChart(Chart))
    .catch((err) => {
      console.error(err);
      setStatus("Falha ao carregar Chart.js");
    });
})();
</script>
