<!-- CONEXAO SERIAL (Web Serial) -->
<div class="host-only">
  <div class="card shadow-sm serial-hidden" id="serialPortCard" style="background:#111;border:1px solid #333;border-radius:.75rem;color:#e5e7eb;display:none;">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2" style="background:#0c0c0e;border-bottom:1px solid #333;color:#e5e7eb;border-top-left-radius:.65rem;border-top-right-radius:.65rem;">
      <div class="d-flex align-items-center gap-2">
        <i class="fa-solid fa-plug"></i>
        <div class="fw-semibold">Conexao do Transmissor</div>
      </div>
      <div class="d-flex align-items-center gap-2">
        <div class="d-flex align-items-center gap-1">
          <label class="small text-secondary">Baud</label>
          <select id="wsBaud" class="form-select form-select-sm" style="width:auto;">
            <option />115200
            <option />57600
            <option />38400
            <option />19200
            <option />9600
          </select>
        </div>
        <div class="form-check form-switch m-0">
          <input class="form-check-input" type="checkbox" id="wsAuto" checked />
          <label class="form-check-label small" for="wsAuto">Auto-reconectar</label>
        </div>
        <button id="wsConnect" class="btn btn-sm btn-primary">
          <i class="fa-solid fa-circle-play me-1"></i>Conectar
        </button>
        <button id="wsDisconnect" class="btn btn-sm btn-outline-light" disabled>
          <i class="fa-solid fa-circle-stop me-1"></i>Desconectar
        </button>
      </div>
    </div>
    <div class="card-body p-3">
      <div class="row g-2 align-items-center">
      <div class="col-12 col-md-6">
        <div class="small text-secondary">Status</div>
        <div id="wsStatus" class="fw-semibold">Desconectado</div>
      </div>
      <div class="col-12 col-md-6">
        <div class="small text-secondary">Porta</div>
        <div id="wsPortInfo" class="text-truncate"><em>--</em></div>
      </div>
    </div>

    <div class="mt-2 small text-secondary">
      Dica: o Web Serial precisa de <strong>HTTPS</strong> (ou <code>localhost</code>) e um gesto do usuario para abrir a porta.
    </div>
    </div>
  </div>

<script>
(() => {
  console.log("üîå [SERIAL] Script iniciando...");
  
  const $ = s => document.querySelector(s);
  const statusEl = $("#wsStatus");
  const portInfoEl = $("#wsPortInfo");
  const btnConnect = $("#wsConnect");
  const btnDisconnect = $("#wsDisconnect");
  const baudSel = $("#wsBaud");
  const autoChk = $("#wsAuto");

  console.log("üîå [SERIAL] Elementos:", {
    statusEl: !!statusEl,
    portInfoEl: !!portInfoEl,
    btnConnect: !!btnConnect,
    btnDisconnect: !!btnDisconnect,
    baudSel: !!baudSel,
    autoChk: !!autoChk
  });

  const hasWebSerial = !!navigator.serial;
  console.log("üîå [SERIAL] Web Serial dispon√≠vel:", hasWebSerial);
  
  const HOST_REQUIRED_MSG = "Habilite 'host' para abrir a serial";
  const LAST_BAUD_KEY = "ws.lastBaud";
  const WANT_AUTO_KEY = "ws.autoReconnect";

  const state = {
    port: null,
    writer: null,
    reader: null,
    readPipeClosed: null,
    portOpening: null
  };

  const SERIAL_BUS_KEY = "__SERIAL_RX_LISTENERS__";
  window[SERIAL_BUS_KEY] = window[SERIAL_BUS_KEY] || [];

  function ensureSerialBusHelpers() {
    if (typeof window.addSerialRxListener !== "function") {
      window.addSerialRxListener = function(listener) {
        if (typeof listener !== "function") return () => {};
        const list = window[SERIAL_BUS_KEY];
        if (!list.includes(listener)) list.push(listener);
        return () => {
          const idx = list.indexOf(listener);
          if (idx >= 0) list.splice(idx, 1);
        };
      };
    }

    if (typeof window.removeSerialRxListener !== "function") {
      window.removeSerialRxListener = function(listener) {
        if (typeof listener !== "function") return;
        const list = window[SERIAL_BUS_KEY];
        const idx = list.indexOf(listener);
        if (idx >= 0) list.splice(idx, 1);
      };
    }
  }

  ensureSerialBusHelpers();
  try {
    window.dispatchEvent(new Event("serial-bus-ready"));
  } catch(_) {}

  function log(msg, level = "info") {
    try {
      if (window.appLog) window.appLog(msg, level);
      else console[level === "error" ? "error" : level === "warn" ? "warn" : "log"](msg);
    } catch {}
  }

  function isHost() {
    try {
      const peer = (window.Flowgate && window.Flowgate.localPeer) ? window.Flowgate.localPeer : window.__TRYSTERO_PEER__;
      const tags = (peer && typeof peer.getLocalTags === "function")
        ? peer.getLocalTags()
        : [];
      const hasTag = Array.isArray(tags) && tags.map(t => String(t || "").toLowerCase()).includes("host");
      if (hasTag) return true;
      return document.documentElement.classList.contains("host-on");
    } catch { return false; }
  }

  function setStatus(text, portText) {
    statusEl.textContent = text;
    portInfoEl.textContent = portText ?? portInfoEl.textContent;
  }
  function setButtons(connected) {
    const host = isHost();
    const disabled = connected || !hasWebSerial || !host || !!state.portOpening;
    console.log("üîå [SERIAL] setButtons:", {connected, hasWebSerial, host, portOpening: !!state.portOpening, "btnConnect.disabled": disabled});
    btnConnect.disabled = disabled;
    btnDisconnect.disabled = !connected;
  }

  function syncGlobals() {
    window.port = state.port;
    window.writer = state.writer;
    window.reader = state.reader;
  }

  async function refreshHostGuard() {
    const host = isHost();
    if (!host) {
      if (state.port) {
        try { await disconnectSerial(); } catch {}
      }
      setButtons(false);
      if (!state.port) setStatus(HOST_REQUIRED_MSG);
    } else {
      setButtons(!!state.port);
      if (!state.port) {
        setStatus("Desconectado");
        if (autoChk.checked) scheduleReconnect();
      }
    }
  }

  function prelimCheck() {
    if (!hasWebSerial) {
      setStatus("Navegador sem Web Serial.");
      log("Este navegador nao oferece navigator.serial. Use Chrome/Edge/Opera em HTTPS ou localhost.", "error");
      return false;
    }
    const httpsOk = location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";
    if (!httpsOk) {
      setStatus("Necessita HTTPS/localhost");
      log("Web Serial exige site servido via HTTPS (ou localhost).", "warn");
      return false;
    }
    const host = isHost();
    const bypassHost = localStorage.getItem('serial.bypassHostCheck') === '1';
    console.log("DEBUG prelimCheck - isHost:", host, "bypass:", bypassHost);
    if (!host && !bypassHost) {
      setStatus(HOST_REQUIRED_MSG);
      log("Marcador de host desligado: serial bloqueada. (Use localStorage para bypass)", "warn");
      console.warn("Host check failed - tags:", (window.Flowgate && window.Flowgate.localPeer) ? "flowgate dispon√≠vel" : "sem flowgate", "classList:", document.documentElement.className);
      return false;
    }
    return true;
  }

  async function openPort(port, baud) {
    await port.open({ baudRate: baud, bufferSize: 255 });
    try { await port.setSignals({ dataTerminalReady: true, requestToSend: false }); } catch {}
    state.port = port;

    state.writer = port.writable ? port.writable.getWriter() : null;

    const textDecoder = new TextDecoderStream();
    state.readPipeClosed = port.readable.pipeTo(textDecoder.writable).catch(() => {});
    const reader = textDecoder.readable.getReader();
    state.reader = reader;

    (async () => {
      let carry = "";
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          carry += value;
          let idx;
          while ((idx = carry.search(/\r\n|\n/)) >= 0) {
            const line = carry.slice(0, idx);
            carry = carry.slice(idx + (carry.slice(idx, idx + 2) === "\r\n" ? 2 : 1));
            dispatchSerialLine(line);
          }
        }
      } catch (e) {
        log(`Leitura interrompida: ${e.message || e}`, "warn");
      } finally {
        try { reader.releaseLock(); } catch {}
      }
    })();

    setStatus("Conectado");
    setButtons(true);
    describePort(port);
    syncGlobals();
    window.dispatchEvent(new Event("serial-connected"));
    log(`Porta aberta @${baud} bps`);
  }

  function dispatchSerialLine(line) {
    try {
      const listeners = window[SERIAL_BUS_KEY];
      if (Array.isArray(listeners) && listeners.length) {
        listeners.slice().forEach((cb) => {
          try { cb(line); } catch(_) {}
        });
      }

      if (typeof window.logSerialLine === "function") {
        // Log module already formats/prints; avoid duplicar aqui
        window.logSerialLine(line);
      } else {
        log(`SERIAL: ${line}`, "info");
      }
    } catch {}
  }

  function describePort(port) {
    try {
      const info = port.getInfo ? port.getInfo() : {};
      const vid = info.usbVendorId != null ? "0x" + info.usbVendorId.toString(16).padStart(4, "0") : "--";
      const pid = info.usbProductId != null ? "0x" + info.usbProductId.toString(16).padStart(4, "0") : "--";
      portInfoEl.textContent = `VID: ${vid} PID: ${pid}`;
    } catch { portInfoEl.textContent = "--"; }
  }

  async function ensureSerial(opts = {}) {
    const prompt = opts.prompt !== false;
    const quiet = opts.quiet === true;

    if (state.port && state.port.readable && state.port.writable) return;
    if (state.portOpening) return state.portOpening;
    if (!prelimCheck()) {
      if (!isHost()) throw new Error(HOST_REQUIRED_MSG);
      throw new Error("Web Serial indisponivel neste contexto.");
    }

    state.portOpening = (async () => {
      const baud = parseInt(baudSel.value || localStorage.getItem(LAST_BAUD_KEY) || "115200", 10);
      localStorage.setItem(LAST_BAUD_KEY, String(baud));

      const granted = await navigator.serial.getPorts();
      if (granted && granted.length) {
        const port = granted[0];
        log("Usando porta previamente concedida.");
        await openPort(port, baud);
        return;
      }

      if (!prompt) {
        if (!quiet) log("Auto-reconnect ignorado: nenhuma porta previamente concedida.", "warn");
        return;
      }

      const filters = [];
      const port = await navigator.serial.requestPort({ filters }).catch(e => { throw e; });
      await openPort(port, baud);
    })();

    try { await state.portOpening; }
    finally { state.portOpening = null; }
  }

  async function disconnectSerial(opts = {}) {
    const forgetGrant = opts.forgetPermission === true;
    const portRef = state.port;
    try {
      if (state.reader) {
        try { await state.reader.cancel(); } catch {}
        try { state.reader.releaseLock && state.reader.releaseLock(); } catch {}
      }
      if (state.readPipeClosed) { try { await state.readPipeClosed; } catch {} }
      if (state.writer) {
        try { await state.writer.close?.(); } catch {}
        try { state.writer.releaseLock && state.writer.releaseLock(); } catch {}
      }
      if (state.port) {
        try { await state.port.close(); } catch {}
      }
    } finally {
      state.reader = null;
      state.writer = null;
      state.port = null;
      state.readPipeClosed = null;
      state.portOpening = null;
      syncGlobals();
      setStatus("Desconectado");
      setButtons(false);
      portInfoEl.textContent = "--";
      window.dispatchEvent(new Event("serial-disconnected"));
      log("Porta desconectada.");
    }
    if (forgetGrant && portRef && typeof portRef.forget === "function") {
      try {
        await portRef.forget();
        log("Permissao da porta esquecida (requer nova confirmacao do navegador).");
      } catch (e) {
        log(`Nao foi possivel limpar a permissao: ${e?.message || e}`, "warn");
      }
    }
  }

  let reconnectTimer = null;
  let reconnectDelay = 1000;
  function scheduleReconnect() {
    if (!autoChk.checked) return;
    if (!isHost()) return;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(async () => {
      reconnectTimer = null;
      if (autoChk.checked && !state.port && isHost()) {
        try { await ensureSerial({ prompt: false, quiet: true }); }
        catch (e) {
          log(`Auto-reconnect falhou: ${e.message || e}`, "warn");
          reconnectDelay = Math.min(reconnectDelay * 2, 10000);
          scheduleReconnect();
        } finally {
          reconnectDelay = 1000;
        }
      }
    }, reconnectDelay);
  }

  if (hasWebSerial) {
    navigator.serial.addEventListener("connect", async () => {
      log("Dispositivo serial conectado (evento).");
      scheduleReconnect();
    });
    navigator.serial.addEventListener("disconnect", async () => {
      log("Dispositivo serial desconectado (evento).", "warn");
      await disconnectSerial().catch(() => {});
      scheduleReconnect();
    });
  }

  btnConnect.addEventListener("click", async () => {
    console.log("‚úì Bot√£o conectar clicado");
    try { 
      console.log("Iniciando ensureSerial...");
      await ensureSerial(); 
    }
    catch (e) {
      const msg = e && e.name === "NotFoundError" ? "Usuario cancelou a selecao da porta." : (e.message || String(e));
      console.error("Erro ao conectar:", msg, e);
      log(`Falha ao conectar: ${msg}`, e && e.name === "NotFoundError" ? "warn" : "error");
      setStatus("Desconectado");
      setButtons(false);
    }
  });

  btnDisconnect.addEventListener("click", async () => {
    await disconnectSerial({ forgetPermission: true });
  });

  baudSel.addEventListener("change", () => {
    localStorage.setItem(LAST_BAUD_KEY, baudSel.value);
    if (state.port) {
      log(`Baud alterado para ${baudSel.value}. Desconecte e reconecte para aplicar.`, "warn");
    }
  });

  autoChk.addEventListener("change", () => {
    localStorage.setItem(WANT_AUTO_KEY, autoChk.checked ? "1" : "0");
    if (autoChk.checked) scheduleReconnect();
  });

  window.addEventListener("flowgate:local_tags_changed", refreshHostGuard);
  window.addEventListener("trystero:localTags", refreshHostGuard);

  const savedBaud = localStorage.getItem(LAST_BAUD_KEY);
  if (savedBaud) baudSel.value = savedBaud;
  const savedAuto = localStorage.getItem(WANT_AUTO_KEY);
  if (savedAuto != null) autoChk.checked = savedAuto === "1";
  else autoChk.checked = true;

  setButtons(false);
  if (!hasWebSerial) {
    setStatus("Navegador sem Web Serial");
  } else {
    setStatus("Desconectado");
    navigator.serial.getPorts().then((ports) => {
      if (ports.length && autoChk.checked && isHost()) {
        log("Abrindo porta previamente concedida (auto).");
        ensureSerial({ prompt: false, quiet: true }).catch(e => log(`Auto open falhou: ${e.message || e}`, "warn"));
      } else if (!isHost()) {
        setStatus(HOST_REQUIRED_MSG);
      }
    });
  }
  refreshHostGuard();

  syncGlobals();
  window.ensureSerial = ensureSerial;
  window.disconnectSerial = disconnectSerial;

  console.log("üîå [SERIAL] Script carregado com sucesso!");
  console.log("üîå [SERIAL] btnConnect.disabled:", btnConnect ? btnConnect.disabled : "BOT√ÉO N√ÉO ENCONTRADO");

})();
</script>

<!-- PATCH: habilita receber comandos externos (chat -> serial) -->
<script>
(() => {
  const enc = new TextEncoder();

  async function writeLine(line) {
    line = String(line ?? "").trim();
    if (!line) return;

    try {
      if (!window.port || !window.port.writable) {
        throw new Error("Porta serial indisponivel");
      }

      if (!window.writer) {
        try { window.writer = window.port.writable.getWriter(); }
        catch (e) { if (!/locked/i.test(String(e))) throw e; }
      }

      const payload = /(\r\n|\n)$/.test(line) ? line : (line + "\n");
      await window.writer.write(enc.encode(payload));

      try { (window.appLog || console.log)(`TX: ${payload.replace(/\n$/, "")}`); } catch {}
    } catch (err) {
      try { (window.appLog || console.error)(`TX erro: ${err && err.message ? err.message : err}`); } catch {}
    }
  }

  window.collarSend = async (line) => writeLine(line);
  window.SerialBridge = window.SerialBridge || {};
  window.SerialBridge.send = window.collarSend;
  if (!window.executorLogs) window.executorLogs = [];
  if (typeof window.getExecutorLogs !== 'function') {
    window.getExecutorLogs = function(){ return window.executorLogs; };
  }
  if (typeof window.executorLog !== 'function') {
    window.executorLog = function(action, cmd, origin, details){
      try {
        const entry = {
          ts: Date.now(),
          tsStr: new Date().toLocaleTimeString(),
          action,
          cmd,
          origin: origin || 'unknown',
          details: details || {}
        };
        window.executorLogs.push(entry);
        if (window.executorLogs.length > 1000) window.executorLogs.shift();
      } catch(_) {}
    };
  }
  if (!window.SerialBridge._executorHooked) {
    window.SerialBridge._executorHooked = true;
    const origSend = window.SerialBridge.send;
    window.SerialBridge.send = function(line) {
      try {
        if (typeof window.executorLog === 'function') {
          window.executorLog('sent', String(line || ''), 'SerialBridge', { path: 'SerialBridge.send' });
        }
      } catch(_) {}
      return origSend.apply(this, arguments);
    };
  }

  window.addEventListener("collar:tx", (e) => {
    const line = e?.detail?.line ? e.detail.line : "";
    if (!line) return;
    writeLine(line);
  });

  try { (window.appLog || console.log)("PATCH serial forwarder: pronto (escutando 'collar:tx')."); } catch {}
})();
</script>

<!-- EXECUTOR FLOW LOG √î√á√∂ Painel de log do fluxo de comandos -->
<div class="host-only">
  <div class="card shadow-sm" style="background:#111;border:1px solid #333;border-radius:.75rem;color:#e5e7eb;">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2" style="background:#0c0c0e;border-bottom:1px solid #333;color:#e5e7eb;border-top-left-radius:.65rem;border-top-right-radius:.65rem;">
      <div class="d-flex align-items-center gap-2">
        <i class="fa-solid fa-flow-branch"></i>
        <div class="fw-semibold">Executor Flow Log</div>
      </div>
      <div class="d-flex flex-wrap gap-2">
        <button id="efClear" class="btn btn-sm btn-outline-light" title="Limpar">Limpar</button>
        <button id="efExport" class="btn btn-sm btn-outline-light" title="Exportar como JSON">Exportar</button>
        
        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="efAutoScroll" checked />
          <label class="form-check-label small" for="efAutoScroll">Auto-scroll</label>
        </div>
      </div>
        </div>
        <div class="card-body p-3">
        <div id="executor-flow-log" class="border rounded p-3" 
          style="height: 300px; overflow-y: auto; font-size: 0.9em; font-family: 'Monaco', 'Courier New', monospace; background: rgba(0,0,0,0.08);">
      <div class="text-muted text-center py-4"><small>Aguardando eventos...</small></div>
    </div>

    <div class="form-text mt-2">
      <i class="fa-solid fa-circle-info me-1"></i>
      Mostra o fluxo de comandos: origem ‚Üí Executor ‚Üí Serial. 
      Origem: <span class="badge bg-warning text-dark">chat</span>
      <span class="badge bg-primary">flowgate</span>
      <span class="badge bg-success">serial adapter</span>
      <span class="badge bg-danger">error</span>
    </div>
    </div>
    </div>
  </div>
</div>

<style>
  .executor-log-entry {
    background-color: rgba(255, 255, 255, 0.02);
    border-radius: 4px;
    font-size: 0.85rem;
    line-height: 1.4;
  }

  .executor-log-entry .badge {
    font-size: 0.7rem;
    padding: 0.25rem 0.5rem;
    font-weight: 600;
  }

  .executor-log-entry code {
    background-color: rgba(0, 0, 0, 0.3);
    padding: 0.25rem 0.4rem;
    border-radius: 3px;
    display: block;
    word-break: break-all;
  }

  #executor-flow-log {
    scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
    scrollbar-width: thin;
  }

  #executor-flow-log::-webkit-scrollbar {
    width: 6px;
  }

  #executor-flow-log::-webkit-scrollbar-track {
    background: transparent;
  }

  #executor-flow-log::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
  }

  #executor-flow-log::-webkit-scrollbar-thumb:hover {
    background-color: rgba(255, 255, 255, 0.4);
  }
</style>

<script>
(() => {
  const logPanel = document.getElementById('executor-flow-log');
  const btnClear = document.getElementById('efClear');
  const btnExport = document.getElementById('efExport');
  const cbAutoScroll = document.getElementById('efAutoScroll');

  function updateLogDisplay() {
    if (typeof window.getExecutorLogs !== 'function') return;
    
    const logs = window.getExecutorLogs();
    const recent = logs.slice(-30);
    
    let html = '';
    
    if (recent.length === 0) {
      html = '<div class="text-muted text-center py-4"><small>Aguardando eventos...</small></div>';
    } else {
      for (let i = 0; i < recent.length; i++) {
        const log = recent[i];
        const badgeClass = getActionBadgeClass(log.action);
        const originBg = getOriginBadgeClass(log.origin);
        
        html += `<div class="executor-log-entry mb-2 p-2 border-start border-3" style="border-color: var(--bs-${badgeClass.replace('bg-', '')});">
          <div class="d-flex align-items-center gap-2 mb-1 flex-wrap">
            <span class="badge ${badgeClass}">${getActionIcon(log.action)} ${log.action.toUpperCase()}</span>
            <span class="badge ${originBg}" title="Origem">${escapeHtml(log.origin)}</span>
            <small class="text-muted">${log.tsStr}</small>
          </div>
          <code class="text-break">${escapeHtml(log.cmd)}</code>`;
        
        if (log.details && Object.keys(log.details).length > 0) {
          html += `<div class="small text-muted mt-1">
            ${Object.entries(log.details).map(([k, v]) => `${escapeHtml(k)}: ${escapeHtml(JSON.stringify(v))}`).join(' | ')}
          </div>`;
        }
        
        html += `</div>`;
      }
    }
    
    logPanel.innerHTML = html;
    if (cbAutoScroll.checked) {
      logPanel.scrollTop = logPanel.scrollHeight;
    }
  }

  function getActionBadgeClass(action) {
    switch(action) {
      case 'received': return 'bg-info';
      case 'sent': return 'bg-success';
      case 'error': return 'bg-danger';
      case 'init': return 'bg-secondary';
      default: return 'bg-dark';
    }
  }

  function getActionIcon(action) {
    switch(action) {
      case 'received': return '‚Üì';
      case 'sent': return '‚Üë';
      case 'error': return '‚ö†';
      case 'init': return '‚óè';
      default: return '‚Ä¢';
    }
  }

  function getOriginBadgeClass(origin) {
    if (origin.includes('chat')) return 'bg-warning text-dark';
    if (origin.includes('trystero') || origin.includes('flowgate')) return 'bg-primary';
    if (origin.includes('holdSync')) return 'bg-purple';
    if (origin.includes('SerialBridge') || origin.includes('collarSend') || origin.includes('sendSerial')) return 'bg-success';
    if (origin.includes('executor')) return 'bg-secondary';
    if (origin.includes('error')) return 'bg-danger';
    return 'bg-dark';
  }

  function escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
  }

  btnClear.addEventListener('click', () => {
    if (typeof window.executorLogs !== 'undefined') {
      window.executorLogs.length = 0;
      updateLogDisplay();
    }
  });

  btnExport.addEventListener('click', () => {
    if (typeof window.getExecutorLogs !== 'function') {
      alert('Executor logs n√£o dispon√≠veis');
      return;
    }
    
    const logs = window.getExecutorLogs();
    const json = JSON.stringify(logs, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `executor-flow-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });

  cbAutoScroll.addEventListener('change', () => {
    if (cbAutoScroll.checked) {
      logPanel.scrollTop = logPanel.scrollHeight;
    }
  });

  // Atualizar a cada 500ms para pegar novos logs
  setInterval(updateLogDisplay, 500);
  updateLogDisplay();
})();
</script>

<!-- SERIAL MONITOR √î√á√∂ bloco independente (sempre aberto / admin-only) -->
<div class="host-only">
  <div class="card shadow-sm" style="background:#111;border:1px solid #333;border-radius:.75rem;color:#e5e7eb;">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2" style="background:#0c0c0e;border-bottom:1px solid #333;color:#e5e7eb;border-top-left-radius:.65rem;border-top-right-radius:.65rem;">
      <div class="d-flex align-items-center gap-2">
        <i class="fa-solid fa-terminal"></i>
        <div class="fw-semibold">Serial Monitor</div>
      </div>
      <div class="d-flex flex-wrap gap-2">
        <button id="smPause" class="btn btn-sm btn-outline-light" title="Pausar/Continuar">Pausar</button>
        <button id="smClear" class="btn btn-sm btn-outline-light" title="Limpar">Limpar</button>

        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="smTimestamps" checked />
          <label class="form-check-label small" for="smTimestamps">Timestamps</label>
        </div>

        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="smWrap" checked />
          <label class="form-check-label small" for="smWrap">Quebra de linha</label>
        </div>

        <div class="ms-2">
          <label class="small me-1" for="smEOL">EOL</label>
          <select id="smEOL" class="form-select form-select-sm d-inline-block" style="width:auto;">
            <option value="\n" />LF (\n)
            <option value="\r\n" selected />CRLF (\r\n)
            <option value="" />Nenhum
          </select>
        </div>
      </div>
        </div>
        <div class="card-body p-3">
    
        <div id="smView" class="border rounded p-2 bg-black text-monospace"
          style="height: 280px; overflow:auto; white-space: pre-wrap;"></div>

    <div class="input-group mt-3">
      <input id="smInput" type="text" class="form-control" placeholder="Digite um comando e pressione Enter√î√á¬™" />
      <button id="smSend" class="btn btn-primary"><i class="fa-solid fa-paper-plane me-1"></i>Enviar</button>
    </div>

    <div class="form-text mt-1">
      Dica: selecione o final de linha (EOL) acima. Enter tamb‚îú¬Æm envia.
    </div>
    </div>
  </div>
</div>

<style>
  #smView .sm-line { line-height: 1.25; padding: 2px 0; }
  #smView .sm-ts { opacity: .75; margin-right: 6px; }

  #smView .sm-dir { display:inline-flex; align-items:center; gap:.45rem; min-width: 3.2rem; }
  #smView .sm-icon { width: 1.2rem; text-align:center; }

  /* RX/TX */
  #smView .sm-rx { color: #22c55e; } /* verde */
  #smView .sm-tx { color: #ef4444; } /* vermelho */

  /* Tipos de comando (texto do comando) */
  #smView .cmd-shock     { color: #3b82f6; } /* azul */
  #smView .cmd-beep      { color: #22c55e; } /* verde */
  #smView .cmd-vibration { color: #eab308; } /* amarelo */
  #smView .cmd-light     { color: #ef4444; } /* vermelho */

  /* Contador de repeti‚îú¬∫‚îú√∫o */
  #smView .sm-dup { opacity: .85; margin-left: 8px; }
</style>

<script>
(() => {
  const $  = s => document.querySelector(s);
  const view = $("#smView");
  const inp  = $("#smInput");
  const btnSend = $("#smSend");
  const btnPause = $("#smPause");
  const btnClear = $("#smClear");
  const cbTs  = $("#smTimestamps");
  const cbWrap= $("#smWrap");
  const selEOL= $("#smEOL");

  let paused = false;
  let autoscroll = true;

  // Compacta‚îú¬∫‚îú√∫o
  let lastKey = null;
  let lastLineEl = null;
  let lastCount = 1;

  function nowTs() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function iconEl(cls) {
    const i = document.createElement("i");
    i.className = `fa-solid ${cls}`;
    i.setAttribute("aria-hidden", "true");
    return i;
  }

  // Remove sufixos "(3x)" vindos do pr‚îú‚îÇprio texto para n‚îú√∫o quebrar a compacta‚îú¬∫‚îú√∫o
  function stripInlineCounter(s) {
    return String(s ?? "").replace(/\(\s*\d+\s*x\s*\)\s*$/i, "").trim();
  }

  // Normaliza entidades √î√á¬£cruas√î√á√ò que chegam como texto
  function normalizeIncoming(s) {
    let t = String(s ?? "");

    // Entidades vistas nos seus logs (literal, n‚îú√∫o renderiza como emoji)
    t = t
      .replace(/&#11013;(&#65039;)?/g, "")   // seta esquerda literal
      .replace(/&#10145;(&#65039;)?/g, "")  // seta direita literal
      .replace(/&#9889;?/g, "")             // raio literal

      // tamb‚îú¬Æm remove entidades nomeadas se vierem cruas
      .replace(/&larr;?/gi, "")
      .replace(/&rarr;?/gi, "");

    // remove setas unicode se vierem embutidas
    t = t.replace(/[√î√•√â√î√•√Ü]/g, "");

    // limpa espa‚îú¬∫os duplicados
    return t.replace(/\s{2,}/g, " ").trim();
  }

  // Extrai (modo, n‚îú¬°vel, canal)
  // Suporta: SHOCK, BEEP/BIP, VIBRATION, LIGHT/LUZ
  // Ex: "OK SHOCK,12,1" / "OK VIBRATION,8,1" / "LIGHT,0,1"
  function parseTuple(text) {
    const cleaned = stripInlineCounter(normalizeIncoming(text))
      .replace(/^(OK|ERR|ERROR|INFO|WARN|WARNING|DBG|DEBUG)\s+/i, "");

    const re = /\b(SHOCK|BEEP|BIP|VIBRATION|LIGHT|LUZ)\b\s*,\s*(\d+)\s*,\s*(\d+)\b/i;
    const m = cleaned.match(re);
    if (!m) return null;

    const raw = m[1].toUpperCase();
    const mode =
      raw === "BIP" ? "BEEP" :
      raw === "LUZ" ? "LIGHT" :
      raw; // VIBRATION permanece VIBRATION

    return { mode, lvl: Number(m[2]), ch: Number(m[3]) };
  }

  function cmdMeta(mode) {
    switch (mode) {
      case "SHOCK":
        return { cls: "cmd-shock", icon: "fa-bolt", label: "SHOCK" };
      case "BEEP":
        return { cls: "cmd-beep", icon: "fa-volume-high", label: "BEEP" };
      case "VIBRATION":
        return { cls: "cmd-vibration", icon: "fa-mobile-screen-button", label: "VIBRATION" };
      case "LIGHT":
        return { cls: "cmd-light", icon: "fa-lightbulb", label: "LUZ" };
      default:
        return { cls: "", icon: "", label: mode };
    }
  }

  function makeKey(dir, originalText) {
    const normalized = stripInlineCounter(normalizeIncoming(originalText));
    const tuple = parseTuple(normalized);

    if (tuple) return `${dir}|${tuple.mode}|${tuple.lvl}|${tuple.ch}`;
    return `${dir}|RAW|${normalized}`;
  }

  function setDupCounter(el, count) {
    let dup = el.querySelector(".sm-dup");
    if (count <= 1) {
      if (dup) dup.remove();
      return;
    }
    if (!dup) {
      dup = document.createElement("span");
      dup.className = "sm-dup";
      el.appendChild(dup);
    }
    dup.textContent = `(${count}x)`;
  }

  function appendLine(text, dir = "in") {
    if (paused) return;

    const key = makeKey(dir, text);

    // Compacta somente quando id‚îú¬¨ntico (mesmo modo/nivel/canal ou RAW id‚îú¬¨ntico)
    if (key === lastKey && lastLineEl) {
      lastCount += 1;
      setDupCounter(lastLineEl, lastCount);
      if (autoscroll) view.scrollTop = view.scrollHeight;
      return;
    }

    lastKey = key;
    lastCount = 1;

    const line = document.createElement("div");
    line.className = "sm-line";
    lastLineEl = line;

    // Timestamp
    if (cbTs.checked) {
      const ts = document.createElement("span");
      ts.className = "sm-ts";
      ts.textContent = `[${nowTs()}]`;
      line.appendChild(ts);
      line.appendChild(document.createTextNode(" "));
    }

    // Dire‚îú¬∫‚îú√∫o RX/TX com Font Awesome
    const dirSpan = document.createElement("span");
    dirSpan.className = `sm-dir ${dir === "out" ? "sm-tx" : "sm-rx"}`;

    const arrowWrap = document.createElement("span");
    arrowWrap.className = "sm-icon";
    arrowWrap.appendChild(iconEl(dir === "out" ? "fa-arrow-right" : "fa-arrow-left"));
    dirSpan.appendChild(arrowWrap);

    line.appendChild(dirSpan);
    line.appendChild(document.createTextNode(" "));

    // Conte‚îú‚ïëdo normalizado
    const normalizedText = stripInlineCounter(normalizeIncoming(text));
    const tuple = parseTuple(normalizedText);

    if (tuple) {
      const meta = cmdMeta(tuple.mode);

      // Prefixo (OK, etc.) preservado quando poss‚îú¬°vel
      const cleaned = normalizeIncoming(text);
      const upper = cleaned.toUpperCase();
      const idx = upper.indexOf(tuple.mode);
      const prefix = (idx > 0 ? cleaned.slice(0, idx).trim() : "")
        .replace(/\s{2,}/g, " ")
        .trim();

      if (prefix) {
        const pre = document.createElement("span");
        pre.textContent = prefix + " ";
        line.appendChild(pre);
      }

      // ‚îú√¨cone + label com cor
      const cmd = document.createElement("span");
      cmd.className = meta.cls;

      if (meta.icon) {
        const ic = iconEl(meta.icon);
        ic.style.marginRight = ".35rem";
        cmd.appendChild(ic);
      }
      cmd.appendChild(document.createTextNode(meta.label));
      line.appendChild(cmd);

      // Restante ",lvl,ch"
      const rest = document.createElement("span");
      rest.textContent = `,${tuple.lvl},${tuple.ch}`;
      line.appendChild(rest);
    } else {
      const msg = document.createElement("span");
      msg.textContent = normalizedText;
      line.appendChild(msg);
    }

    view.appendChild(line);
    setDupCounter(line, 1);

    if (autoscroll) view.scrollTop = view.scrollHeight;
  }

  // UI
  btnPause.addEventListener("click", () => {
    paused = !paused;
    btnPause.textContent = paused ? "Continuar" : "Pausar";
  });

  btnClear.addEventListener("click", () => {
    view.innerHTML = "";
    lastKey = null;
    lastLineEl = null;
    lastCount = 1;
  });

  cbWrap.addEventListener("change", () => {
    view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
  });

  view.addEventListener("scroll", () => {
    autoscroll = (view.scrollHeight - view.scrollTop - view.clientHeight) < 8;
  });

  // Envio TX
  async function writeRaw(raw) {
    if (!raw?.length) return;

    const eolVal = selEOL.value
      .replaceAll("\\n", "\n")
      .replaceAll("\\r", "\r");
    const payload = raw + eolVal;

    // Somente envia se a porta j√° estiver aberta; n√£o tenta abrir sozinho
    let useWriter = (typeof writer !== "undefined" && writer) ? writer : null;
    if (!useWriter && window.port?.writable) {
      try { useWriter = await window.port.writable.getWriter(); } catch(_) {}
    }

    if (!useWriter) {
      appendLine(`(sem porta) ${raw}`, "out");
      return;
    }

    try {
      await useWriter.write(new TextEncoder().encode(payload));
      appendLine(raw, "out");
    } catch (e) {
      appendLine(`ERRO envio: ${e?.message || e}`, "out");
    } finally {
      try { if (useWriter !== writer) useWriter.releaseLock(); } catch(_) {}
    }
  }

  btnSend.addEventListener("click", async () => {
    const txt = inp.value.trimEnd();
    await writeRaw(txt);
    inp.value = "";
    inp.focus();
  });

  inp.addEventListener("keydown", async (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      const txt = inp.value.trimEnd();
      await writeRaw(txt);
      inp.value = "";
    }
  });

  // Hook RX
  const prevLogSerialLine = window.logSerialLine;
  window.logSerialLine = function(line) {
    try {
      if (line != null && line !== "") {
        const parts = String(line)
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n")
          .split("\n");
        for (const p of parts) if (p.length) appendLine(p, "in");
      }
    } catch(_) {}
    if (typeof prevLogSerialLine === "function") prevLogSerialLine(line);
  };

  window.addEventListener?.("serial-connected", () => appendLine("Porta conectada.", "in"));
  window.addEventListener?.("serial-disconnected", () => appendLine("Porta desconectada.", "in"));

  view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
})();
</script>
<div class="host-only">
  <div class="card p-3">
    <div class="d-flex align-items-center justify-content-between mb-2">
      <h5 class="m-0"><i class="fa-solid fa-clipboard-list me-2"></i>Log</h5>
      <div class="d-flex flex-wrap gap-2 align-items-center">
        <div class="form-check form-switch m-0">
          <input class="form-check-input" type="checkbox" id="lmTimestamps" checked />
          <label class="form-check-label small" for="lmTimestamps">Timestamps</label>
        </div>
        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="lmWrap" checked />
          <label class="form-check-label small" for="lmWrap">Quebra</label>
        </div>
        <div class="ms-2 d-flex align-items-center gap-1">
          <label class="small">N‚îú¬°vel</label>
          <select id="lmLevel" class="form-select form-select-sm" style="width:auto;">
            <option value="all" selected />Tudo
            <option value="info" />Info
            <option value="warn" />Warn
            <option value="error" />Error
          </select>
        </div>
        <button id="lmPause" class="btn btn-sm btn-outline-light">Pausar</button>
        <button id="lmClear" class="btn btn-sm btn-outline-light">Limpar</button>
        <button id="lmCopy" class="btn btn-sm btn-outline-light">Copiar</button>
        <button id="lmSave" class="btn btn-sm btn-outline-light">Salvar .txt</button>
      </div>
    </div>

    <div id="lmView" class="border rounded p-2 bg-black text-monospace"
         style="height: 260px; overflow:auto; white-space: pre-wrap;"></div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const view = $("#lmView");
  const btnPause = $("#lmPause");
  const btnClear = $("#lmClear");
  const btnCopy  = $("#lmCopy");
  const btnSave  = $("#lmSave");
  const cbTs   = $("#lmTimestamps");
  const cbWrap = $("#lmWrap");
  const selLvl = $("#lmLevel");

  let paused = false;
  let autoscroll = true;
  let filterLevel = "all";
  const buffer = []; // mant‚îú¬Æm texto para copiar/salvar

  function nowTs() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function levelAllows(level) {
    if (filterLevel === "all") return true;
    return level === filterLevel;
  }

  function colorFor(level) {
    if (level === "error") return "#ff6b6b";
    if (level === "warn")  return "#ffd166";
    return "#9ad1ff";
  }

  function appendLine(text, level="info") {
    if (!levelAllows(level)) return;
    if (paused) return;

    const line = document.createElement("div");
    line.className = "lm-line";
    const ts = cbTs.checked ? `[${nowTs()}] ` : "";
    line.textContent = `${ts}${level.toUpperCase()}: ${text}`;
    line.style.color = colorFor(level);
    view.appendChild(line);

    // guarda vers‚îú√∫o √î√á¬£crua√î√á√ò (sem cor) para export/copy
    buffer.push(`${ts}${level.toUpperCase()}: ${text}`);

    if (autoscroll) view.scrollTop = view.scrollHeight;
  }

  // Controles UI
  btnPause.addEventListener("click", () => {
    paused = !paused;
    btnPause.textContent = paused ? "Continuar" : "Pausar";
  });
  btnClear.addEventListener("click", () => { view.innerHTML = ""; buffer.length = 0; });
  btnCopy.addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(buffer.join("\n")); btnCopy.textContent = "Copiado!"; setTimeout(()=>btnCopy.textContent="Copiar",1200); }
    catch { /* ignore */ }
  });
  btnSave.addEventListener("click", () => {
    const blob = new Blob([buffer.join("\n")], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `log_${new Date().toISOString().replace(/[:.]/g,"-")}.txt`;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  });
  cbWrap.addEventListener("change", () => {
    view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
  });
  selLvl.addEventListener("change", () => {
    filterLevel = selLvl.value;
    // Re-render simples (limpa e repopula do buffer conforme filtro)
    const snapshot = buffer.slice();
    view.innerHTML = "";
    for (const line of snapshot) {
      const level = line.includes("ERROR:") ? "error" : line.includes("WARN:") ? "warn" : "info";
      if (levelAllows(level)) {
        const div = document.createElement("div");
        div.className = "lm-line";
        div.textContent = line;
        div.style.color = colorFor(level);
        view.appendChild(div);
      }
    }
    view.scrollTop = view.scrollHeight;
  });

  // Autoscroll on/off baseado na rolagem
  view.addEventListener("scroll", () => {
    const nearBottom = view.scrollHeight - view.scrollTop - view.clientHeight < 8;
    autoscroll = nearBottom;
  });

  // ===== API Global =====
  // appLog(msg, level="info") √î√á√∂ n‚îú¬°vel: "info"|"warn"|"error"
  // Tamb‚îú¬Æm aceita CustomEvent('app-log', {detail:{msg, level}})
  const originalConsole = {
    log:   console.log.bind(console),
    warn:  console.warn.bind(console),
    error: console.error.bind(console),
  };

  function appLog(msg, level="info") {
    try {
      let text = "";
      if (msg instanceof Error) {
        text = `${msg.name || "Error"}: ${msg.message}`;
      } else if (typeof msg === "object") {
        text = JSON.stringify(msg);
      } else {
        text = String(msg);
      }
      appendLine(text, level);
    } catch(_) {}
  }

  // exp‚îú√Åe global
  window.appLog = appLog;

  // escuta eventos personalizados
  window.addEventListener("app-log", (ev) => {
    const d = ev?.detail || {};
    appLog(d.msg, d.level || "info");
  });

  // espelha console.* no painel, preservando comportamento original
  console.log = (...args) => { originalConsole.log(...args); appLog(args.map(String).join(" "), "info"); };
  console.warn = (...args) => { originalConsole.warn(...args); appLog(args.map(String).join(" "), "warn"); };
  console.error = (...args) => { originalConsole.error(...args); appLog(args.map(String).join(" "), "error"); };

  // Integra‚îú¬∫‚îú√∫o opcional: tamb‚îú¬Æm mostra linhas vindas do Serial (se existir)
  const prevLogSerialLine = window.logSerialLine;
  window.logSerialLine = function(line){
    try {
      if (line != null && line !== "") {
        const parts = String(line).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
        for (const p of parts) if (p.length) appLog(`SERIAL: ${p}`, "info");
      }
    } catch(_) {}
    if (typeof prevLogSerialLine === "function") prevLogSerialLine(line);
  };

  // Estado inicial
  view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";

  // Mensagem inicial
  appLog("Monitor de LOG iniciado.", "info");
})();
</script>
