<!-- CONEXAO SERIAL (Web Serial / Bluetooth / BLE) -->
<div class="host-only">
  <div class="card shadow-sm serial-hidden" id="serialPortCard" style="background:#111;border:1px solid #333;border-radius:.75rem;color:#e5e7eb;display:none;">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2" style="background:#0c0c0e;border-bottom:1px solid #333;color:#e5e7eb;border-top-left-radius:.65rem;border-top-right-radius:.65rem;">
      <div class="d-flex align-items-center gap-2">
        <i class="fa-solid fa-plug"></i>
        <div class="fw-semibold">Conexao do Transmissor</div>
      </div>
      <div class="d-flex align-items-center gap-2">
        <div class="d-flex align-items-center gap-1">
          <label class="small text-secondary">Transporte</label>
          <select id="wsTransport" class="form-select form-select-sm" style="width:auto;">
            <option value="ble">Bluetooth LE (BLE)</option>
            <option value="serial">Serial</option>
            <option value="bluetooth">Bluetooth</option>
          </select>
        </div>
        <div class="d-flex align-items-center gap-1">
          <label class="small text-secondary">Baud</label>
          <select id="wsBaud" class="form-select form-select-sm" style="width:auto;">
            <option />115200</option>
            <option />57600</option>
            <option />38400</option>
            <option />19200</option>
            <option />9600</option>
          </select>
        </div>
        <div class="form-check form-switch m-0">
          <input class="form-check-input" type="checkbox" id="wsAuto" checked />
          <label class="form-check-label small" for="wsAuto">Auto-reconectar</label>
        </div>
        <button id="wsConnect" class="btn btn-sm btn-primary">
          <i class="fa-solid fa-circle-play me-1"></i>Conectar
        </button>
        <button id="wsDisconnect" class="btn btn-sm btn-outline-light" disabled>
          <i class="fa-solid fa-circle-stop me-1"></i>Desconectar
        </button>
      </div>
    </div>
    <div class="card-body p-3">
      <div class="row g-2 align-items-center">
        <div class="col-12 col-md-6">
          <div class="small text-secondary">Status</div>
          <div id="wsStatus" class="fw-semibold">Desconectado</div>
        </div>
        <div class="col-12 col-md-6">
          <div class="small text-secondary">Porta</div>
          <div id="wsPortInfo" class="text-truncate"><em>--</em></div>
        </div>
      </div>
      <div class="mt-2 small text-secondary">
        Dica: o Web Serial precisa de <strong>HTTPS</strong> (ou <code>localhost</code>) e um gesto do usuario para abrir a porta.
      </div>
    </div>
  </div>
</div>

<style>
  #serialPortCard .card-header { flex-wrap: wrap; gap: 8px; }
  #serialPortCard .card-header > div { min-width: 0; }
  #serialPortCard .card-header .d-flex.align-items-center.gap-2 { flex-wrap: wrap; }
  #serialPortCard .card-header .form-select-sm { max-width: 100%; }
  @media (max-width: 720px) {
    #serialPortCard .card-header { align-items: flex-start; }
    #serialPortCard .card-header > div:last-child { width: 100%; justify-content: flex-start; }
  }
</style>

<script>
(() => {
  const $ = s => document.querySelector(s);

  const statusEl = $("#wsStatus");
  const portInfoEl = $("#wsPortInfo");
  const btnConnect = $("#wsConnect");
  const btnDisconnect = $("#wsDisconnect");
  const baudSel = $("#wsBaud");
  const autoChk = $("#wsAuto");
  const transportSel = $("#wsTransport");

  const hasWebSerial = !!navigator.serial;

  const HOST_REQUIRED_MSG = "Habilite 'host' para abrir a serial";
  const LAST_BAUD_KEY = "ws.lastBaud";
  const WANT_AUTO_KEY = "ws.autoReconnect";
  const LAST_BLE_ID_KEY = "ws.lastBleDeviceId";
  const LAST_TRANSPORT_KEY = "ws.lastTransport";

  const state = {
    port: null,
    writer: null,
    reader: null,
    readPipeClosed: null,
    portOpening: null,
    transport: 'ble',
    userDisconnect: false,

    // Bluetooth clássico (GATT SPP-like) - opcional
    btDevice: null,
    btServer: null,
    btService: null,
    btCharRx: null,
    btCharTx: null,
    btNotifyAbort: null,

    // BLE NUS
    bleDevice: null,
    bleServer: null,
    bleService: null,
    bleCharRx: null, // write
    bleCharTx: null, // notify
    bleNotifyAbort: null
  };

  // ===== BUS RX (linhas) =====
  const SERIAL_BUS_KEY = "__SERIAL_RX_LISTENERS__";
  window[SERIAL_BUS_KEY] = window[SERIAL_BUS_KEY] || [];

  function ensureSerialBusHelpers() {
    if (typeof window.addSerialRxListener !== "function") {
      window.addSerialRxListener = function(listener) {
        if (typeof listener !== "function") return () => {};
        const list = window[SERIAL_BUS_KEY];
        if (!list.includes(listener)) list.push(listener);
        return () => {
          const idx = list.indexOf(listener);
          if (idx >= 0) list.splice(idx, 1);
        };
      };
    }
    if (typeof window.removeSerialRxListener !== "function") {
      window.removeSerialRxListener = function(listener) {
        if (typeof listener !== "function") return;
        const list = window[SERIAL_BUS_KEY];
        const idx = list.indexOf(listener);
        if (idx >= 0) list.splice(idx, 1);
      };
    }
  }
  ensureSerialBusHelpers();

  function log(msg, level = "info") {
    try {
      if (window.appLog) window.appLog(msg, level);
      else console[level === "error" ? "error" : level === "warn" ? "warn" : "log"](msg);
    } catch {}
  }

  function isHost() {
    try {
      const peer = (window.Flowgate && window.Flowgate.localPeer) ? window.Flowgate.localPeer : window.__TRYSTERO_PEER__;
      const tags = (peer && typeof peer.getLocalTags === "function")
        ? peer.getLocalTags()
        : [];
      const hasTag = Array.isArray(tags) && tags.map(t => String(t || "").toLowerCase()).includes("host");
      if (hasTag) return true;
      return document.documentElement.classList.contains("host-on");
    } catch { return false; }
  }

  function setStatus(text, portText) {
    if (statusEl) statusEl.textContent = text;
    if (portText != null && portInfoEl) portInfoEl.textContent = portText;
  }

  function setButtons(connected) {
    const host = isHost();
    const isSerial = state.transport === 'serial';
    const serialOk = isSerial ? hasWebSerial : true;
    const disabled = connected || !serialOk || !host || !!state.portOpening;
    if (btnConnect) btnConnect.disabled = disabled;
    if (btnDisconnect) btnDisconnect.disabled = !connected;
    if (baudSel) baudSel.disabled = !isSerial;
  }

  function syncGlobals() {
    // Mantém compatibilidade com códigos legados
    window.port = state.port;
    window.writer = state.writer;
    window.reader = state.reader;
    const bleConnected = !!(state.bleDevice && state.bleDevice.gatt && state.bleDevice.gatt.connected);
    const serialConnected = !!(state.port && state.port.readable && state.port.writable);
    window.serialConnected = serialConnected || bleConnected;
    if (window.SerialBridge) {
      window.SerialBridge.isConnected = window.serialConnected;
    }
  }

  function dispatchSerialLine(line) {
    try {
      const listeners = window[SERIAL_BUS_KEY];
      if (Array.isArray(listeners) && listeners.length) {
        listeners.slice().forEach((cb) => { try { cb(line); } catch(_) {} });
      }
      if (typeof window.logSerialLine === "function") {
        window.logSerialLine(line);
      } else {
        log('RX: ' + line, "info");
      }
    } catch {}
  }

  // split em linhas com CRLF/LF
  function dispatchChunkAsLines(chunk) {
    const text = String(chunk ?? "");
    const norm = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    const parts = norm.split("\n");
    for (const p of parts) {
      const line = p.trimEnd();
      if (line.length) dispatchSerialLine(line);
    }
  }

  function prelimCheck() {
    if (state.transport === 'serial') {
      if (!hasWebSerial) {
        setStatus("Navegador sem Web Serial.");
        log("Este navegador nao oferece navigator.serial. Use Chrome/Edge/Opera em HTTPS ou localhost.", "error");
        return false;
      }
      const httpsOk = location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";
      if (!httpsOk) {
        setStatus("Necessita HTTPS/localhost");
        log("Web Serial exige site servido via HTTPS (ou localhost).", "warn");
        return false;
      }
    }
    const host = isHost();
    const bypassHost = localStorage.getItem('serial.bypassHostCheck') === '1';
    if (!host && !bypassHost) {
      setStatus(HOST_REQUIRED_MSG);
      log("Marcador de host desligado: serial/bt bloqueada. (Use localStorage para bypass)", "warn");
      return false;
    }
    return true;
  }

  // ===== SERIAL (WebSerial) =====
  async function openPort(port, baud) {
    await port.open({ baudRate: baud, bufferSize: 255 });
    try { await port.setSignals({ dataTerminalReady: true, requestToSend: false }); } catch {}

    state.port = port;
    state.writer = port.writable ? port.writable.getWriter() : null;

    const textDecoder = new TextDecoderStream();
    state.readPipeClosed = port.readable.pipeTo(textDecoder.writable).catch(() => {});
    const reader = textDecoder.readable.getReader();
    state.reader = reader;

    (async () => {
      let carry = "";
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          carry += value;
          let idx;
          while ((idx = carry.search(/\r\n|\n/)) >= 0) {
            const line = carry.slice(0, idx);
            carry = carry.slice(idx + (carry.slice(idx, idx + 2) === "\r\n" ? 2 : 1));
            dispatchSerialLine(line);
          }
        }
      } catch (e) {
        log('Leitura interrompida: ' + (e.message || e), "warn");
      } finally {
        try { reader.releaseLock(); } catch {}
        if (state.transport === 'serial' && state.port === port) {
          disconnectSerial({ isEvent: true }).catch(()=>{});
        }
      }
    })();

    setStatus("Conectado", describePortText(port));
    setButtons(true);
    state.userDisconnect = false;
    syncGlobals();
    window.dispatchEvent(new Event("serial-connected"));
    log('Porta aberta @' + baud + ' bps');
  }

  function describePortText(port) {
    try {
      const info = port.getInfo ? port.getInfo() : {};
      const vid = info.usbVendorId != null ? "0x" + info.usbVendorId.toString(16).padStart(4, "0") : "--";
      const pid = info.usbProductId != null ? "0x" + info.usbProductId.toString(16).padStart(4, "0") : "--";
      return `VID: ${vid} PID: ${pid}`;
    } catch { return "--"; }
  }

  function onBLEDisconnected(event) {
    const device = event.target;
    log(`Dispositivo BLE desconectado: ${device.name || device.id}`, 'warn');
    disconnectSerial({ isEvent: true }).catch(()=>{});
  }

  function handleBLENotifications(event) {
      try {
        const value = event.target.value;
        const text = new TextDecoder().decode(value);
        dispatchChunkAsLines(text); 
      } catch (e) {
        log("Erro ao decodificar notificação BLE: " + (e.message || e), "error");
      }
  }

  // ====== BLE (NUS) ======
  async function setupBLEFromDevice(device) {
    const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const CHAR_TX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';
    const CHAR_RX_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';

    state.bleDevice = device;
    device.removeEventListener('gattserverdisconnected', onBLEDisconnected);
    device.addEventListener('gattserverdisconnected', onBLEDisconnected);
    log("Conectando ao servidor GATT...");
    const server = await device.gatt.connect();
    state.bleServer = server;
    log("Servidor GATT conectado.");

    const service = await server.getPrimaryService(SERVICE_UUID);
    log("Servi??o UART (NUS) encontrado.");

    const [charTx, charRx] = await Promise.all([
        service.getCharacteristic(CHAR_TX_UUID),
        service.getCharacteristic(CHAR_RX_UUID)
    ]);
    
    // Verifica permiss??es do characteristic RX
    let rxProps = charRx.properties || {};
    if (!rxProps.write && !rxProps.writeWithoutResponse) {
      log("Aten????o: Caracter??stica RX n??o suporta escrita!", "warn");
    }
    state.bleCharTx = charTx;
    state.bleCharRx = charRx;
    log("Caracter??sticas RX/TX encontradas.");

    await charTx.startNotifications();
    log("Inscri????o para notifica????es ativada (TX).");

    state.bleNotifyAbort = new AbortController();
    charTx.addEventListener('characteristicvaluechanged', handleBLENotifications, { signal: state.bleNotifyAbort.signal });

    setStatus("Conectado (BLE)", device.name || device.id);
    setButtons(true);
    state.userDisconnect = false;
    syncGlobals();
    window.dispatchEvent(new Event("serial-connected"));
    log('Conex??o BLE estabelecida com ' + (device.name || '(sem nome)'));
  }

  async function connectBLE() {
    const SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    log("Procurando por dispositivos BLE com o servi??o UART...");
    let device;
    try {
      device = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: [SERVICE_UUID]
      });
      if (!device) throw new Error("Nenhum dispositivo selecionado.");
    } catch (e) {
      throw new Error(`Sele????o de dispositivo BLE falhou: ${e.message}`);
    }

    log(`Dispositivo selecionado: ${device.name || 'ID: ' + device.id}`);
    try { localStorage.setItem(LAST_BLE_ID_KEY, device.id); } catch {}
    await setupBLEFromDevice(device);
  }

  async function getKnownBLEDevice() {
    if (!navigator.bluetooth || typeof navigator.bluetooth.getDevices !== "function") return null;
    const devices = await navigator.bluetooth.getDevices();
    if (!devices || !devices.length) return null;
    const lastId = (() => {
      try { return localStorage.getItem(LAST_BLE_ID_KEY); } catch { return null; }
    })();
    if (lastId) {
      const match = devices.find(d => d.id === lastId);
      if (match) return match;
    }
    return devices[0] || null;
  }

  async function reconnectBLE() {
    if (!state.bleDevice) throw new Error("Nenhum dispositivo BLE previamente conhecido.");
    if (state.bleDevice.gatt && state.bleDevice.gatt.connected) return;
    log("Tentando reconectar BLE ao dispositivo anterior...");
    await setupBLEFromDevice(state.bleDevice);
  }

  // ====== Bluetooth clássico (mantido, mas opcional) ======
  async function connectBTClassic() {
    // Esta função é um placeholder e não será usada, mas é mantida para não quebrar a estrutura.
    log("Bluetooth Clássico não é suportado para este firmware.", "warn");
    throw new Error("Transporte 'Bluetooth Clássico' não suportado.");
  }

  // ===== ensureSerial (principal) =====
  async function ensureSerial(opts = {}) {
    const prompt = opts.prompt !== false;
    const quiet = opts.quiet === true;

    if (state.portOpening) return state.portOpening;

    if (!prelimCheck()) {
      if (!isHost()) throw new Error(HOST_REQUIRED_MSG);
      throw new Error("Transporte indisponível neste contexto.");
    }

    state.portOpening = (async () => {
      if (state.transport === 'serial') {
        if (state.port && state.port.readable && state.port.writable) return;

        const baud = parseInt(baudSel.value || localStorage.getItem(LAST_BAUD_KEY) || "115200", 10);
        localStorage.setItem(LAST_BAUD_KEY, String(baud));

        const granted = await navigator.serial.getPorts();
        if (granted && granted.length) {
          const port = granted[0];
          if (!quiet) log("Usando porta previamente concedida.");
          await openPort(port, baud);
          return;
        }

        if (!prompt) {
          if (!quiet) log("Auto-reconnect ignorado: nenhuma porta previamente concedida.", "warn");
          throw new Error("Sem permissao serial previamente concedida.");
        }

        const port = await navigator.serial.requestPort({ filters: [] });
        await openPort(port, baud);
        return;
      }

      if (state.transport === 'bluetooth') {
        await connectBTClassic();
        return;
      }

      if (state.transport === 'ble') {
        if (state.bleDevice && state.bleDevice.gatt && state.bleDevice.gatt.connected) return;
        if (state.bleDevice && !prompt) {
          await reconnectBLE();
          return;
        }
        if (!prompt) {
          const known = await getKnownBLEDevice();
          if (known) {
            state.bleDevice = known;
            await reconnectBLE();
            return;
          }
          throw new Error("Sem dispositivo BLE conhecido para reconectar.");
        }
        await connectBLE();
        return;
      }
    })();

    try { await state.portOpening; }
    finally { state.portOpening = null; }
  }

  // ===== disconnect =====
  async function disconnectSerial(opts = {}) {
    const isEvent = opts.isEvent === true;

    if (state.transport === 'serial' && state.port) {
        const forgetGrant = opts.forgetPermission === true;
        const portRef = state.port;
        
        if (state.reader) { try { await state.reader.cancel(); } catch {} }
        if (state.writer) { try { await state.writer.close(); } catch {} }
        if (state.port) { try { await state.port.close(); } catch {} }

        state.reader = null; state.writer = null; state.port = null;

        if (forgetGrant && portRef && typeof portRef.forget === "function") {
          try { await portRef.forget(); log("Permissão da porta esquecida."); }
          catch (e) { log('Não foi possível limpar a permissão: ' + (e?.message || e), "warn"); }
        }
    }

    if (state.transport === 'ble' && state.bleDevice) {
        if (state.bleNotifyAbort) { try { state.bleNotifyAbort.abort(); state.bleNotifyAbort = null; } catch {} }
        if (state.bleDevice.gatt.connected) { try { state.bleDevice.gatt.disconnect(); } catch {} }
        if (!isEvent) {
            state.bleDevice.removeEventListener('gattserverdisconnected', onBLEDisconnected);
            state.bleDevice = null;
        }
        state.bleServer = null; state.bleCharRx = null; state.bleCharTx = null;
    }

    state.portOpening = null;
    setStatus("Desconectado", "--");
    setButtons(false);
    syncGlobals();
    window.dispatchEvent(new Event("serial-disconnected"));
    log(`${state.transport.toUpperCase()} desconectado.`);

    if (isEvent && (state.transport === 'ble' || state.transport === 'serial')) {
      scheduleReconnect();
    }
  }

  // ===== Auto-reconnect =====
  let reconnectTimer = null;
  let reconnectDelay = 1000;

  function scheduleReconnect() {
    if (!autoChk?.checked) return;
    if (!isHost()) return;
    if (state.userDisconnect) return;
    if (reconnectTimer) return;

    reconnectTimer = setTimeout(async () => {
      reconnectTimer = null;
      try {
        await ensureSerial({ prompt: false, quiet: true });
        reconnectDelay = 1000;
      } catch (e) {
        log('Auto-reconnect falhou: ' + (e?.message || e), "warn");
        reconnectDelay = Math.min(reconnectDelay * 2, 10000);
        scheduleReconnect();
      }
    }, reconnectDelay);
  }

  // ===== UNIVERSAL SEND =====
  async function sendLineUniversal(line) {
    line = String(line ?? "").trim();
    if (!line) return;

    // Permite alternar terminador via window.BLE_LINE_ENDING
    const lineEnding = typeof window.BLE_LINE_ENDING === 'string' ? window.BLE_LINE_ENDING : "\n";
    const payload = line + lineEnding;
    const bytes = new TextEncoder().encode(payload);

    if (state.transport === 'serial') {
      if (!state.port || !state.port.writable) throw new Error("Porta serial indisponível");
      if (!state.writer) state.writer = state.port.writable.getWriter();
      await state.writer.write(bytes);
      return;
    }

    if (state.transport === 'ble') {
      const maxLen = 20;
      let sentRx = false;
      const canWriteNoRsp = !!(state.bleCharRx && state.bleCharRx.writeValueWithoutResponse && state.bleCharRx.properties && state.bleCharRx.properties.writeWithoutResponse);
      const writeFn = canWriteNoRsp
        ? state.bleCharRx.writeValueWithoutResponse.bind(state.bleCharRx)
        : state.bleCharRx ? state.bleCharRx.writeValue.bind(state.bleCharRx) : null;
      // Se o comando couber em um pacote, envie de uma vez só
      if (bytes.length <= maxLen) {
        if (state.bleCharRx) {
          try {
            if (!writeFn) throw new Error("write indisponivel");
            await writeFn(bytes);
            log(`BLE: enviado comando inteiro via RX (${bytes.length} bytes)`, "info");
            sentRx = true;
          } catch (e) {
            log(`Erro ao enviar BLE RX: ${e.message || e}`, "warn");
          }
        }
      } else {
        // Fragmenta apenas se for maior que 20 bytes
        if (state.bleCharRx) {
          let offset = 0;
          while (offset < bytes.length) {
            const chunk = bytes.slice(offset, offset + maxLen);
            try {
              if (!writeFn) throw new Error("write indisponivel");
              await writeFn(chunk);
              log(`BLE: enviado chunk via RX [${offset}-${offset+chunk.length-1}] (${chunk.length} bytes)`, "info");
              sentRx = true;
            } catch (e) {
              log(`Erro ao enviar chunk BLE RX: ${e.message || e}`, "warn");
            }
            offset += maxLen;
          }
        }
      }
      if (!sentRx) {
        log("Nenhum characteristic BLE disponível para escrita!", "error");
        throw new Error("Nenhum characteristic BLE disponível para escrita!");
      }
      return;
    }
  }

  // ===== UI handlers =====
  if (btnConnect) {
    btnConnect.addEventListener("click", async () => {
      try {
        await ensureSerial({ prompt: true });
      } catch (e) {
        log('Falha ao conectar: ' + e.message, "error");
        setStatus("Falha na conexão", "--");
        setButtons(false);
      }
    });
  }

  if (btnDisconnect) {
    btnDisconnect.addEventListener("click", () => {
      state.userDisconnect = true;
      disconnectSerial({ forgetPermission: true }).catch(()=>{});
    });
  }

  if (transportSel) {
    transportSel.addEventListener("change", () => {
      disconnectSerial().finally(() => {
          state.transport = transportSel.value;
          try { localStorage.setItem(LAST_TRANSPORT_KEY, state.transport); } catch {}
          setStatus("Desconectado", "--");
          setButtons(false);
      });
    });
  }

  if (autoChk) {
    autoChk.addEventListener("change", () => {
      localStorage.setItem(WANT_AUTO_KEY, autoChk.checked ? "1" : "0");
      if (autoChk.checked && !btnConnect.disabled) {
        scheduleReconnect();
      } else {
        clearTimeout(reconnectTimer);
      }
    });
  }

  // ===== Expor API global p/ Serial Monitor / Executor =====
  window.ensureSerial = ensureSerial;
  window.disconnectSerial = disconnectSerial;
  window.SerialBridge = window.SerialBridge || {};
  window.SerialBridge.send = sendLineUniversal;
  window.SerialBridge.isConnected = !!window.serialConnected;
  window.collarSend = sendLineUniversal;

  // ===== Inicialização =====
  function initialize() {
    const hasWebBluetooth = !!navigator.bluetooth;
    const savedTransport = (() => {
      try { return localStorage.getItem(LAST_TRANSPORT_KEY); } catch { return null; }
    })();
    const baseTransport = hasWebBluetooth ? (transportSel?.value || 'ble') : 'serial';
    state.transport = savedTransport || baseTransport;
    if (!hasWebBluetooth && state.transport !== 'serial') state.transport = 'serial';
    if (transportSel) transportSel.value = state.transport;

    const savedAuto = localStorage.getItem(WANT_AUTO_KEY);
    if (savedAuto != null && autoChk) autoChk.checked = savedAuto === "1";

    let statusMsg = "Desconectado";
    if (state.transport === 'serial' && !hasWebSerial) statusMsg = "Web Serial indisponível";
    if (state.transport === 'ble' && !hasWebBluetooth) statusMsg = "Web Bluetooth indisponível";
    
    setStatus(statusMsg, "--");
    setButtons(false);
    syncGlobals();

    if (autoChk?.checked && isHost()) {
        scheduleReconnect();
    }
  }
  
  initialize();

  // watchers de host tag
  window.addEventListener("flowgate:local_tags_changed", () => {
    setButtons(!!state.port || !!state.bleDevice);
    if (autoChk?.checked && isHost()) scheduleReconnect();
  });
  window.addEventListener("trystero:localTags", () => {
    setButtons(!!state.port || !!state.bleDevice);
    if (autoChk?.checked && isHost()) scheduleReconnect();
  });

  if (navigator.serial && typeof navigator.serial.addEventListener === "function") {
    navigator.serial.addEventListener("disconnect", (event) => {
      if (state.transport !== 'serial') return;
      if (state.port && event && event.target === state.port) {
        disconnectSerial({ isEvent: true }).catch(()=>{});
      }
    });
  }

})();
</script>


<!-- SERIAL MONITOR - bloco independente (sempre aberto / admin-only) -->
<div class="host-only">
  <div id="serial-monitor-card" class="card shadow-sm mt-3" style="background:#111;border:1px solid #333;border-radius:.75rem;color:#e5e7eb;">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2" style="background:#0c0c0e;border-bottom:1px solid #333;color:#e5e7eb;border-top-left-radius:.65rem;border-top-right-radius:.65rem;">
      <div class="d-flex align-items-center gap-2">
        <i class="fa-solid fa-terminal"></i>
        <div class="fw-semibold">Serial Monitor</div>
      </div>
      <div class="d-flex flex-wrap gap-2 align-items-center">
        <button id="smPause" class="btn btn-sm btn-outline-light" title="Pausar/Continuar">Pausar</button>
        <button id="smClear" class="btn btn-sm btn-outline-light" title="Limpar">Limpar</button>
        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="smTimestamps" checked />
          <label class="form-check-label small" for="smTimestamps">Timestamps</label>
        </div>
        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="smWrap" checked />
          <label class="form-check-label small" for="smWrap">Quebra de linha</label>
        </div>
      </div>
    </div>
    <div class="card-body p-3">
    
        <div id="smView" class="border rounded p-2 bg-black"
          style="height: 280px; overflow-y:auto; white-space: pre-wrap; font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.85rem;"></div>

    <div class="input-group mt-3">
      <input id="smInput" type="text" class="form-control" placeholder="Digite um comando e pressione Enter..." />
      <button id="smSend" class="btn btn-primary"><i class="fa-solid fa-paper-plane me-1"></i>Enviar</button>
    </div>
    <div id="smQuickCommands" class="d-flex flex-wrap align-items-center gap-2 mt-2">
      <span class="small text-secondary me-1">Atalhos:</span>
      <button type="button" class="btn btn-sm btn-danger sm-quick-btn" data-cmd="HOLDOFF" data-send-now="1">HOLDOFF</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="PING" data-send-now="1">PING</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="SHOCK,30,1">SHOCK,30,1</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="VIBRATION,30,1">VIBRATION,30,1</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="BEEP,0,1">BEEP,0,1</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="LIGHT,0,1">LIGHT,0,1</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="SHOCK,30,1,300">SHOCK,30,1,300</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="HOLDON SHOCK,30,1">HOLDON SHOCK</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="HOLDON CADENCE SHOCK,30,1,5,200">HOLDON CADENCE</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="HOLDON PATTERN SHOCK,30,1 [150,120,150,200]">HOLDON PATTERN</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="HOLDON SEQUENCE">HOLDON SEQUENCE</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="CADENCE SHOCK,30,1,5,200">CADENCE</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="PATTERN SHOCK,30,1 [150,120,150,200]">PATTERN</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="SEQUENCE">SEQUENCE</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="ENDSEQ">ENDSEQ</button>
      <button type="button" class="btn btn-sm btn-outline-light sm-quick-btn" data-cmd="ENDSEQUENCE">ENDSEQUENCE</button>
    </div>
    </div>
  </div>
</div>

<style>
  #smView .sm-line { line-height: 1.3; padding: 1px 0; }
  #smView .sm-ts { opacity: .6; margin-right: 8px; font-size: 0.9em; }
  #smView .sm-dir { display:inline-flex; align-items:center; gap:.4rem; min-width: 2.8rem; opacity: 0.7; }
  #smView .sm-rx { color: #22c55e; } /* verde */
  #smView .sm-tx { color: #ef4444; } /* vermelho */
  #smView .cmd-shock     { color: #60a5fa; }
  #smView .cmd-beep      { color: #4ade80; }
  #smView .cmd-vibration { color: #facc15; }
  #smView .cmd-light     { color: #f87171; }
  #smView .sm-dup { opacity: .7; margin-left: 8px; font-style: italic; }
  #smQuickCommands .sm-quick-btn { font-size: .76rem; }
</style>

<script>
(() => {
  const $  = s => document.querySelector(s);
  const view = $("#smView");
  const inp  = $("#smInput");
  const btnSend = $("#smSend");
  const btnPause = $("#smPause");
  const btnClear = $("#smClear");
  const quickCommands = $("#smQuickCommands");
  const cbTs  = $("#smTimestamps");
  const cbWrap= $("#smWrap");

  let paused = false;
  let autoscroll = true;
  let lastKey = null, lastLineEl = null, lastCount = 1;

  const nowTs = () => new Date().toLocaleTimeString();

  function appendLine(text, dir = "in") {
    if (paused) return;
    if (!text) return;

    const key = `${dir}|${text}`;
    if (key === lastKey && lastLineEl) {
      lastCount++;
      const dupEl = lastLineEl.querySelector(".sm-dup") || document.createElement("span");
      dupEl.className = "sm-dup";
      dupEl.textContent = `(${lastCount}x)`;
      if (!dupEl.parentElement) lastLineEl.appendChild(dupEl);
      if (autoscroll) view.scrollTop = view.scrollHeight;
      return;
    }

    lastKey = key;
    lastCount = 1;

    const line = document.createElement("div");
    line.className = "sm-line";
    lastLineEl = line;

    if (cbTs?.checked) {
      const ts = document.createElement("span");
      ts.className = "sm-ts";
      ts.textContent = `[${nowTs()}]`;
      line.appendChild(ts);
    }
    
    const dirSpan = document.createElement("span");
    dirSpan.className = `sm-dir ${dir === 'out' ? 'sm-tx' : 'sm-rx'}`;
    const icon = document.createElement("i");
    icon.className = `fa-solid fa-arrow-${dir === 'out' ? 'up' : 'down'}`;
    dirSpan.appendChild(icon);
    line.appendChild(dirSpan);
    
    const msg = document.createElement("span");
    msg.textContent = text;
    line.appendChild(msg);

    view.appendChild(line);
    if (autoscroll) view.scrollTop = view.scrollHeight;
  }

  async function writeRaw(raw) {
    if (!raw.length) return;
    try {
      if (window.SerialBridge?.send) {
        await window.SerialBridge.send(raw);
        appendLine(raw, "out");
      } else {
        throw new Error("SerialBridge não está disponível.");
      }
    } catch (e) {
      appendLine(`ERRO: ${e?.message || e}`, "out");
      log(`Falha no envio: ${e?.message}`, "error");
    }
  }

  btnSend?.addEventListener("click", () => {
    writeRaw(inp.value.trim());
    inp.value = "";
    inp.focus();
  });
  inp?.addEventListener("keydown", (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      writeRaw(inp.value.trim());
      inp.value = "";
    }
  });
  quickCommands?.addEventListener("click", (ev) => {
    const btn = ev.target?.closest?.(".sm-quick-btn");
    if (!btn) return;
    const cmd = String(btn.dataset?.cmd || "").trim();
    if (!cmd) return;
    if (inp) inp.value = cmd;
    const sendNow = btn.dataset?.sendNow === "1";
    if (sendNow) writeRaw(cmd);
    if (inp) inp.focus();
  });

  btnPause?.addEventListener("click", () => { paused = !paused; btnPause.textContent = paused ? "Continuar" : "Pausar"; });
  btnClear?.addEventListener("click", () => { view.innerHTML = ""; lastKey = null; lastLineEl = null; });
  cbWrap?.addEventListener("change", () => { view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre"; });
  view?.addEventListener("scroll", () => { autoscroll = (view.scrollHeight - view.scrollTop - view.clientHeight) < 10; });

  const originalLogSerialLine = window.logSerialLine;
  window.logSerialLine = function(line) {
    appendLine(line, "in");
    if (typeof originalLogSerialLine === 'function') originalLogSerialLine(line);
  };
  
  if(view && cbWrap) view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
  appendLine("Monitor iniciado. Aguardando conexão...", "in");
})();
</script>


<div class="host-only">
  <div id="log-monitor-card" class="card p-3">
    <div class="d-flex align-items-center justify-content-between mb-2">
      <h5 class="m-0"><i class="fa-solid fa-clipboard-list me-2"></i>Log</h5>
      <div class="d-flex flex-wrap gap-2 align-items-center">
        <div class="form-check form-switch m-0">
          <input class="form-check-input" type="checkbox" id="lmTimestamps" checked />
          <label class="form-check-label small" for="lmTimestamps">Timestamps</label>
        </div>
        <div class="form-check form-switch m-0 ms-2">
          <input class="form-check-input" type="checkbox" id="lmWrap" checked />
          <label class="form-check-label small" for="lmWrap">Quebra</label>
        </div>
        <div class="ms-2 d-flex align-items-center gap-1">
          <label class="small">N├¡vel</label>
          <select id="lmLevel" class="form-select form-select-sm" style="width:auto;">
            <option value="all" selected />Tudo
            <option value="info" />Info
            <option value="warn" />Warn
            <option value="error" />Error
          </select>
        </div>
        <button id="lmPause" class="btn btn-sm btn-outline-light">Pausar</button>
        <button id="lmClear" class="btn btn-sm btn-outline-light">Limpar</button>
        <button id="lmCopy" class="btn btn-sm btn-outline-light">Copiar</button>
        <button id="lmSave" class="btn btn-sm btn-outline-light">Salvar .txt</button>
      </div>
    </div>

    <div id="lmView" class="border rounded p-2 bg-black text-monospace"
         style="height: 260px; overflow:auto; white-space: pre-wrap;"></div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const view = $("#lmView");
  const btnPause = $("#lmPause");
  const btnClear = $("#lmClear");
  const btnCopy  = $("#lmCopy");
  const btnSave  = $("#lmSave");
  const cbTs   = $("#lmTimestamps");
  const cbWrap = $("#lmWrap");
  const selLvl = $("#lmLevel");

  let paused = false;
  let autoscroll = true;
  let filterLevel = "all";
  const buffer = []; // mant├®m texto para copiar/salvar

  function nowTs() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function levelAllows(level) {
    if (filterLevel === "all") return true;
    return level === filterLevel;
  }

  function colorFor(level) {
    if (level === "error") return "#ff6b6b";
    if (level === "warn")  return "#ffd166";
    return "#9ad1ff";
  }

  function appendLine(text, level="info") {
    if (!levelAllows(level)) return;
    if (paused) return;

    const line = document.createElement("div");
    line.className = "lm-line";
    const ts = cbTs.checked ? `[${nowTs()}] ` : "";
    line.textContent = `${ts}${level.toUpperCase()}: ${text}`;
    line.style.color = colorFor(level);
    view.appendChild(line);

    // guarda vers├úo ÔÇ£cruaÔÇØ (sem cor) para export/copy
    buffer.push(`${ts}${level.toUpperCase()}: ${text}`);

    if (autoscroll) view.scrollTop = view.scrollHeight;
  }

  // Controles UI
  btnPause.addEventListener("click", () => {
    paused = !paused;
    btnPause.textContent = paused ? "Continuar" : "Pausar";
  });
  btnClear.addEventListener("click", () => { view.innerHTML = ""; buffer.length = 0; });
  btnCopy.addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(buffer.join("\n")); btnCopy.textContent = "Copiado!"; setTimeout(()=>btnCopy.textContent="Copiar",1200); }
    catch { /* ignore */ }
  });
  btnSave.addEventListener("click", () => {
    const blob = new Blob([buffer.join("\n")], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `log_${new Date().toISOString().replace(/[:.]/g,"-")}.txt`;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  });
  cbWrap.addEventListener("change", () => {
    view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
  });
  selLvl.addEventListener("change", () => {
    filterLevel = selLvl.value;
    // Re-render simples (limpa e repopula do buffer conforme filtro)
    const snapshot = buffer.slice();
    view.innerHTML = "";
    for (const line of snapshot) {
      const level = line.includes("ERROR:") ? "error" : line.includes("WARN:") ? "warn" : "info";
      if (levelAllows(level)) {
        const div = document.createElement("div");
        div.className = "lm-line";
        div.textContent = line;
        div.style.color = colorFor(level);
        view.appendChild(div);
      }
    }
    view.scrollTop = view.scrollHeight;
  });

  // Autoscroll on/off baseado na rolagem
  view.addEventListener("scroll", () => {
    const nearBottom = view.scrollHeight - view.scrollTop - view.clientHeight < 8;
    autoscroll = nearBottom;
  });

  // ===== API Global =====
  // appLog(msg, level="info") ÔÇö n├¡vel: "info"|"warn"|"error"
  // Tamb├®m aceita CustomEvent('app-log', {detail:{msg, level}})
  const originalConsole = {
    log:   console.log.bind(console),
    warn:  console.warn.bind(console),
    error: console.error.bind(console),
  };

  function appLog(msg, level="info") {
    try {
      let text = "";
      if (msg instanceof Error) {
        text = `${msg.name || "Error"}: ${msg.message}`;
      } else if (typeof msg === "object") {
        text = JSON.stringify(msg);
      } else {
        text = String(msg);
      }
      appendLine(text, level);
    } catch(_) {}
  }

  // exp├Áe global
  window.appLog = appLog;

  // escuta eventos personalizados
  window.addEventListener("app-log", (ev) => {
    const d = ev?.detail || {};
    appLog(d.msg, d.level || "info");
  });

  // espelha console.* no painel, preservando comportamento original
  console.log = (...args) => { originalConsole.log(...args); appLog(args.map(String).join(" "), "info"); };
  console.warn = (...args) => { originalConsole.warn(...args); appLog(args.map(String).join(" "), "warn"); };
  console.error = (...args) => { originalConsole.error(...args); appLog(args.map(String).join(" "), "error"); };

  // Integra├º├úo opcional: tamb├®m mostra linhas vindas do Serial (se existir)
  const prevLogSerialLine = window.logSerialLine;
  window.logSerialLine = function(line){
    try {
      if (line != null && line !== "") {
        const parts = String(line).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
        for (const p of parts) if (p.length) appLog('SERIAL: ' + p, "info");
      }
    } catch(_) {}
    if (typeof prevLogSerialLine === "function") prevLogSerialLine(line);
  };

  // Estado inicial
  view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";

  // Mensagem inicial
  appLog("Monitor de LOG iniciado.", "info");
})();
</script>

