<!-- CONEXAO SERIAL (Web Serial) -->
<div class="host-only">
  <div class="card p-3" style="background:#111;border:1px solid #333;border-radius:.75rem;color:#e5e7eb;">
    <div class="d-flex align-items-center justify-content-between flex-wrap gap-2">
      <div class="d-flex align-items-center gap-2">
        <h5 class="m-0 d-flex align-items-center gap-2">
          <i class="fa-solid fa-plug"></i>
          <span>Conexão Serial</span>
        </h5>
        <span id="wsStatusCompact" class="badge text-bg-secondary fw-semibold">Desconectado</span>
      </div>
      <button id="wsToggle" type="button" class="btn btn-sm btn-outline-light" aria-expanded="false" aria-controls="wsBody" title="Mostrar painel">
        <i class="fa-solid fa-plug"></i>
      </button>
    </div>

    <div id="wsBody" class="collapse mt-3">
      <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-2">
        <div class="d-flex align-items-center gap-1">
          <label class="small text-secondary">Baud</label>
          <select id="wsBaud" class="form-select form-select-sm" style="width:auto;">
            <option />115200
            <option />57600
            <option />38400
            <option />19200
            <option />9600
          </select>
        </div>
        <div class="d-flex align-items-center gap-2">
          <div class="form-check form-switch m-0">
            <input class="form-check-input" type="checkbox" id="wsAuto" />
            <label class="form-check-label small" for="wsAuto">Auto-reconectar</label>
          </div>
          <button id="wsConnect" class="btn btn-sm btn-primary">
            <i class="fa-solid fa-circle-play me-1"></i>Conectar
          </button>
          <button id="wsDisconnect" class="btn btn-sm btn-outline-light" disabled>
            <i class="fa-solid fa-circle-stop me-1"></i>Desconectar
          </button>
        </div>
      </div>

      <div class="row g-2 align-items-center">
        <div class="col-12 col-md-6">
          <div class="small text-secondary">Status</div>
          <div id="wsStatus" class="fw-semibold">Desconectado</div>
        </div>
        <div class="col-12 col-md-6">
          <div class="small text-secondary">Porta</div>
          <div id="wsPortInfo" class="text-truncate"><em>--</em></div>
        </div>
      </div>

      <div class="mt-2 small text-secondary">
        Dica: o Web Serial precisa de <strong>HTTPS</strong> (ou <code>localhost</code>) e um gesto do usuario para abrir a porta.
      </div>

      <!-- Serial monitor fica abaixo, dentro do painel recolhivel -->
      <div class="border rounded p-3 mt-4" id="wsMonitorSlot">
        <div class="d-flex align-items-center justify-content-between mb-2">
          <h5 class="m-0"><i class="fa-solid fa-terminal me-2"></i>Serial Monitor</h5>
          <div class="d-flex flex-wrap gap-2">
            <button id="smPause" class="btn btn-sm btn-outline-light" title="Pausar/Continuar">Pausar</button>
            <button id="smClear" class="btn btn-sm btn-outline-light" title="Limpar">Limpar</button>

            <div class="form-check form-switch m-0 ms-2">
              <input class="form-check-input" type="checkbox" id="smTimestamps" checked />
              <label class="form-check-label small" for="smTimestamps">Timestamps</label>
            </div>

            <div class="form-check form-switch m-0 ms-2">
              <input class="form-check-input" type="checkbox" id="smWrap" checked />
              <label class="form-check-label small" for="smWrap">Quebra de linha</label>
            </div>

            <div class="ms-2">
              <label class="small me-1" for="smEOL">EOL</label>
              <select id="smEOL" class="form-select form-select-sm d-inline-block" style="width:auto;">
                <option value="\n" />LF (\n)
                <option value="\r\n" selected />CRLF (\r\n)
                <option value="" />Nenhum
              </select>
            </div>
          </div>
        </div>

        <div id="smView" class="border rounded p-2 bg-black text-monospace"
             style="height: 280px; overflow:auto; white-space: pre-wrap;"></div>

        <div class="input-group mt-3">
          <input id="smInput" type="text" class="form-control" placeholder="Digite um comando e pressione Enter..." />
          <button id="smSend" class="btn btn-primary"><i class="fa-solid fa-paper-plane me-1"></i>Enviar</button>
        </div>

        <div class="form-text mt-1">
          Dica: selecione o final de linha (EOL) acima. Enter tambem envia.
        </div>
      </div>

      <!-- Log consolidado junto da conexao serial -->
      <div class="border rounded p-3 mt-4" id="wsLogSlot">
        <div class="d-flex align-items-center justify-content-between mb-2">
          <h5 class="m-0"><i class="fa-solid fa-clipboard-list me-2"></i>Log</h5>
          <div class="d-flex flex-wrap gap-2 align-items-center">
            <div class="form-check form-switch m-0">
              <input class="form-check-input" type="checkbox" id="lmTimestamps" checked />
              <label class="form-check-label small" for="lmTimestamps">Timestamps</label>
            </div>
            <div class="form-check form-switch m-0 ms-2">
              <input class="form-check-input" type="checkbox" id="lmWrap" checked />
              <label class="form-check-label small" for="lmWrap">Quebra</label>
            </div>
            <div class="ms-2 d-flex align-items-center gap-1">
              <label class="small">Nivel</label>
              <select id="lmLevel" class="form-select form-select-sm" style="width:auto;">
                <option value="all" selected />Tudo
                <option value="info" />Info
                <option value="warn" />Warn
                <option value="error" />Error
              </select>
            </div>
            <button id="lmPause" class="btn btn-sm btn-outline-light">Pausar</button>
            <button id="lmClear" class="btn btn-sm btn-outline-light">Limpar</button>
            <button id="lmCopy" class="btn btn-sm btn-outline-light">Copiar</button>
            <button id="lmSave" class="btn btn-sm btn-outline-light">Salvar .txt</button>
          </div>
        </div>

        <div id="lmView" class="border rounded p-2 bg-black text-monospace"
             style="height: 260px; overflow:auto; white-space: pre-wrap;"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const statusEl = $("#wsStatus");
  const portInfoEl = $("#wsPortInfo");
  const btnConnect = $("#wsConnect");
  const btnDisconnect = $("#wsDisconnect");
  const baudSel = $("#wsBaud");
  const autoChk = $("#wsAuto");
  const wsBody = document.getElementById("wsBody");
  const btnToggle = document.getElementById("wsToggle");
  const statusCompact = document.getElementById("wsStatusCompact");

  const hasWebSerial = !!navigator.serial;
  const HOST_REQUIRED_MSG = "Habilite 'host' para abrir a serial";
  const LAST_BAUD_KEY = "ws.lastBaud";
  const WANT_AUTO_KEY = "ws.autoReconnect";
  const UI_KEY = "ws.uiExpanded";

  const state = {
    port: null,
    writer: null,
    reader: null,
    readPipeClosed: null,
    portOpening: null
  };

  function setUiExpanded(open) {
    if (wsBody) {
      wsBody.classList.toggle("show", !!open);
    }
    if (btnToggle) {
      btnToggle.setAttribute("aria-expanded", open ? "true" : "false");
      btnToggle.setAttribute("title", open ? "Ocultar painel" : "Mostrar painel");
      btnToggle.classList.toggle("btn-success", !!open);
      btnToggle.classList.toggle("btn-outline-light", !open);
    }
  }

  function initUiToggle() {
    const stored = (() => { try { return localStorage.getItem(UI_KEY); } catch { return null; }})();
    const startExpanded = stored === "1";
    setUiExpanded(startExpanded);
    if (btnToggle) {
      btnToggle.addEventListener("click", () => {
        const next = !wsBody?.classList.contains("show");
        setUiExpanded(next);
        try { localStorage.setItem(UI_KEY, next ? "1" : "0"); } catch {}
      });
    }
  }

  function log(msg, level = "info") {
    try {
      if (window.appLog) window.appLog(msg, level);
      else console[level === "error" ? "error" : level === "warn" ? "warn" : "log"](msg);
    } catch {}
  }

  function isHost() {
    try {
      const tags = (window.__TRYSTERO_PEER__ && typeof window.__TRYSTERO_PEER__.getLocalTags === "function")
        ? window.__TRYSTERO_PEER__.getLocalTags()
        : [];
      const hasTag = Array.isArray(tags) && tags.map(t => String(t || "").toLowerCase()).includes("host");
      if (hasTag) return true;
      return document.documentElement.classList.contains("host-on");
    } catch { return false; }
  }

  function setStatus(text, portText) {
    statusEl.textContent = text;
    if (statusCompact) {
      statusCompact.textContent = text;
      const isConnected = /conectad/i.test(text) && !/desconectad/i.test(text);
      statusCompact.classList.toggle("text-bg-success", isConnected);
      statusCompact.classList.toggle("text-bg-secondary", !isConnected);
    }
    portInfoEl.textContent = portText ?? portInfoEl.textContent;
  }
  function setButtons(connected) {
    const host = isHost();
    btnConnect.disabled = connected || !hasWebSerial || !host || !!state.portOpening;
    btnDisconnect.disabled = !connected;
  }

  function syncGlobals() {
    window.port = state.port;
    window.writer = state.writer;
    window.reader = state.reader;
  }

  async function refreshHostGuard() {
    const host = isHost();
    if (!host) {
      if (state.port) {
        try { await disconnectSerial(); } catch {}
      }
      setButtons(false);
      if (!state.port) setStatus(HOST_REQUIRED_MSG);
    } else {
      setButtons(!!state.port);
      if (!state.port) {
        setStatus("Desconectado");
        if (autoChk.checked) scheduleReconnect();
      }
    }
  }

  function prelimCheck() {
    if (!hasWebSerial) {
      setStatus("Navegador sem Web Serial.");
      log("Este navegador nao oferece navigator.serial. Use Chrome/Edge/Opera em HTTPS ou localhost.", "error");
      return false;
    }
    const httpsOk = location.protocol === "https:" || location.hostname === "localhost" || location.hostname === "127.0.0.1";
    if (!httpsOk) {
      setStatus("Necessita HTTPS/localhost");
      log("Web Serial exige site servido via HTTPS (ou localhost).", "warn");
      return false;
    }
    if (!isHost()) {
      setStatus(HOST_REQUIRED_MSG);
      log("Marcador de host desligado: serial bloqueada.", "warn");
      return false;
    }
    return true;
  }

  async function openPort(port, baud) {
    await port.open({ baudRate: baud, bufferSize: 255 });
    try { await port.setSignals({ dataTerminalReady: true, requestToSend: false }); } catch {}
    state.port = port;

    state.writer = port.writable ? port.writable.getWriter() : null;

    const textDecoder = new TextDecoderStream();
    state.readPipeClosed = port.readable.pipeTo(textDecoder.writable).catch(() => {});
    const reader = textDecoder.readable.getReader();
    state.reader = reader;

    (async () => {
      let carry = "";
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          carry += value;
          let idx;
          while ((idx = carry.search(/\r\n|\n/)) >= 0) {
            const line = carry.slice(0, idx);
            carry = carry.slice(idx + (carry.slice(idx, idx + 2) === "\r\n" ? 2 : 1));
            dispatchSerialLine(line);
          }
        }
      } catch (e) {
        log(`Leitura interrompida: ${e.message || e}`, "warn");
      } finally {
        try { reader.releaseLock(); } catch {}
      }
    })();

    setStatus("Conectado");
    setButtons(true);
    describePort(port);
    syncGlobals();
    window.dispatchEvent(new Event("serial-connected"));
    log(`Porta aberta @${baud} bps`);
  }

  function dispatchSerialLine(line) {
    try {
      if (typeof window.logSerialLine === "function") {
        // Log module already formats/prints; avoid duplicar aqui
        window.logSerialLine(line);
      } else {
        log(`SERIAL: ${line}`, "info");
      }
    } catch {}
  }

  function describePort(port) {
    try {
      const info = port.getInfo ? port.getInfo() : {};
      const vid = info.usbVendorId != null ? "0x" + info.usbVendorId.toString(16).padStart(4, "0") : "--";
      const pid = info.usbProductId != null ? "0x" + info.usbProductId.toString(16).padStart(4, "0") : "--";
      portInfoEl.textContent = `VID: ${vid} PID: ${pid}`;
    } catch { portInfoEl.textContent = "--"; }
  }

  async function ensureSerial(opts = {}) {
    const prompt = opts.prompt !== false;
    const quiet = opts.quiet === true;

    if (state.port && state.port.readable && state.port.writable) return;
    if (state.portOpening) return state.portOpening;
    if (!prelimCheck()) {
      if (!isHost()) throw new Error(HOST_REQUIRED_MSG);
      throw new Error("Web Serial indisponivel neste contexto.");
    }

    state.portOpening = (async () => {
      const baud = parseInt(baudSel.value || localStorage.getItem(LAST_BAUD_KEY) || "115200", 10);
      localStorage.setItem(LAST_BAUD_KEY, String(baud));

      const granted = await navigator.serial.getPorts();
      if (granted && granted.length) {
        const port = granted[0];
        log("Usando porta previamente concedida.");
        await openPort(port, baud);
        return;
      }

      if (!prompt) {
        if (!quiet) log("Auto-reconnect ignorado: nenhuma porta previamente concedida.", "warn");
        return;
      }

      const filters = [];
      const port = await navigator.serial.requestPort({ filters }).catch(e => { throw e; });
      await openPort(port, baud);
    })();

    try { await state.portOpening; }
    finally { state.portOpening = null; }
  }

  async function disconnectSerial() {
    try {
      if (state.reader) {
        try { await state.reader.cancel(); } catch {}
        try { state.reader.releaseLock && state.reader.releaseLock(); } catch {}
      }
      if (state.readPipeClosed) { try { await state.readPipeClosed; } catch {} }
      if (state.writer) {
        try { await state.writer.close?.(); } catch {}
        try { state.writer.releaseLock && state.writer.releaseLock(); } catch {}
      }
      if (state.port) {
        try { await state.port.close(); } catch {}
      }
    } finally {
      state.reader = null;
      state.writer = null;
      state.port = null;
      state.readPipeClosed = null;
      state.portOpening = null;
      syncGlobals();
      setStatus("Desconectado");
      setButtons(false);
      portInfoEl.textContent = "--";
      window.dispatchEvent(new Event("serial-disconnected"));
      log("Porta desconectada.");
    }
  }

  let reconnectTimer = null;
  let reconnectDelay = 1000;
  function scheduleReconnect() {
    if (!autoChk.checked) return;
    if (!isHost()) return;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(async () => {
      reconnectTimer = null;
      if (autoChk.checked && !state.port && isHost()) {
        try { await ensureSerial({ prompt: false, quiet: true }); }
        catch (e) {
          log(`Auto-reconnect falhou: ${e.message || e}`, "warn");
          reconnectDelay = Math.min(reconnectDelay * 2, 10000);
          scheduleReconnect();
        } finally {
          reconnectDelay = 1000;
        }
      }
    }, reconnectDelay);
  }

  if (hasWebSerial) {
    navigator.serial.addEventListener("connect", async () => {
      log("Dispositivo serial conectado (evento).");
      scheduleReconnect();
    });
    navigator.serial.addEventListener("disconnect", async () => {
      log("Dispositivo serial desconectado (evento).", "warn");
      await disconnectSerial().catch(() => {});
      scheduleReconnect();
    });
  }

  btnConnect.addEventListener("click", async () => {
    try { await ensureSerial(); }
    catch (e) {
      const msg = e && e.name === "NotFoundError" ? "Usuario cancelou a selecao da porta." : (e.message || String(e));
      log(`Falha ao conectar: ${msg}`, e && e.name === "NotFoundError" ? "warn" : "error");
      setStatus("Desconectado");
      setButtons(false);
    }
  });

  btnDisconnect.addEventListener("click", async () => {
    await disconnectSerial();
  });

  baudSel.addEventListener("change", () => {
    localStorage.setItem(LAST_BAUD_KEY, baudSel.value);
    if (state.port) {
      log(`Baud alterado para ${baudSel.value}. Desconecte e reconecte para aplicar.`, "warn");
    }
  });

  autoChk.addEventListener("change", () => {
    localStorage.setItem(WANT_AUTO_KEY, autoChk.checked ? "1" : "0");
    if (autoChk.checked) scheduleReconnect();
  });

  window.addEventListener("trystero:localTags", refreshHostGuard);

  const savedBaud = localStorage.getItem(LAST_BAUD_KEY);
  if (savedBaud) baudSel.value = savedBaud;
  const savedAuto = localStorage.getItem(WANT_AUTO_KEY);
  if (savedAuto != null) autoChk.checked = savedAuto === "1";
  else autoChk.checked = false;

  initUiToggle();
  setButtons(false);
  if (!hasWebSerial) {
    setStatus("Navegador sem Web Serial");
  } else {
    setStatus("Desconectado");
    navigator.serial.getPorts().then((ports) => {
      if (ports.length && autoChk.checked && isHost()) {
        log("Abrindo porta previamente concedida (auto).");
        ensureSerial({ prompt: false, quiet: true }).catch(e => log(`Auto open falhou: ${e.message || e}`, "warn"));
      } else if (!isHost()) {
        setStatus(HOST_REQUIRED_MSG);
      }
    });
  }
  refreshHostGuard();

  syncGlobals();
  window.ensureSerial = ensureSerial;
  window.disconnectSerial = disconnectSerial;

})();
</script>

<!-- PATCH: habilita receber comandos externos (chat -> serial) -->
<script>
(() => {
  const enc = new TextEncoder();
  const MIRROR_STATE_KEY = "remote_control_state_v1";

  function shouldMirrorOpposite() {
    try {
      const raw = localStorage.getItem(MIRROR_STATE_KEY);
      if (!raw) return false;
      const parsed = JSON.parse(raw);
      return !!(parsed && parsed.advanced && parsed.advanced.mirrorChan2);
    } catch {
      return false;
    }
  }

  function mirrorCommandToOppositeChannel(text) {
    const raw = String(text ?? "");
    const trimmed = raw.trim();
    if (!trimmed) return null;

    const holdMatch = trimmed.match(/^(HOLDON\s+)(.+)$/i);
    const prefix = holdMatch ? holdMatch[1] : "";
    const body = holdMatch ? holdMatch[2] : trimmed;

    const cmdMatch = body.match(/^([A-Z]+)\s*,\s*([+-]?\d+(?:\.\d+)?)\s*,\s*(\d+)(.*)$/i);
    if (!cmdMatch) return null;

    const channelNum = Number(cmdMatch[3]);
    if (!Number.isFinite(channelNum) || (channelNum !== 1 && channelNum !== 2)) return null;

    const targetChannel = channelNum === 2 ? 1 : 2;
    const suffix = cmdMatch[4] || "";
    const mirroredBody = `${cmdMatch[1]},${cmdMatch[2]},${targetChannel}${suffix}`;
    return prefix ? `${prefix}${mirroredBody}` : mirroredBody;
  }

  try {
    window.__SERIAL_MIRROR__ = window.__SERIAL_MIRROR__ || {};
    window.__SERIAL_MIRROR__.shouldMirrorOpposite = shouldMirrorOpposite;
    window.__SERIAL_MIRROR__.mirrorCommandToOppositeChannel = mirrorCommandToOppositeChannel;
  } catch {}

  async function writeLineRaw(line) {
    const trimmed = String(line ?? "").trim();
    if (!trimmed) return;

    try {
      if (!window.port || !window.port.writable) {
        throw new Error("Porta serial indisponivel");
      }

      if (!window.writer) {
        try { window.writer = window.port.writable.getWriter(); }
        catch (e) { if (!/locked/i.test(String(e))) throw e; }
      }

    const payload = /(\r\n|\n)$/.test(trimmed) ? trimmed : (trimmed + "\n");
    try {
      const clean = payload.replace(/\r?\n$/, "");
      window.dispatchEvent(new CustomEvent("serial-tx", { detail: { line: clean } }));
    } catch {}
    await window.writer.write(enc.encode(payload));

    try { (window.appLog || console.log)(`TX: ${payload.replace(/\n$/, "")}`); } catch {}
    } catch (err) {
      try { (window.appLog || console.error)(`TX erro: ${err && err.message ? err.message : err}`); } catch {}
    }
  }

  async function writeLine(line, opts = {}) {
    const trimmed = String(line ?? "").trim();
    if (!trimmed) return;

    const forceBoth = !!opts.forceBothChannels;
    const noMirror = !!opts.noMirror;
    let lines = [trimmed];

    if (forceBoth) {
      const mirrored = mirrorCommandToOppositeChannel(trimmed);
      if (mirrored && mirrored !== trimmed) lines = [trimmed, mirrored];
    } else if (!noMirror && shouldMirrorOpposite()) {
      const mirrored = mirrorCommandToOppositeChannel(trimmed);
      if (mirrored && mirrored !== trimmed) lines = [trimmed, mirrored];
    }

    for (const cmd of lines) {
      await writeLineRaw(cmd);
    }
  }

  window.collarSend = async (line, opts) => writeLine(line, opts);
  window.SerialBridge = window.SerialBridge || {};
  window.SerialBridge.send = window.collarSend;

  window.addEventListener("collar:tx", (e) => {
    const detail = e?.detail || {};
    const line = detail.line ? detail.line : "";
    if (!line) return;
    writeLine(line, {
      noMirror: !!detail.noMirror,
      forceBothChannels: !!detail.forceBothChannels
    });
  });

  try { (window.appLog || console.log)("PATCH serial forwarder: pronto (escutando 'collar:tx')."); } catch {}
})();
</script>

<style>
  #smView .sm-line { line-height: 1.25; padding: 2px 0; }
  #smView .sm-ts { opacity: .75; margin-right: 6px; }

  #smView .sm-dir { display:inline-flex; align-items:center; gap:.45rem; min-width: 3.2rem; }
  #smView .sm-icon { width: 1.2rem; text-align:center; }

  /* RX/TX */
  #smView .sm-rx { color: #22c55e; } /* verde */
  #smView .sm-tx { color: #ef4444; } /* vermelho */

  /* Tipos de comando (texto do comando) */
  #smView .cmd-shock     { color: #3b82f6; } /* azul */
  #smView .cmd-beep      { color: #22c55e; } /* verde */
  #smView .cmd-vibration { color: #eab308; } /* amarelo */
  #smView .cmd-light     { color: #ef4444; } /* vermelho */

  /* Contador de repeticao */
  #smView .sm-dup { opacity: .85; margin-left: 8px; }
</style>

<script>
(() => {
  const $  = s => document.querySelector(s);
  const view = $("#smView");
  const inp  = $("#smInput");
  const btnSend = $("#smSend");
  const btnPause = $("#smPause");
  const btnClear = $("#smClear");
  const cbTs  = $("#smTimestamps");
  const cbWrap= $("#smWrap");
  const selEOL= $("#smEOL");

  let paused = false;
  let autoscroll = true;

  // Compactacao
  let lastKey = null;
  let lastLineEl = null;
  let lastCount = 1;

  function nowTs() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function iconEl(cls) {
    const i = document.createElement("i");
    i.className = `fa-solid ${cls}`;
    i.setAttribute("aria-hidden", "true");
    return i;
  }

  // Remove sufixos "(3x)" vindos do proprio texto para nao quebrar a compactacao
  function stripInlineCounter(s) {
    return String(s ?? "").replace(/\(\s*\d+\s*x\s*\)\s*$/i, "").trim();
  }

  // Normaliza entidades cruas que chegam como texto
  function normalizeIncoming(s) {
    let t = String(s ?? "");

    // Entidades vistas nos seus logs (literal, nao renderiza como emoji)
    t = t
      .replace(/&#11013;(&#65039;)?/g, "")   // seta esquerda literal
      .replace(/&#10145;(&#65039;)?/g, "")  // seta direita literal
      .replace(/&#9889;?/g, "")             // raio literal

      // tambem remove entidades nomeadas se vierem cruas
      .replace(/&larr;?/gi, "")
      .replace(/&rarr;?/gi, "");

    // remove setas unicode se vierem embutidas
    t = t.replace(/[\u2190\u2192]/g, "");

    // limpa espacos duplicados
    return t.replace(/\s{2,}/g, " ").trim();
  }

  // Extrai (modo, nivel, canal)
  // Suporta: SHOCK, BEEP/BIP, VIBRATION, LIGHT/LUZ
  // Ex: "OK SHOCK,12,1" / "OK VIBRATION,8,1" / "LIGHT,0,1"
  function parseTuple(text) {
    const cleaned = stripInlineCounter(normalizeIncoming(text))
      .replace(/^(OK|ERR|ERROR|INFO|WARN|WARNING|DBG|DEBUG)\s+/i, "");

    const re = /\b(SHOCK|BEEP|BIP|VIBRATION|LIGHT|LUZ)\b\s*,\s*(\d+)\s*,\s*(\d+)\b/i;
    const m = cleaned.match(re);
    if (!m) return null;

    const raw = m[1].toUpperCase();
    const mode =
      raw === "BIP" ? "BEEP" :
      raw === "LUZ" ? "LIGHT" :
      raw; // VIBRATION permanece VIBRATION

    return { mode, lvl: Number(m[2]), ch: Number(m[3]) };
  }

  function cmdMeta(mode) {
    switch (mode) {
      case "SHOCK":
        return { cls: "cmd-shock", icon: "fa-bolt", label: "SHOCK" };
      case "BEEP":
        return { cls: "cmd-beep", icon: "fa-volume-high", label: "BEEP" };
      case "VIBRATION":
        return { cls: "cmd-vibration", icon: "fa-mobile-screen-button", label: "VIBRATION" };
      case "LIGHT":
        return { cls: "cmd-light", icon: "fa-lightbulb", label: "LUZ" };
      default:
        return { cls: "", icon: "", label: mode };
    }
  }

  function makeKey(dir, originalText) {
    const normalized = stripInlineCounter(normalizeIncoming(originalText));
    const tuple = parseTuple(normalized);

    if (tuple) return `${dir}|${tuple.mode}|${tuple.lvl}|${tuple.ch}`;
    return `${dir}|RAW|${normalized}`;
  }

  function setDupCounter(el, count) {
    let dup = el.querySelector(".sm-dup");
    if (count <= 1) {
      if (dup) dup.remove();
      return;
    }
    if (!dup) {
      dup = document.createElement("span");
      dup.className = "sm-dup";
      el.appendChild(dup);
    }
    dup.textContent = `(${count}x)`;
  }

  function appendLine(text, dir = "in") {
    if (paused) return;

    const key = makeKey(dir, text);

    // Compacta somente quando identico (mesmo modo/nivel/canal ou RAW identico)
    if (key === lastKey && lastLineEl) {
      lastCount += 1;
      setDupCounter(lastLineEl, lastCount);
      if (autoscroll) view.scrollTop = view.scrollHeight;
      return;
    }

    lastKey = key;
    lastCount = 1;

    const line = document.createElement("div");
    line.className = "sm-line";
    lastLineEl = line;

    // Timestamp
    if (cbTs.checked) {
      const ts = document.createElement("span");
      ts.className = "sm-ts";
      ts.textContent = `[${nowTs()}]`;
      line.appendChild(ts);
      line.appendChild(document.createTextNode(" "));
    }

    // Direcao RX/TX com Font Awesome
    const dirSpan = document.createElement("span");
    dirSpan.className = `sm-dir ${dir === "out" ? "sm-tx" : "sm-rx"}`;

    const arrowWrap = document.createElement("span");
    arrowWrap.className = "sm-icon";
    arrowWrap.appendChild(iconEl(dir === "out" ? "fa-arrow-right" : "fa-arrow-left"));
    dirSpan.appendChild(arrowWrap);

    line.appendChild(dirSpan);
    line.appendChild(document.createTextNode(" "));

    // Conteudo normalizado
    const normalizedText = stripInlineCounter(normalizeIncoming(text));
    const tuple = parseTuple(normalizedText);

    if (tuple) {
      const meta = cmdMeta(tuple.mode);

      // Prefixo (OK, etc.) preservado quando possivel
      const cleaned = normalizeIncoming(text);
      const upper = cleaned.toUpperCase();
      const idx = upper.indexOf(tuple.mode);
      const prefix = (idx > 0 ? cleaned.slice(0, idx).trim() : "")
        .replace(/\s{2,}/g, " ")
        .trim();

      if (prefix) {
        const pre = document.createElement("span");
        pre.textContent = prefix + " ";
        line.appendChild(pre);
      }

      // Icone + label com cor
      const cmd = document.createElement("span");
      cmd.className = meta.cls;

      if (meta.icon) {
        const ic = iconEl(meta.icon);
        ic.style.marginRight = ".35rem";
        cmd.appendChild(ic);
      }
      cmd.appendChild(document.createTextNode(meta.label));
      line.appendChild(cmd);

      // Restante ",lvl,ch"
      const rest = document.createElement("span");
      rest.textContent = `,${tuple.lvl},${tuple.ch}`;
      line.appendChild(rest);
    } else {
      const msg = document.createElement("span");
      msg.textContent = normalizedText;
      line.appendChild(msg);
    }

    view.appendChild(line);
    setDupCounter(line, 1);

    if (autoscroll) view.scrollTop = view.scrollHeight;
  }

  // UI
  btnPause.addEventListener("click", () => {
    paused = !paused;
    btnPause.textContent = paused ? "Continuar" : "Pausar";
  });

  btnClear.addEventListener("click", () => {
    view.innerHTML = "";
    lastKey = null;
    lastLineEl = null;
    lastCount = 1;
  });

  cbWrap.addEventListener("change", () => {
    view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
  });

  view.addEventListener("scroll", () => {
    autoscroll = (view.scrollHeight - view.scrollTop - view.clientHeight) < 8;
  });

  // Envio TX
  async function writeRaw(raw) {
    if (!raw?.length) return;

    const eolVal = selEOL.value
      .replaceAll("\\n", "\n")
      .replaceAll("\\r", "\r");
    const mirrorHelper = window.__SERIAL_MIRROR__;
    const shouldMirror = !!(mirrorHelper && typeof mirrorHelper.shouldMirrorOpposite === "function" && mirrorHelper.shouldMirrorOpposite());
    const mirrored = shouldMirror && typeof mirrorHelper.mirrorCommandToOppositeChannel === "function"
      ? mirrorHelper.mirrorCommandToOppositeChannel(raw)
      : null;
    const lines = (mirrored && mirrored !== raw) ? [raw, mirrored] : [raw];

    // Somente envia se a porta ja estiver aberta; nao tenta abrir sozinho
    let useWriter = (typeof writer !== "undefined" && writer) ? writer : null;
    if (!useWriter && window.port?.writable) {
      try { useWriter = await window.port.writable.getWriter(); } catch(_) {}
    }

    if (!useWriter) {
      appendLine(`(sem porta) ${raw}`, "out");
      return;
    }

    try {
      for (const line of lines) {
        const payload = line + eolVal;
        await useWriter.write(new TextEncoder().encode(payload));
        appendLine(line, "out");
      }
    } catch (e) {
      appendLine(`ERRO envio: ${e?.message || e}`, "out");
    } finally {
      try { if (useWriter !== writer) useWriter.releaseLock(); } catch(_) {}
    }
  }

  btnSend.addEventListener("click", async () => {
    const txt = inp.value.trimEnd();
    await writeRaw(txt);
    inp.value = "";
    inp.focus();
  });

  inp.addEventListener("keydown", async (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      const txt = inp.value.trimEnd();
      await writeRaw(txt);
      inp.value = "";
    }
  });

  // Hook RX
  const prevLogSerialLine = window.logSerialLine;
  const wrappedLogSerialLine = function(line) {
    try {
      if (line != null && line !== "") {
        const parts = String(line)
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n")
          .split("\n");
        for (const p of parts) if (p.length) appendLine(p, "in");
      }
    } catch(_) {}
    if (typeof prevLogSerialLine === "function") prevLogSerialLine(line);
  };
  wrappedLogSerialLine._orig = prevLogSerialLine;
  window.logSerialLine = wrappedLogSerialLine;

  window.addEventListener?.("serial-tx", (ev) => {
    const line = ev?.detail?.line;
    if (line != null && line !== "") appendLine(line, "out");
  });

  window.addEventListener?.("serial-connected", () => appendLine("Porta conectada.", "in"));
  window.addEventListener?.("serial-disconnected", () => appendLine("Porta desconectada.", "in"));

  view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
})();
</script>

<script>
(() => {
  const $ = s => document.querySelector(s);
  const view = $("#lmView");
  const btnPause = $("#lmPause");
  const btnClear = $("#lmClear");
  const btnCopy  = $("#lmCopy");
  const btnSave  = $("#lmSave");
  const cbTs   = $("#lmTimestamps");
  const cbWrap = $("#lmWrap");
  const selLvl = $("#lmLevel");

  let paused = false;
  let autoscroll = true;
  let filterLevel = "all";
  const buffer = []; // mant├®m texto para copiar/salvar

  function nowTs() {
    const d = new Date();
    const pad = n => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  function levelAllows(level) {
    if (filterLevel === "all") return true;
    return level === filterLevel;
  }

  function colorFor(level) {
    if (level === "error") return "#ff6b6b";
    if (level === "warn")  return "#ffd166";
    return "#9ad1ff";
  }

  function appendLine(text, level="info") {
    if (!levelAllows(level)) return;
    if (paused) return;

    const line = document.createElement("div");
    line.className = "lm-line";
    const ts = cbTs.checked ? `[${nowTs()}] ` : "";
    line.textContent = `${ts}${level.toUpperCase()}: ${text}`;
    line.style.color = colorFor(level);
    view.appendChild(line);

    // guarda vers├úo ÔÇ£cruaÔÇØ (sem cor) para export/copy
    buffer.push(`${ts}${level.toUpperCase()}: ${text}`);

    if (autoscroll) view.scrollTop = view.scrollHeight;
  }

  // Controles UI
  btnPause.addEventListener("click", () => {
    paused = !paused;
    btnPause.textContent = paused ? "Continuar" : "Pausar";
  });
  btnClear.addEventListener("click", () => { view.innerHTML = ""; buffer.length = 0; });
  btnCopy.addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(buffer.join("\n")); btnCopy.textContent = "Copiado!"; setTimeout(()=>btnCopy.textContent="Copiar",1200); }
    catch { /* ignore */ }
  });
  btnSave.addEventListener("click", () => {
    const blob = new Blob([buffer.join("\n")], {type:"text/plain"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `log_${new Date().toISOString().replace(/[:.]/g,"-")}.txt`;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  });
  cbWrap.addEventListener("change", () => {
    view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";
  });
  selLvl.addEventListener("change", () => {
    filterLevel = selLvl.value;
    // Re-render simples (limpa e repopula do buffer conforme filtro)
    const snapshot = buffer.slice();
    view.innerHTML = "";
    for (const line of snapshot) {
      const level = line.includes("ERROR:") ? "error" : line.includes("WARN:") ? "warn" : "info";
      if (levelAllows(level)) {
        const div = document.createElement("div");
        div.className = "lm-line";
        div.textContent = line;
        div.style.color = colorFor(level);
        view.appendChild(div);
      }
    }
    view.scrollTop = view.scrollHeight;
  });

  // Autoscroll on/off baseado na rolagem
  view.addEventListener("scroll", () => {
    const nearBottom = view.scrollHeight - view.scrollTop - view.clientHeight < 8;
    autoscroll = nearBottom;
  });

  // ===== API Global =====
  // appLog(msg, level="info") ÔÇö n├¡vel: "info"|"warn"|"error"
  // Tamb├®m aceita CustomEvent('app-log', {detail:{msg, level}})
  const originalConsole = {
    log:   console.log.bind(console),
    warn:  console.warn.bind(console),
    error: console.error.bind(console),
  };

  function appLog(msg, level="info") {
    try {
      let text = "";
      if (msg instanceof Error) {
        text = `${msg.name || "Error"}: ${msg.message}`;
      } else if (typeof msg === "object") {
        text = JSON.stringify(msg);
      } else {
        text = String(msg);
      }
      appendLine(text, level);
    } catch(_) {}
  }

  // exp├Áe global
  window.appLog = appLog;

  // escuta eventos personalizados
  window.addEventListener("app-log", (ev) => {
    const d = ev?.detail || {};
    appLog(d.msg, d.level || "info");
  });

  // espelha console.* no painel, preservando comportamento original
  console.log = (...args) => { originalConsole.log(...args); appLog(args.map(String).join(" "), "info"); };
  console.warn = (...args) => { originalConsole.warn(...args); appLog(args.map(String).join(" "), "warn"); };
  console.error = (...args) => { originalConsole.error(...args); appLog(args.map(String).join(" "), "error"); };

  // Integra├º├úo opcional: tamb├®m mostra linhas vindas do Serial (se existir)
  const prevLogSerialLine = window.logSerialLine;
  const wrappedLogSerialLine = function(line){
    try {
      if (line != null && line !== "") {
        const parts = String(line).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");
        for (const p of parts) if (p.length) appLog(`SERIAL: ${p}`, "info");
      }
    } catch(_) {}
    if (typeof prevLogSerialLine === "function") prevLogSerialLine(line);
  };
  wrappedLogSerialLine._orig = prevLogSerialLine;
  window.logSerialLine = wrappedLogSerialLine;

  // Estado inicial
  view.style.whiteSpace = cbWrap.checked ? "pre-wrap" : "pre";

  // Mensagem inicial
  appLog("Monitor de LOG iniciado.", "info");
})();
</script>
