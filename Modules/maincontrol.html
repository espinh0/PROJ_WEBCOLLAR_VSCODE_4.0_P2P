<!-- CONTROLE MANUAL v3.3 (Flowgate/Chat Bus; clique = comando unico; segurar = HOLD; sem Firebase) -->
<style>
  #remoteControlWrapper {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 900;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 0 8px;
    pointer-events: none; /* evita bloquear cliques fora do controle */
  }
  #remoteControlWrapper.inline-mode {
    position: static;
    bottom: auto;
    left: auto;
    transform: none;
    padding: 0;
    pointer-events: auto;
    align-items: stretch;
    width: 100%;
    max-width: 100%;
  }
  #remoteControlWrapper.inline-mode #controlShell {
    flex-direction: column;
    align-items: stretch;
    max-width: none;
    max-height: none;
    overflow: visible;
    width: 100%;
    min-width: 0;
  }
  #remoteControlWrapper.inline-mode #remoteControlCard {
    width: 100%;
    min-width: unset;
  }
  #controlShell {
    display: flex;
    align-items: flex-start;
    gap: 8px;
    pointer-events: auto;
    min-width: 32%;
    max-width: 100%;
    position: relative;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
    overscroll-behavior: contain;
  }
  @media (max-height: 900px) {
    #controlShell {
      max-height: calc(100vh - 56px);
      overflow-y: auto;
    }
  }
  @media (max-height: 720px) {
    #controlShell {
      max-height: calc(100vh - 32px);
    }
  }
  #remoteControlCard {
    width: auto;
    min-width: 300px;
    max-width: 100%;
    border-radius: 16px;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    text-align: left;
  }
  @media (max-width: 640px) {
    #remoteControlWrapper {
      position: static;
      left: auto;
      transform: none;
      padding: 0;
    }
    #controlShell {
      flex-direction: column;
      align-items: stretch;
      max-width: none;
    }
    #remoteControlCard {
      width: 100%;
      min-width: unset;
    }
  }
  .control-row {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-start;
    gap: 12px;
    width: 100%;
  }
  @media (max-width: 640px) {
    .control-row {
      flex-direction: column;
      align-items: stretch;
    }
    .module-btn-group,
    .control-action-group {
      margin-left: 0;
      width: 100%;
      justify-content: center;
    }
  }
  @media (max-width: 1024px) {
    .module-btn-group,
    .control-action-group {
      margin-left: 0;
      width: 100%;
      justify-content: center;
    }
  }
  .control-slider-row {
    width: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    max-height: 220px;
    overflow: hidden;
  }
  #rouletteRow {
    width: 100%;
    display: flex;
    justify-content: center;
    max-height: 1200px;
    overflow: hidden;
  }
  #remoteControlCard #roletas-widget {
    width: 100%;
    margin: 0;
    background: transparent !important;
    border: none !important;
    border-radius: 14px;
    padding: 0 !important;
  }
  #remoteControlCard #roletas-widget .r3-layout {
    gap: clamp(0.75rem, 1.5vw, 1.5rem);
  }
  .naval-module-slot,
  .pulse-sequencer-slot,
  .video-player-slot,
  .custom-buttons-slot {
    width: 100%;
  }
  #remoteControlCard #navalModuleMount,
  #remoteControlCard #pulseSequencerMount,
  #remoteControlCard #videoPlayerMount {
    width: 100%;
  }
  .control-scoreboard-block,
  .control-audio-block,
  .naval-module-slot,
  .pulse-sequencer-slot,
  .video-player-slot,
  .chart-block {
    width: 100%;
    transition: max-height .24s ease, opacity .18s ease, margin .18s ease, padding .18s ease;
    margin-bottom: 0;
    overflow: hidden;
  }
  .control-scoreboard-block:not(.collapsed),
  .control-audio-block:not(.collapsed),
  .naval-module-slot:not(.collapsed),
  .pulse-sequencer-slot:not(.collapsed),
  .video-player-slot:not(.collapsed),
  .chart-block:not(.collapsed) {
    margin-bottom: 18px;
  }
  .control-scoreboard-block.collapsed,
  .control-audio-block.collapsed,
  .naval-module-slot.collapsed,
  .pulse-sequencer-slot.collapsed,
  .video-player-slot.collapsed,
  .chart-block.collapsed {
    max-height: 0;
    opacity: 0;
    margin-top: 0;
    margin-bottom: 0 !important;
    padding-top: 0;
    padding-bottom: 0;
    padding-left: 0;
    padding-right: 0;
    border-width: 0;
    pointer-events: none;
    visibility: hidden;
  }
  .control-scoreboard-mount,
  .control-audio-mount,
  #navalModuleMount,
  #pulseSequencerMount,
  #videoPlayerMount {
    width: 100%;
  }
  .scoreboard-embed-state,
  .audio-embed-state,
  .naval-embed-state,
  .pulse-embed-state,
  .video-embed-state,
  .roulette-embed-state {
    border-radius: 16px;
    padding: 20px 16px;
    text-align: center;
    font-size: 0.9rem;
  }
  .scoreboard-loading-state,
  .audio-loading-state,
  .naval-loading-state,
  .pulse-loading-state,
  .video-loading-state,
  .roulette-loading-state {
    border: 1px dashed rgba(255,255,255,0.18);
    color: #94a3b8;
    background: rgba(8,10,18,0.45);
  }
  .scoreboard-error-state,
  .audio-error-state,
  .naval-error-state,
  .pulse-error-state,
  .video-error-state,
  .roulette-error-state {
    border: 1px solid rgba(239,68,68,0.4);
    color: #fecaca;
    background: rgba(63,0,0,0.45);
  }
  .event-canvas-slot {
    width: 100%;
    margin-top: 18px;
  }
  .control-status-bar {
    display: flex;
    flex-wrap: wrap;
    align-items: flex-start;
    justify-content: space-between;
    gap: 12px;
    width: 100%;
  }
  .control-status-groups {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 12px;
    flex: 1 1 auto;
    min-width: 0;
  }
  .control-peer-list {
    margin-left: auto;
    display: inline-flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: flex-end;
    gap: 0.35rem;
    min-height: 38px;
    text-align: right;
  }
  .control-peer-list #fg-peer-list {
    display: inline-flex;
    justify-content: flex-end;
  }
  #remoteControlCard .status-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.35rem 0.7rem;
    border-radius: 999px;
    font-size: 0.9rem;
    background: rgba(255, 255, 255, 0.06);
    border: 1px solid rgba(255, 255, 255, 0.12);
    color: #e5e7eb;
  }
  #remoteControlCard .status-pill[data-status="ok"] { border-color: rgba(34, 197, 94, 0.6); color: #bbf7d0; }
  #remoteControlCard .status-pill[data-status="warn"] { border-color: rgba(249, 115, 22, 0.6); color: #fed7aa; }
  #remoteControlCard .status-pill[data-status="off"] { border-color: rgba(239, 68, 68, 0.6); color: #fecaca; }
  #remoteControlCard .status-label {
    font-size: 0.75rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: #94a3b8;
  }
  #remoteControlCard .peer-chip {
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.6rem;
    border-radius: 999px;
    font-size: 0.85rem;
    background: rgba(77, 113, 255, 0.16);
    border: 1px solid rgba(77, 113, 255, 0.35);
    color: #e0e7ff;
    white-space: nowrap;
  }
  .serial-device-list {
    display: inline-flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.3rem;
    min-width: 0;
  }
  .serial-device-chip {
    display: inline-flex;
    align-items: center;
    padding: 0.2rem 0.5rem;
    border-radius: 999px;
    font-size: 0.8rem;
    background: rgba(34, 197, 94, 0.18);
    border: 1px solid rgba(34, 197, 94, 0.35);
    color: #d1fae5;
    white-space: nowrap;
  }
  .serial-device-empty {
    font-size: 0.78rem;
    color: #94a3b8;
  }
  #remoteControlCard .status-pill .status-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1rem;
    color: #cbd5f5;
  }
  .event-canvas-card {
    position: relative;
    border-radius: 16px;
    padding: 0;
    background: transparent;
    border: none;
    overflow: hidden;
  }
  .chart-embed-placeholder {
    border: 1px dashed rgba(255,255,255,0.25);
    border-radius: 16px;
    padding: 24px;
    text-align: center;
    color: #94a3b8;
    font-size: 0.9rem;
    background: rgba(10,12,18,0.35);
  }
  .embedded-event-chart {
    width: 100%;
    margin: 0;
  }
  #remoteControlCard #customPads {
    width: 100%;
  }
  #remoteControlCard #customPads .cp-grid {
    justify-content: flex-start;
  }
  .mode-toggle {
    max-width: 420px;
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: flex-start;
  }
  .module-btn-group {
    display: flex;
    flex-wrap: nowrap;
    gap: 10px;
  }
  .control-action-group {
    display: flex;
    flex-wrap: nowrap;
    align-items: center;
    gap: 10px;
    margin-left: auto;
    justify-content: flex-end;
  }
  .mode-btn {
    --mc-color: #4d71ff;
    --mc-tint: rgba(77,113,255,0.12);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 14px;
    background: linear-gradient(120deg, var(--mc-tint), rgba(12,12,14,0.95));
    color: #e5e7eb;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
    min-width: 70px;
    transition: border-color .2s ease, box-shadow .2s ease, transform .2s ease;
    box-shadow: 0 6px 16px rgba(0,0,0,0.28);
  }
  .mode-btn .mode-icon {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 1.4rem;
    color: var(--mc-color);
  }
  .mode-btn:hover {
    border-color: var(--mc-color);
    box-shadow: 0 10px 22px rgba(0,0,0,0.35);
    transform: translateY(-1px);
  }
  .mode-btn.active {
    border-color: var(--mc-color);
    border-width: 2px;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 12px 26px rgba(0,0,0,0.4);
  }
  .mode-btn[data-mode="SHOCK"] { --mc-color: #f97316; --mc-tint: rgba(249,115,22,0.16); }
  .mode-btn[data-mode="VIBRATION"] { --mc-color: #10b981; --mc-tint: rgba(16,185,129,0.18); }
  .mode-btn[data-mode="LIGHT"] { --mc-color: #facc15; --mc-tint: rgba(250,204,21,0.16); }
  .mode-btn[data-mode="BEEP"] { --mc-color: #60a5fa; --mc-tint: rgba(96,165,250,0.18); }
  .mode-btn[data-mode="ROULETTE"] { --mc-color: #f472b6; --mc-tint: rgba(244,114,182,0.18); }
  .level-wrap {
    min-width: 200px;
    position: relative;
  }
  .level-tooltip-anchor {
    position: absolute;
    top: -4px;
    width: 1px;
    height: 1px;
    pointer-events: none;
  }
  .level-slider {
    --lvl: 0%;
    --lvlColor: #ff6b6b;
    --thumb: #ff6b6b;
    appearance: none;
    width: 100%;
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--lvlColor) 0%, var(--lvlColor) var(--lvl), #2c3040 var(--lvl), #2c3040 100%);
    outline: none;
  }
  .level-slider::-webkit-slider-runnable-track {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--lvlColor) 0%, var(--lvlColor) var(--lvl), #2c3040 var(--lvl), #2c3040 100%);
  }
  .level-slider::-moz-range-track {
    height: 10px;
    border-radius: 999px;
    background: linear-gradient(90deg, var(--lvlColor) 0%, var(--lvlColor) var(--lvl), #2c3040 var(--lvl), #2c3040 100%);
  }
  .level-slider::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid #0f111a;
    background: var(--thumb);
    box-shadow: 0 0 0 2px #1b1f2a;
    margin-top: -4px;
  }
  .level-slider::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid #0f111a;
    background: var(--thumb);
    box-shadow: 0 0 0 2px #1b1f2a;
  }
  .level-input {
    background: transparent;
    color: #e7eaee;
    border: none;
    min-width: 0;
    width: fit-content;
    text-align: center;
    font-size: 2rem;
    font-weight: 600;
    padding: 0;
    flex: 0 0 auto;
    display: inline-block;
    line-height: 1;
  }
  .level-input:focus,
  .level-input:active {
    background: transparent;
    border: none;
    outline: none;
    box-shadow: none;
  }
  .btn-send {
    --send-color: #ef4444;
    --send-tint: rgba(239,68,68,0.16);
    --send-tint-strong: rgba(239,68,68,0.32);
    width: 64px;
    height: 64px;
    padding: 0;
    border-radius: 50%;
    font-weight: 700;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    letter-spacing: 0.02em;
    border: 3px solid rgba(239,68,68,0.65);
    background: linear-gradient(125deg, var(--send-tint), rgba(9,10,15,0.92));
    color: #ffecec;
    box-shadow: 0 8px 20px rgba(239,68,68,0.25), 0 4px 12px rgba(0,0,0,0.35);
    transition: transform .12s ease, box-shadow .15s ease, background .15s ease, border-color .15s ease, color .1s ease;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn-send i {
    color: var(--send-color);
    transition: color .12s ease;
  }
  .btn-send:hover {
    border-color: var(--send-color);
    background: linear-gradient(125deg, var(--send-tint-strong), rgba(23,6,8,0.92));
    color: #fff1f1;
    box-shadow: 0 10px 26px rgba(239,68,68,0.35), 0 6px 12px rgba(0,0,0,0.35);
    transform: translateY(-1px);
  }
  .btn-send i {
    font-size: 1.2rem;
  }
  .btn-send:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(239,68,68,0.25);
  }
  .btn-send.pressed { transform: translateY(1px); }
  .btn-send.holding,
  .btn-send.adv-running {
    background: linear-gradient(120deg, rgba(239,68,68,0.95), rgba(190,18,60,0.9));
    border-color: rgba(239,68,68,0.95) !important;
    color: #fff !important;
    box-shadow: 0 10px 26px rgba(239,68,68,0.45), 0 0 0 0.15rem rgba(239,68,68,0.35);
  }
  .btn-send.holding i,
  .btn-send.adv-running i {
    color: #ffffff;
  }
  .btn-advanced-toggle {
    --adv-color: #9ca3af;
    --adv-tint: rgba(156,163,175,0.18);
    --adv-tint-strong: rgba(156,163,175,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(156,163,175,0.35);
    background: linear-gradient(120deg, var(--adv-tint), rgba(12,12,14,0.92));
    color: #f3f4f6;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-advanced-toggle i {
    color: var(--adv-color);
    transition: color .12s ease;
  }
  .btn-advanced-toggle:hover {
    border-color: rgba(156,163,175,0.6);
    background: linear-gradient(120deg, var(--adv-tint-strong), rgba(18,19,24,0.95));
    color: #fff;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-advanced-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(156,163,175,0.3);
  }
  .btn-advanced-toggle[aria-expanded="true"] {
    border-color: rgba(156,163,175,0.75);
    background: linear-gradient(120deg, rgba(156,163,175,0.28), rgba(50,54,65,0.95));
    color: #fff;
    box-shadow: 0 0 0 2px rgba(156,163,175,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-advanced-toggle[aria-expanded="true"] i {
    color: #f9fafb;
  }
  .btn-save-shortcut {
    --save-color: #facc15;
    --save-tint: rgba(250,204,21,0.18);
    --save-tint-strong: rgba(250,204,21,0.32);
    min-width: 48px;
    min-height: 48px;
    height: 48px;
    padding: 10px 14px;
    border-radius: 100%;
    border: 1px solid rgba(250,204,21,0.38);
    background: linear-gradient(120deg, var(--save-tint), rgba(12,12,14,0.92));
    color: #fff7ed;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
    line-height: 1;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .btn-save-shortcut i {
    color: var(--save-color);
    transition: color .12s ease;
  }
  .btn-save-shortcut:hover {
    border-color: rgba(250,204,21,0.65);
    background: linear-gradient(120deg, var(--save-tint-strong), rgba(18,19,24,0.95));
    color: #fff7ed;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-save-shortcut:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(250,204,21,0.3);
  }
  .btn-scoreboard-toggle {
    --sb-color: var(--cp-color, #a855f7);
    --sb-tint: rgba(168,85,247,0.18);
    --sb-tint-strong: rgba(168,85,247,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(168,85,247,0.35);
    background: linear-gradient(120deg, var(--sb-tint), rgba(12,12,14,0.92));
    color: #f0fdfa;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-scoreboard-toggle i {
    color: var(--sb-color);
    transition: color .12s ease;
  }
  .btn-scoreboard-toggle:hover {
    border-color: rgba(168,85,247,0.6);
    background: linear-gradient(120deg, var(--sb-tint-strong), rgba(18,19,24,0.95));
    color: #ecfeff;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-scoreboard-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(168,85,247,0.3);
  }
  .btn-scoreboard-toggle.active {
    border-color: rgba(168,85,247,0.75);
    border-width: 3px;
    background: linear-gradient(120deg, rgba(168,85,247,0.28), rgba(50,54,65,0.95));
    color: #ecfeff;
    box-shadow: 0 0 0 2px rgba(34,211,238,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-scoreboard-toggle.active i {
    color: #ecfeff;
  }
  .btn-audio-toggle {
    --audio-color: #38bdf8;
    --audio-tint: rgba(56,189,248,0.18);
    --audio-tint-strong: rgba(56,189,248,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(56,189,248,0.35);
    background: linear-gradient(120deg, var(--audio-tint), rgba(12,12,14,0.92));
    color: #f0fdfa;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-audio-toggle i {
    color: var(--audio-color);
    transition: color .12s ease;
  }
  .btn-audio-toggle:hover {
    border-color: rgba(56,189,248,0.6);
    background: linear-gradient(120deg, var(--audio-tint-strong), rgba(18,19,24,0.95));
    color: #ecfeff;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-audio-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(56,189,248,0.3);
  }
  .btn-audio-toggle.active {
    border-color: rgba(56,189,248,0.75);
    border-width: 3px;
    background: linear-gradient(120deg, rgba(56,189,248,0.28), rgba(50,54,65,0.95));
    color: #ecfeff;
    box-shadow: 0 0 0 2px rgba(56,189,248,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-audio-toggle.active i {
    color: #ecfeff;
  }
  .btn-naval-toggle {
    --naval-color: #f97316;
    --naval-tint: rgba(249,115,22,0.18);
    --naval-tint-strong: rgba(249,115,22,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(249,115,22,0.35);
    background: linear-gradient(120deg, var(--naval-tint), rgba(12,12,14,0.92));
    color: #fff7ed;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-naval-toggle i {
    color: var(--naval-color);
    transition: color .12s ease;
  }
  .btn-naval-toggle:hover {
    border-color: rgba(249,115,22,0.6);
    background: linear-gradient(120deg, var(--naval-tint-strong), rgba(18,19,24,0.95));
    color: #fff7ed;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-naval-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(249,115,22,0.3);
  }
  .btn-naval-toggle.active {
    border-color: rgba(249,115,22,0.75);
    border-width: 3px;
    background: linear-gradient(120deg, rgba(249,115,22,0.28), rgba(50,54,65,0.95));
    color: #fff7ed;
    box-shadow: 0 0 0 2px rgba(249,115,22,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-naval-toggle.active i {
    color: #fff7ed;
  }
  .btn-pulse-toggle {
    --pulse-color: #14b8a6;
    --pulse-tint: rgba(20,184,166,0.18);
    --pulse-tint-strong: rgba(20,184,166,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(20,184,166,0.35);
    background: linear-gradient(120deg, var(--pulse-tint), rgba(12,12,14,0.92));
    color: #ecfdf5;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-pulse-toggle i {
    color: var(--pulse-color);
    transition: color .12s ease;
  }
  .btn-pulse-toggle:hover {
    border-color: rgba(20,184,166,0.6);
    background: linear-gradient(120deg, var(--pulse-tint-strong), rgba(18,19,24,0.95));
    color: #ecfdf5;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-pulse-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(20,184,166,0.3);
  }
  .btn-pulse-toggle.active {
    border-color: rgba(20,184,166,0.75);
    border-width: 3px;
    background: linear-gradient(120deg, rgba(20,184,166,0.28), rgba(50,54,65,0.95));
    color: #ecfdf5;
    box-shadow: 0 0 0 2px rgba(20,184,166,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-pulse-toggle.active i {
    color: #ecfdf5;
  }
  .btn-video-toggle {
    --video-color: #f43f5e;
    --video-tint: rgba(244,63,94,0.18);
    --video-tint-strong: rgba(244,63,94,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(244,63,94,0.35);
    background: linear-gradient(120deg, var(--video-tint), rgba(12,12,14,0.92));
    color: #ffe4e6;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-video-toggle i {
    color: var(--video-color);
    transition: color .12s ease;
  }
  .btn-video-toggle:hover {
    border-color: rgba(244,63,94,0.6);
    background: linear-gradient(120deg, var(--video-tint-strong), rgba(18,19,24,0.95));
    color: #ffe4e6;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-video-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(244,63,94,0.3);
  }
  .btn-video-toggle.active {
    border-color: rgba(244,63,94,0.75);
    border-width: 3px;
    background: linear-gradient(120deg, rgba(244,63,94,0.28), rgba(50,54,65,0.95));
    color: #ffe4e6;
    box-shadow: 0 0 0 2px rgba(244,63,94,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-video-toggle.active i {
    color: #ffe4e6;
  }
  .btn-chart-toggle {
    --chart-color: #4d71ff;
    --chart-tint: rgba(77,113,255,0.18);
    --chart-tint-strong: rgba(77,113,255,0.32);
    min-width: 48px;
    min-height: 48px;
    padding: 10px;
    border-radius: 14px;
    border: 1px solid rgba(77,113,255,0.35);
    background: linear-gradient(120deg, var(--chart-tint), rgba(12,12,14,0.92));
    color: #f0fdfa;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 8px 18px rgba(0,0,0,0.28);
    transition: transform .15s ease, box-shadow .2s ease, border-color .15s ease, background .15s ease, color .12s ease;
  }
  .btn-chart-toggle i {
    color: var(--chart-color);
    transition: color .12s ease;
  }
  .btn-chart-toggle:hover {
    border-color: rgba(77,113,255,0.6);
    background: linear-gradient(120deg, var(--chart-tint-strong), rgba(18,19,24,0.95));
    color: #ecfeff;
    box-shadow: 0 10px 22px rgba(0,0,0,0.32);
    transform: translateY(-1px);
  }
  .btn-chart-toggle:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(77,113,255,0.3);
  }
  .btn-chart-toggle.active {
    border-color: rgba(77,113,255,0.75);
    border-width: 3px;
    background: linear-gradient(120deg, rgba(77,113,255,0.28), rgba(50,54,65,0.95));
    color: #ecfeff;
    box-shadow: 0 0 0 2px rgba(77,113,255,0.28), 0 8px 20px rgba(0,0,0,0.35);
  }
  .btn-chart-toggle.active i {
    color: #ecfeff;
  }
  .control-collapse-btn {
    position: relative;
    width: 38px;
    height: 38px;
    border-radius: 50%;
    border: none;
    background: rgba(17,21,32,0.82);
    color: #f9fafb;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 10px 20px rgba(0,0,0,0.35);
    transition: transform .12s ease, box-shadow .15s ease, background .15s ease, color .12s ease;
    flex-shrink: 0;
  }
  .control-collapse-btn i {
    font-size: 1rem;
  }
  .control-collapse-btn:hover {
    transform: translateY(-1px);
    background: rgba(239,68,68,0.35);
    color: #fff;
    box-shadow: 0 12px 26px rgba(0,0,0,0.45);
  }
  .control-collapse-btn:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.25), 0 0 0 6px rgba(239,68,68,0.25);
  }
  .control-collapse-btn.is-muted {
    background: rgba(234,179,8,0.32);
    color: #fff7ed;
    box-shadow: 0 12px 26px rgba(202,138,4,0.45);
  }
  .control-collapse-btn.is-muted:hover {
    background: rgba(217,119,6,0.48);
    color: #fff;
  }
  .control-status-actions {
    margin-left: auto;
    display: inline-flex;
    align-items: center;
    justify-content: flex-end;
    gap: 10px;
    flex-wrap: wrap;
  }
  .channel-switch {
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.08);
    background: rgba(12,14,22,0.75);
    box-shadow: 0 10px 20px rgba(0,0,0,0.28);
    display: inline-flex;
    align-items: center;
  }
  .channel-switch-label {
    font-size: 0.75rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    color: #9ca3af;
    margin-right: 6px;
  }
  .channel-switch-value {
    min-width: 22px;
    height: 22px;
    border-radius: 999px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 700;
    color: #e0e7ff;
    background: rgba(77,113,255,0.18);
    border: 1px solid rgba(77,113,255,0.45);
    margin-right: 8px;
  }
  .channel-switch .form-check-input {
    width: 52px;
    height: 26px;
    margin: 0;
    border-radius: 999px;
    background-color: rgba(15,18,28,0.9);
    border: 1px solid rgba(77,113,255,0.35);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
    cursor: pointer;
  }
  .channel-switch .form-check-input:hover {
    border-color: rgba(77,113,255,0.6);
  }
  .channel-switch .form-check-input:checked {
    background-color: rgba(77,113,255,0.95);
    border-color: rgba(77,113,255,0.75);
    box-shadow: 0 0 0 2px rgba(255,255,255,0.1), 0 8px 18px rgba(77,113,255,0.25);
  }
  .channel-switch .form-check-input:focus-visible {
    outline: none;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.12), 0 0 0 6px rgba(77,113,255,0.25);
  }
  .level-tooltip .tooltip-inner { font-weight: 700; }
  .glass-background {
    --glass-grad-start: rgba(77,113,255,0.35);
    --glass-grad-end: rgba(9,11,20,0);
    --glass-border: rgba(255,255,255,0.06);
    --glass-glow: rgba(7,10,22,0.5);
    position: relative;
    z-index: 0;
    overflow: hidden;
    backdrop-filter: blur(14px);
    -webkit-backdrop-filter: blur(14px);
    background: rgba(5,7,12,0.45);
    border: 1px solid var(--glass-border);
    border-radius: 16px;
    box-shadow: 0 20px 40px var(--glass-glow);
  }
  .glass-background::before {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: linear-gradient(135deg, var(--glass-grad-start) 0%, rgba(8,10,16,0.15) 35%, var(--glass-grad-end) 80%);
    opacity: 0.95;
    pointer-events: none;
    z-index: -1;
  }
  .control-readouts {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: flex-start;
    justify-content: flex-start;
    margin-bottom: 1rem;
    width: 100%;
  }
  .control-readout {
    min-width: 120px;
    text-align: left;
  }
  .control-readout-label {
    font-size: 0.78rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #9ca3af;
  }
  .control-readout-value {
    font-size: 1.9rem;
    font-weight: 700;
    color: #f9fafb;
    line-height: 1.1;
  }
  @media (max-width: 640px) {
    .control-readouts {
      justify-content: center;
    }
  }
  #remoteControlCard > .control-readouts,
  #remoteControlCard > #controlContent,
  #remoteControlCard > #advancedPanel {
    width: 100%;
  }
  .collapsible-section {
    overflow: hidden;
    transition: max-height .24s ease, opacity .18s ease, transform .24s ease, padding .18s ease, margin .18s ease;
    will-change: max-height, opacity, transform;
  }
  .collapsible-section.is-collapsed {
    max-height: 0 !important;
    opacity: 0;
    transform: translateY(-6px);
    margin-top: 0 !important;
    margin-bottom: 0 !important;
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    pointer-events: none;
    visibility: hidden;
  }
  .advanced-panel {
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255,255,255,0.06);
    border-radius: 14px;
    padding: 12px;
    overflow: hidden;
    transition: max-height .24s ease, opacity .18s ease, transform .24s ease, padding .18s ease;
  }
  .advanced-panel.adv-collapsed {
    max-height: 0;
    opacity: 0;
    transform: translateY(-6px);
    padding-top: 0;
    padding-bottom: 0;
    visibility: hidden;
    pointer-events: none;
  }
  .advanced-panel.adv-open {
    max-height: 2000px;
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
  }
  .advanced-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 5rem;
  }
  .advanced-chart-block {
    margin-top: 16px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.08);
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .advanced-chart-title {
    font-size: 0.95rem;
    font-weight: 600;
    color: #f3f4f6;
  }
  .advanced-panel .event-canvas-slot {
    margin-top: 0;
  }
  .advanced-note {
    font-size: .85rem;
    color: #9ca3af;
  }
  .chart-title {
    font-size: 0.95rem;
    font-weight: 600;
    color: #f3f4f6;
  }
  .chart-note {
    font-size: .85rem;
    color: #9ca3af;
  }
  .advanced-status {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 8px 10px;
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px;
    color: #e5e7eb;
    font-size: 0.9rem;
  }
  .advanced-status .pill {
    padding: 4px 8px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 0.85rem;
  }
  .adv-led {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.35);
    box-shadow: 0 0 12px rgba(0,0,0,0.35);
    flex-shrink: 0;
  }
  .led-off { background: #6b7280; }
  .led-on  { background: #22c55e; box-shadow: 0 0 10px rgba(34,197,94,0.8); }
  .led-gap { background: #ef4444; box-shadow: 0 0 10px rgba(239,68,68,0.8); }
  .pill-idle { background: #1f2937; color: #e5e7eb; }
  .pill-run { background: #2563eb; color: #ffffff; }
  .pill-done { background: #16a34a; color: #ffffff; }
  .number-spinner {
    display: grid;
    grid-template-columns: 54px 1fr 54px;
    align-items: stretch;
    border-radius: 14px;
    overflow: hidden;
    border: 0px solid rgba(255,255,255,0.08);
    background: transparent;
  }
  .number-spinner:focus-within {
    border-color: #4d71ff;
  }
  .number-spinner .spin-btn {
    border: none;
    background: transparent;
    color: #d1d5db;
    font-size: 2.5rem;
    font-weight: 600;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: background 0.12s ease, color 0.12s ease;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .number-spinner .spin-btn:first-child,
  .number-spinner .spin-btn:last-child {
    border: none;
  }
  .number-spinner .spin-btn:hover {
    color: #ffffff;
  }
  .number-spinner .spin-btn:active {
    color: #ffffff;
    transform: translateY(1px);
  }
  .number-spinner input[type="number"] {
    border: none;
    background: transparent;
    color: #e7eaee;
    text-align: center;
    font-weight: 700;
    font-size: 2rem;
    width: 100%;
    padding: 8px 6px;
    box-shadow: none;
  }
  .number-spinner input[type="number"]::-webkit-outer-spin-button,
  .number-spinner input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  .number-spinner input[type="number"] {
    appearance: textfield;
    -moz-appearance: textfield;
  }
  .number-spinner input[type="number"]:focus {
    outline: none;
    box-shadow: none;
  }
</style>
<div id="remoteControlWrapper" class="inline-mode">
  <div id="controlShell">
    <div id="remoteControlCard" class="card p-3 p-lg-4 shadow-lg flex-grow-1 glass-background">
      <div class="control-status-bar mb-3">
        <div class="control-status-groups">
          <div class="d-flex align-items-center flex-wrap gap-2">
          <div id="fg-status-pill" class="status-pill" data-status="off">
            <span class="status-icon"><i class="fa-solid fa-tower-broadcast" aria-hidden="true"></i></span>
            <span class="visually-hidden">Flowgate:</span>
            <span id="fg-conn-state">desconectado</span>
          </div>
          <div class="status-pill" aria-label="Peers conectados" title="Peers conectados">
            <span class="status-icon"><i class="fa-solid fa-user-group"></i></span>
            <span id="fg-peer-count">0</span>
          </div>
          <div class="status-pill host-only" aria-label="Bots conectados" title="Bots conectados">
            <span class="status-icon"><i class="fa-solid fa-robot"></i></span>
            <span id="fg-bot-count">0</span>
          </div>
          <div id="serial-devices-pill" class="status-pill" data-status="off" aria-label="Peers com serial aberta" title="Peers com serial aberta">
            <span class="status-icon"><i class="fa-solid fa-microchip"></i></span>
            <span>Dispositivos:</span>
            <div id="serial-device-list" class="serial-device-list"></div>
            <span id="serial-device-empty" class="serial-device-empty">nenhum</span>
          </div>
          <div id="serial-status-pill" class="status-pill host-only" data-status="off">
            Serial: <span id="serial-conn-state">fechada</span>
          </div>
        </div>
          <div class="control-peer-list">
            <span class="status-label">Usuários</span>
            <div id="fg-peer-list" class="d-flex align-items-center flex-wrap gap-2"></div>
            <span id="fg-peer-empty" class="text-muted small">nenhum peer</span>
          </div>
        </div>
        <div class="control-status-actions">
          <button id="serialModalBtn" class="control-collapse-btn host-only" aria-label="Abrir Serial" title="Abrir Serial" data-bs-toggle="tooltip">
            <i class="fa-solid fa-plug"></i>
          </button>
          <button id="keepawakeModalBtn" class="control-collapse-btn host-only" aria-label="Abrir Keep-awake" title="Abrir Keep-awake" data-bs-toggle="tooltip">
            <i class="fa-solid fa-moon"></i>
          </button>
          <button id="flowgateModalBtn" class="control-collapse-btn" aria-label="Abrir Flowgate" title="Abrir Flowgate" data-bs-toggle="tooltip">
            <i class="fa-solid fa-tower-broadcast"></i>
          </button>
          <button id="interfaceSoundToggle" class="control-collapse-btn" aria-label="Mutar sons" title="Mutar sons" data-bs-toggle="tooltip" aria-pressed="false">
            <i class="fa-solid fa-volume-high"></i>
          </button>
          <button id="toggleControl" class="control-collapse-btn" aria-label="Fixar controle na tela" title="Fixar controle na tela" data-bs-toggle="tooltip">
            <i class="fa-solid fa-thumbtack"></i>
          </button>
        </div>
      </div>
      <div class="control-readouts my-3">
        <div class="control-readout">
          <div class="control-readout-label">Modo</div>
        <div id="modeReadout" class="control-readout-value">Modo Atual</div>
        </div>
        <div class="control-readout">
          <div class="control-readout-label">Intensidade</div>
          <div id="intensityReadout" class="control-readout-value">0%</div>
        </div>
        <div class="control-readout">
          <div class="control-readout-label">Canal</div>
        <div id="channelReadout" class="control-readout-value">Canal 1</div>
        </div>
        <div class="control-readout">
          <div class="control-readout-label">Duracao</div>
          <div id="durationReadout" class="control-readout-value">—</div>
        </div>
        <div class="control-readout">
          <div class="control-readout-label">Pulsos</div>
          <div id="pulsesReadout" class="control-readout-value">—</div>
        </div>
      </div>
      <div id="controlContent" class="control-row mb-3">
    <div class="btn-group mode-toggle" role="group" aria-label="Modo">
      <button class="mode-btn" data-mode="SHOCK" title="Choque" data-bs-toggle="tooltip">
        <span class="mode-icon"><i class="fa-solid fa-bolt-lightning"></i></span>
      </button>
      <button class="mode-btn" data-mode="VIBRATION" title="Vibracao" data-bs-toggle="tooltip">
        <span class="mode-icon"><i class="fa-solid fa-mobile-screen-button"></i></span>
      </button>
      <button class="mode-btn" data-mode="LIGHT" title="Luz (LED)" data-bs-toggle="tooltip">
        <span class="mode-icon"><i class="fa-solid fa-lightbulb"></i></span>
      </button>
      <button class="mode-btn" data-mode="BEEP" title="Som (Beep)" data-bs-toggle="tooltip">
        <span class="mode-icon"><i class="fa-solid fa-volume-high"></i></span>
      </button>
      <button class="mode-btn" data-mode="ROULETTE" title="Roleta" data-bs-toggle="tooltip">
        <span class="mode-icon"><i class="fa-solid fa-dice"></i></span>
      </button>
    </div>

    <div class="module-btn-group">
      <button id="btnScoreboardToggle" class="btn btn-scoreboard-toggle" title="Mostrar placar" data-bs-toggle="tooltip" aria-pressed="false" aria-expanded="false">
        <i class="fa-solid fa-flag-checkered"></i>
      </button>

      <button id="btnAudioToggle" class="btn btn-audio-toggle" title="Mostrar audio" data-bs-toggle="tooltip" aria-pressed="false" aria-expanded="false">
        <i class="fa-solid fa-headphones"></i>
      </button>

      <button id="btnNavalToggle" class="btn btn-naval-toggle" title="Mostrar Batalha Naval" data-bs-toggle="tooltip" aria-pressed="false" aria-expanded="false">
        <i class="fa-solid fa-ship"></i>
      </button>

      <button id="btnPulseToggle" class="btn btn-pulse-toggle" title="Mostrar Sequenciador" data-bs-toggle="tooltip" aria-pressed="false" aria-expanded="false">
        <i class="fa-solid fa-sliders"></i>
      </button>

      <button id="btnVideoToggle" class="btn btn-video-toggle" title="Mostrar Video" data-bs-toggle="tooltip" aria-pressed="false" aria-expanded="false">
        <i class="fa-solid fa-clapperboard"></i>
      </button>
      <button id="btnChartToggle" class="btn btn-chart-toggle" title="Exibir/ocultar gráfico" data-bs-toggle="tooltip" aria-pressed="false" aria-expanded="false">
        <i class="fa-solid fa-chart-line"></i>
      </button>
    </div>

    <div class="control-action-group">
      <div class="channel-switch form-check form-switch m-0">
        <span class="channel-switch-label">Canal</span>
        <span id="channelSwitchValue" class="channel-switch-value">1</span>
        <input class="form-check-input" type="checkbox" id="chanSwitch" aria-label="Canal 1 ou 2" title="Canal 1 ou 2" data-bs-toggle="tooltip"/>
      </div>

      <button id="btnSend" class="btn btn-send" title="Enviar comando" data-bs-toggle="tooltip">
        <i class="fa-solid fa-power-off"></i>
      </button>

      <button id="cpAdd" class="btn btn-save-shortcut" type="button" title="Salvar atalho personalizado" data-bs-toggle="tooltip">
        <i class="fa-solid fa-floppy-disk"></i>
        <span class="d-none d-md-inline">Salvar</span>
      </button>

      <button id="btnAdvancedToggle" class="control-collapse-btn" title="Opcoes avancadas" data-bs-toggle="tooltip" aria-expanded="false">
        <i class="fa-solid fa-chevron-down"></i>
      </button>
    </div>

  </div>

  <div class="control-slider-row collapsible-section mt-2 mb-3" id="sliderRow" aria-hidden="false">
    <div id="levelRow" class="d-flex align-items-center gap-2 level-wrap">
      <input type="range" class="form-range level-slider" min="0" max="100" step="1" id="levelSlider" data-bs-toggle="tooltip" data-bs-placement="top"/>
      <input id="levelValue" class="form-control form-control-sm level-input" type="text" inputmode="numeric" pattern="[0-9]*" title="Nivel (0 a 100)" data-bs-toggle="tooltip" value="0%"/>
    </div>
  </div>
  <div id="advancedPanel" class="advanced-panel adv-collapsed">
    <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap mb-2">
      <div class="fw-semibold text-light">Opcoes avancadas</div>
      <div class="d-flex align-items-center gap-2 flex-wrap">
        <div class="advanced-note">Opcoes extras de controle</div>
        <button id="advResetBtn" class="btn btn-sm btn-outline-light py-1 px-2" type="button" title="Restaurar valores padrao" data-bs-toggle="tooltip">
          Reset
        </button>
      </div>
    </div>
    <div class="advanced-status">
      <div id="advLed" class="adv-led led-off" title="Estado do pulso"></div>
      <div id="advStatusPill" class="pill pill-idle">Pronto</div>
      <div class="flex-grow-1 text-end small" id="advCountdownText">-</div>
      <button id="advStopBtn" class="btn btn-danger btn-sm ms-2 d-none" type="button" title="Parar agora">
        <i class="fa-solid fa-stop"></i>
      </button>
    </div>
      <div class="advanced-grid my-3">
        <div>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir numero de pulsos">-</button>
            <input id="advPulses" class="form-control form-control-sm" type="number" min="1" step="1" value="1" title="Quantidade de pulsos automaticos ao clicar" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar numero de pulsos">+</button>
          </div>
          <label for="advPulses" class="form-label small text-secondary mt-1 text-center d-block">Numero de pulsos</label>
        </div>
        <div>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir duracao">-</button>
            <input id="advDuration" class="form-control form-control-sm" type="number" min="0.05" step="0.5" value="0.18" title="Duracao de cada pulso (segundos)" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar duracao">+</button>
          </div>
          <label for="advDuration" class="form-label small text-secondary mt-1 text-center d-block">Duracao (s)</label>
        </div>
        <div>
          <div class="number-spinner">
            <button class="spin-btn" type="button" data-spin="dec" aria-label="Diminuir intervalo entre pulsos">-</button>
            <input id="advDelay" class="form-control form-control-sm" type="number" min="0" step="0.5" value="1.00" title="Intervalo entre pulsos automaticos (segundos)" data-bs-toggle="tooltip"/>
            <button class="spin-btn" type="button" data-spin="inc" aria-label="Aumentar intervalo entre pulsos">+</button>
          </div>
          <label for="advDelay" class="form-label small text-secondary mt-1 text-center d-block">Intervalo entre pulsos (s)</label>
        </div>
      </div>
        <!-- Chart block removido do painel avançado -->
  </div>
  <div id="rouletteRow" class="collapsible-section is-collapsed mt-3 mb-3" aria-hidden="true">
    <div id="rouletteMount" class="w-100"></div>
  </div>
    <div class="control-scoreboard-block collapsed mb-3" aria-hidden="true">
      <div id="controlScoreboardMount" class="control-scoreboard-mount">
        <div class="scoreboard-embed-state scoreboard-loading-state">Carregando placar...</div>
      </div>
    </div>
    <div class="control-audio-block collapsed mb-3" aria-hidden="true">
      <div id="controlAudioMount" class="control-audio-mount">
        <div class="audio-embed-state audio-loading-state">Carregando audio...</div>
      </div>
    </div>
    <div class="naval-module-slot collapsed mb-3" aria-hidden="true">
      <div id="navalModuleMount">
        <div class="naval-embed-state naval-loading-state">Carregando Batalha Naval...</div>
      </div>
    </div>
    <div class="pulse-sequencer-slot collapsed mb-3" aria-hidden="true">
      <div id="pulseSequencerMount">
        <div class="pulse-embed-state pulse-loading-state">Carregando Sequenciador de Pulsos...</div>
      </div>
    </div>
    <div class="video-player-slot collapsed mb-3" aria-hidden="true">
      <div id="videoPlayerMount">
        <div class="video-embed-state video-loading-state">Carregando Video...</div>
      </div>
    </div>

    <div id="chartBlock" class="chart-block collapsed mb-3" aria-hidden="true">
      <div class="event-canvas-slot">
        <div class="event-canvas-card">
          <div id="collarEventChartHolder" class="chart-embed-placeholder">Carregando grafico…</div>
        </div>
      </div>
    </div>
  <div class="custom-buttons-slot mb-3">
    <div id="customButtonsMount"></div>
  </div>
</div>
</div>
</div>

<div class="modal fade" id="flowgate-module-modal" tabindex="-1" aria-labelledby="flowgate-module-modal-label" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-scrollable">
    <div class="modal-content" style="background:#111;border:1px solid #333;color:#e5e7eb;">
      <div class="modal-header" style="border-bottom:1px solid #2a2a2a;">
        <h5 class="modal-title" id="flowgate-module-modal-label">
          <i class="fa-solid fa-gear me-2"></i>Flowgate
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fechar"></button>
      </div>
      <div class="modal-body">
        <div id="flowgate-module-modal-body"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Bus cross-document =====
  if (!window.__FS_BUS__) {
    (function(){
      const CHANNEL = 'fs-score-channel';
      let bc = null;
      try { bc = new BroadcastChannel(CHANNEL); } catch(e){ bc = null; }
      function _onMessage(msg){
        try {
          const data = (typeof msg === 'string') ? JSON.parse(msg) : msg;
          window.dispatchEvent(new CustomEvent('fs-score:global', { detail: data }));
        } catch(_){ }
      }
      if (bc) bc.onmessage = (ev)=> _onMessage(ev.data);
      window.addEventListener('message', (ev)=>{ if (ev.data && ev.data.__fs_score_msg) _onMessage(ev.data.payload); });
      window.addEventListener('storage', (ev)=>{ if (ev.key === CHANNEL && ev.newValue) _onMessage(JSON.parse(ev.newValue)); });
      window.__FS_BUS__ = {
        send(payload){
          const data = payload || {};
          if (bc) try { bc.postMessage(data); } catch(_){}
          try { if (window.parent && window.parent !== window) window.parent.postMessage({ __fs_score_msg: true, payload: data }, '*'); } catch(_){}
          try { (document.querySelectorAll('iframe')||[]).forEach(f=>{ try{ f.contentWindow.postMessage({ __fs_score_msg: true, payload: data }, '*'); }catch(_){} }); } catch(_){}
          try { localStorage.setItem(CHANNEL, JSON.stringify(data)); localStorage.removeItem(CHANNEL); } catch(_){}
          try { _onMessage(data); } catch(_){}
        },
        on(cb){ if (typeof cb !== 'function') return; window.addEventListener('fs-score:global', (ev)=> cb(ev.detail)); }
      };
    })();
  }

  // ===== Estado =====
  let currentMode = "SHOCK";
  let level = 0;
  let channel = 1;
  const STORAGE_KEY = "remote_control_state_v1";
  const MODES = ["SHOCK", "VIBRATION", "LIGHT", "BEEP", "ROULETTE"];
  const MODE_LABELS = {
    SHOCK: "Choque",
    VIBRATION: "Vibra",
    LIGHT: "Luz",
    BEEP: "Beep",
    ROULETTE: "Roleta"
  };
  const MODE_GLASS_THEMES = {
    SHOCK: { start: "rgba(249,115,22,0.55)", end: "rgba(249,115,22,0)", border: "rgba(249,115,22,0.45)", glow: "rgba(249,115,22,0.25)" },
    VIBRATION: { start: "rgba(16,185,129,0.45)", end: "rgba(16,185,129,0)", border: "rgba(16,185,129,0.32)", glow: "rgba(16,185,129,0.2)" },
    LIGHT: { start: "rgba(250,204,21,0.45)", end: "rgba(250,204,21,0)", border: "rgba(250,204,21,0.38)", glow: "rgba(250,204,21,0.2)" },
    BEEP: { start: "rgba(96,165,250,0.45)", end: "rgba(96,165,250,0)", border: "rgba(96,165,250,0.32)", glow: "rgba(96,165,250,0.25)" },
    ROULETTE: { start: "rgba(244,114,182,0.5)", end: "rgba(244,114,182,0)", border: "rgba(244,114,182,0.35)", glow: "rgba(244,114,182,0.28)" },
    DEFAULT: { start: "rgba(77,113,255,0.35)", end: "rgba(77,113,255,0)", border: "rgba(255,255,255,0.08)", glow: "rgba(7,10,22,0.5)" }
  };
  const MODE_LEVEL_COLORS = {
    SHOCK: "#f97316",
    VIBRATION: "#10b981"
  };
  const modeSupportsLevel = (mode)=> mode === "SHOCK" || mode === "VIBRATION";
  let levelTooltip = null;
  let levelTooltipAnchor = null;
  let levelTooltipVisible = false;
  const LEVEL_PATCH_REASON = "remote-level";
  const CONTROL_ORIGIN_KEY = "remote_control_origin_v1";
  const CONTROL_ORIGIN = (() => {
    try {
      let id = sessionStorage.getItem(CONTROL_ORIGIN_KEY);
      if (!id) {
        id = `rc-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
        sessionStorage.setItem(CONTROL_ORIGIN_KEY, id);
      }
      return id;
    } catch (_) {
      return `rc-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
    }
  })();
  const lastControlTs = new Map(); // origin -> ts
  let levelDebounce = null;
  const ADV_DEFAULTS = { pulses: 1, durationMs: 180, delayMs: 1000, preDelayMs: 0 };
  const ADV_LIMITS = {
    pulses: { min: 1, max: Infinity },
    durationMs: { min: 50, max: Infinity },
    delayMs: { min: 0, max: Infinity },
    preDelayMs: { min: 0, max: Infinity }
  };
  let advanced = { ...ADV_DEFAULTS };
  let advancedOpen = false;
  let scoreboardOpen = false;
  let audioOpen = false;
  let navalOpen = false;
  let pulseOpen = false;
  let videoOpen = false;
  let lastScoreboardArmedState = null;
  const ROULETTE_DEFAULT_HOLD_MS = 220;
  const ROULETTE_HOLD_LIMITS = { min: 200, max: 20000 };
  let roulettePointerActive = false;
  let rouletteAutoReleaseTimer = null;
  const ROULETTE_RESULT_TIMEOUT_MS = 20000;

  const HOLD_THRESHOLD_MS = 220; // abaixo disso: clique unico; acima: HOLD
  const GLOBAL_HARD_LIMIT = 15;  // failsafe geral (mantido)

  window.currentMode = currentMode;
  window.level = level;
  window.channel = channel;
  window.__ADVANCED_PANEL_OPEN__ = advancedOpen;

  const $  = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const advancedPanelEl = $("#advancedPanel");
  const advancedToggleBtn = $("#btnAdvancedToggle");
  const advancedInputs = {
    pulses: $("#advPulses"),
    duration: $("#advDuration"),
    delay: $("#advDelay"),
    preDelay: $("#advPreDelay")
  };
  const advLed = $("#advLed");
  const advStatusPill = $("#advStatusPill");
  const advCountdownText = $("#advCountdownText");
  const advStopBtn = $("#advStopBtn");
  const btnSend = $("#btnSend");
  const remoteControlCard = $("#remoteControlCard");
  const modeReadoutEl = $("#modeReadout");
  const intensityReadoutEl = $("#intensityReadout");
  const channelReadoutEl = $("#channelReadout");
  const durationReadoutEl = $("#durationReadout");
  const pulsesReadoutEl = $("#pulsesReadout");
  const sliderRowEl = $("#sliderRow");
  const rouletteRowEl = $("#rouletteRow");
  const scoreboardBlockEl = $(".control-scoreboard-block");
  const scoreboardToggleBtn = $("#btnScoreboardToggle");
  const audioBlockEl = $(".control-audio-block");
  const audioToggleBtn = $("#btnAudioToggle");
  const navalBlockEl = $(".naval-module-slot");
  const navalToggleBtn = $("#btnNavalToggle");
  const pulseBlockEl = $(".pulse-sequencer-slot");
  const pulseToggleBtn = $("#btnPulseToggle");
  const videoBlockEl = $(".video-player-slot");
  const videoToggleBtn = $("#btnVideoToggle");
  let advCountdownTimer = null;
  let advCountdownEndAt = 0;
  let advStopSignal = { stop: false, holdActive: false };
  const chartBlockEl = document.getElementById("chartBlock");
  const chartToggleBtn = document.getElementById("btnChartToggle");

  function log(msg, lvl="info"){
    try { window.appLog ? window.appLog(msg, lvl) : console.log(msg); } catch {}
  }

  const clampNum = (v, min, max) => {
    const n = Number(v) || 0;
    const upper = Number.isFinite(max) ? max : n;
    return Math.max(min, Math.min(upper, n));
  };
  const msToSecStr = (ms, key="durationMs") => {
    const lim = ADV_LIMITS[key] || ADV_LIMITS.durationMs;
    const upper = Number.isFinite(lim.max) ? lim.max : Number(ms)||0;
    const seconds = clampNum(Number(ms)||0, lim.min, upper) / 1000;
    const fixed = seconds.toFixed(2);
    return fixed.replace(/\.00$/, "").replace(/(\.\d)0$/, "$1");
  };
  const secToMs = (s, key="durationMs") => {
    const lim = ADV_LIMITS[key] || ADV_LIMITS.durationMs;
    const upper = Number.isFinite(lim.max) ? lim.max/1000 : Number(s)||0;
    return Math.round(clampNum(Number(s)||0, lim.min/1000, upper) * 1000);
  };
  const fmtRemain = (ms)=> `${(Math.max(0, ms)/1000).toFixed(ms > 10000 ? 1 : 2)}s`;
  function calcBurstTotalMs(plan){
    const pulses = Math.max(1, Math.round(plan?.pulses || 1));
    const dur = Math.max(0, Math.round(plan?.durationMs || ADV_DEFAULTS.durationMs));
    const gap = Math.max(0, Math.round(plan?.delayMs || ADV_DEFAULTS.delayMs));
    const pre = Math.max(0, Math.round(plan?.preDelayMs || 0));
    // total = pre-delay + (dur+gap) for each pulse, gap skipped after last
    return pre + (pulses * dur) + (Math.max(0, pulses - 1) * gap);
  }

  // ===== Username (mesmo padrao do widget Flowgate) =====
  function getUsername(){
    try {
      const u = new URL(location.href);
      const fromUrl = (u.searchParams.get('name') || '').trim();
      if (fromUrl) return fromUrl;
    } catch {}

    // state do widget de conexao
    try {
      const st = JSON.parse(localStorage.getItem('flowgate_widget_state_v2') || localStorage.getItem('trystero_widget_state_v2') || '{}') || {};
      const name = (st.name || '').trim();
      if (name) return name;
    } catch {}

    return 'eu';
  }

  // ===== Persistencia =====
  function loadState(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object") return null;
      parsed.advanced = { ...ADV_DEFAULTS, ...(parsed.advanced || {}) };
      parsed.advancedOpen = !!parsed.advancedOpen;
      parsed.scoreboardOpen = !!parsed.scoreboardOpen;
      parsed.audioOpen = !!parsed.audioOpen;
      parsed.navalOpen = !!parsed.navalOpen;
      parsed.pulseOpen = !!parsed.pulseOpen;
      parsed.videoOpen = !!parsed.videoOpen;
      parsed.chartOpen = !!parsed.chartOpen;
      return parsed;
    } catch(e){
      log(`Falha ao carregar estado: ${e && e.message || e}`, "warn");
      return null;
    }
  }
  function normalizeAdvancedState(next){
    const target = next || advanced || { ...ADV_DEFAULTS };
    target.pulses = clampNum(Math.round(target.pulses || ADV_DEFAULTS.pulses), ADV_LIMITS.pulses.min, ADV_LIMITS.pulses.max);
    target.durationMs = clampNum(Math.round(target.durationMs || ADV_DEFAULTS.durationMs), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
    target.delayMs = clampNum(Math.round(target.delayMs || ADV_DEFAULTS.delayMs), ADV_LIMITS.delayMs.min, ADV_LIMITS.delayMs.max);
    target.preDelayMs = clampNum(Math.round(target.preDelayMs || ADV_DEFAULTS.preDelayMs), ADV_LIMITS.preDelayMs.min, ADV_LIMITS.preDelayMs.max);
    return target;
  }
  function persistState(){
    try {
      advanced = normalizeAdvancedState(advanced);
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        mode: currentMode,
        level,
        channel,
        advanced,
        advancedOpen,
        scoreboardOpen,
        audioOpen,
        navalOpen,
        pulseOpen,
        videoOpen,
        chartOpen
      }));
    } catch(e){
      log(`Falha ao salvar estado: ${e && e.message || e}`, "warn");
    }
  }

      function initEventChartEmbed(){
        const holder = document.getElementById("collarEventChartHolder");
        if (!holder) return;
        const tryAttach = () => {
          const chartCard = document.getElementById("collarEventChartCard");
          if (!chartCard || holder.contains(chartCard)) return !!chartCard;
          holder.innerHTML = "";
          holder.classList.remove("chart-embed-placeholder");
          chartCard.classList.add("embedded-event-chart");
          chartCard.classList.remove("chart-hidden");
          chartCard.style.display = "";
          holder.appendChild(chartCard);
          setTimeout(() => {
            try { window.dispatchEvent(new Event("resize")); } catch(_) {}
          }, 0);
          return true;
        };
        if (tryAttach()) return;
        let attempts = 0;
        const timer = setInterval(() => {
          attempts += 1;
          if (tryAttach() || attempts >= 40) {
            if (attempts >= 40) {
              const chartCard = document.getElementById("collarEventChartCard");
              if (chartCard) {
                chartCard.classList.remove("chart-hidden");
                chartCard.style.display = "";
                setTimeout(() => {
                  try { window.dispatchEvent(new Event("resize")); } catch(_) {}
                }, 0);
              }
            }
            clearInterval(timer);
          }
        }, 400);
      }
      initEventChartEmbed();

  const SCOREBOARD_SRC = "Widgets/fscore.html";
  const AUDIO_LISTENER_SRC = "Widgets/audiolistener.html";
  const NAVAL_WIDGET_SRC = "Widgets/Games/naval.html";
  const PULSE_SEQUENCER_SRC = "Widgets/sequence.html";
  const VIDEO_PLAYER_SRC = "Widgets/Video_player.html";
  const ROULETTE_WIDGET_SRC = "Widgets/Roleta.html";
  function runInlineScriptsIn(container){
    if (!container) return;
    const scripts = Array.from(container.querySelectorAll('script'));
    scripts.forEach((oldScript) => {
      const newScript = document.createElement('script');
      Array.from(oldScript.attributes).forEach((attr) => newScript.setAttribute(attr.name, attr.value));
      if (oldScript.textContent) newScript.textContent = oldScript.textContent;
      oldScript.parentNode?.replaceChild(newScript, oldScript);
    });
  }
  function loadControlScoreboard(){
    const mount = document.getElementById('controlScoreboardMount');
    if (!mount) return;
    mount.innerHTML = '<div class="scoreboard-embed-state scoreboard-loading-state">Carregando placar...</div>';
    fetch(SCOREBOARD_SRC)
      .then((res) => {
        if (!res.ok) throw new Error('Falha ao carregar Widgets/fscore.html: ' + res.status);
        return res.text();
      })
      .then((html) => {
        mount.innerHTML = html;
        runInlineScriptsIn(mount);
      })
      .catch((err) => {
        try { console.error(err); } catch(_){ }
        mount.innerHTML = '<div class="scoreboard-embed-state scoreboard-error-state">Nao foi possivel carregar o placar.</div>';
      });
  }
  loadControlScoreboard();

  function loadControlAudio(){
    const mount = document.getElementById('controlAudioMount');
    if (!mount) return;
    mount.innerHTML = '<div class="audio-embed-state audio-loading-state">Carregando audio...</div>';
    fetch(AUDIO_LISTENER_SRC)
      .then((res) => {
        if (!res.ok) throw new Error('Falha ao carregar Widgets/audiolistener.html: ' + res.status);
        return res.text();
      })
      .then((html) => {
        mount.innerHTML = html;
        runInlineScriptsIn(mount);
      })
      .catch((err) => {
        try { console.error(err); } catch(_){ }
        mount.innerHTML = '<div class="audio-embed-state audio-error-state">Nao foi possivel carregar o audio.</div>';
      });
  }
  loadControlAudio();

  function loadControlNaval(){
    const mount = document.getElementById('navalModuleMount');
    if (!mount) return;
    mount.innerHTML = '<div class="naval-embed-state naval-loading-state">Carregando Batalha Naval...</div>';
    fetch(NAVAL_WIDGET_SRC)
      .then((res) => {
        if (!res.ok) throw new Error('Falha ao carregar Widgets/Games/naval.html: ' + res.status);
        return res.text();
      })
      .then((html) => {
        mount.innerHTML = html;
        runInlineScriptsIn(mount);
      })
      .catch((err) => {
        try { console.error(err); } catch(_){ }
        mount.innerHTML = '<div class="naval-embed-state naval-error-state">Nao foi possivel carregar Batalha Naval.</div>';
      });
  }
  loadControlNaval();

  function loadPulseSequencer(){
    const mount = document.getElementById('pulseSequencerMount');
    if (!mount) return;
    mount.innerHTML = '<div class="pulse-embed-state pulse-loading-state">Carregando Sequenciador de Pulsos...</div>';
    fetch(PULSE_SEQUENCER_SRC)
      .then((res) => {
        if (!res.ok) throw new Error('Falha ao carregar Widgets/sequence.html: ' + res.status);
        return res.text();
      })
      .then((html) => {
        mount.innerHTML = html;
        runInlineScriptsIn(mount);
      })
      .catch((err) => {
        try { console.error(err); } catch(_){ }
        mount.innerHTML = '<div class="pulse-embed-state pulse-error-state">Nao foi possivel carregar o Sequenciador de Pulsos.</div>';
      });
  }
  loadPulseSequencer();

  function loadControlVideo(){
    const mount = document.getElementById('videoPlayerMount');
    if (!mount) return;
    mount.innerHTML = '<div class="video-embed-state video-loading-state">Carregando Video...</div>';
    fetch(VIDEO_PLAYER_SRC)
      .then((res) => {
        if (!res.ok) throw new Error('Falha ao carregar Widgets/Video_player.html: ' + res.status);
        return res.text();
      })
      .then((html) => {
        mount.innerHTML = html;
        runInlineScriptsIn(mount);
      })
      .catch((err) => {
        try { console.error(err); } catch(_){ }
        mount.innerHTML = '<div class="video-embed-state video-error-state">Nao foi possivel carregar o Video.</div>';
      });
  }
  loadControlVideo();

  function loadRouletteWidget(){
    const mount = document.getElementById('rouletteMount');
    if (!mount) return;
    mount.innerHTML = '<div class="roulette-embed-state roulette-loading-state">Carregando Roletas...</div>';
    fetch(ROULETTE_WIDGET_SRC)
      .then((res) => {
        if (!res.ok) throw new Error('Falha ao carregar Widgets/Roleta.html: ' + res.status);
        return res.text();
      })
      .then((html) => {
        mount.innerHTML = html;
        runInlineScriptsIn(mount);
      })
      .catch((err) => {
        try { console.error(err); } catch(_){ }
        mount.innerHTML = '<div class="roulette-embed-state roulette-error-state">Nao foi possivel carregar as Roletas.</div>';
      });
  }
  loadRouletteWidget();

  let sendControlToRoom = null;
  let sendChartToRoom = null;
  let boundControlRoom = null;

  function buildControlSnapshot(reason){
    return {
      mode: currentMode,
      level,
      channel,
      advancedOpen,
      scoreboardOpen,
      audioOpen,
      navalOpen,
      pulseOpen,
      videoOpen,
      chartOpen,
      pulses: advanced.pulses,
      gapMs: advanced.delayMs,
      baseMs: advanced.durationMs,
      preDelayMs: advanced.preDelayMs,
      reason: reason || "snapshot"
    };
  }

  function sendControlPayload(payload, opts = {}){
    const toBus = opts.toBus !== false;
    const toRoom = opts.toRoom !== false;
    if (toBus && window.__FS_BUS__ && typeof window.__FS_BUS__.send === "function") {
      try { window.__FS_BUS__.send({ type: "fs-control", payload }); } catch(_){}
    }
    if (toRoom && typeof sendControlToRoom === "function") {
      try { sendControlToRoom(payload); } catch(_){}
    }
  }

  function sendChartPayload(payload, opts = {}){
    const toBus = opts.toBus !== false;
    const toRoom = opts.toRoom !== false;
    if (toBus && window.__FS_BUS__ && typeof window.__FS_BUS__.send === "function") {
      try { window.__FS_BUS__.send({ type: "fs-chart", payload }); } catch(_){}
    }
    if (toRoom && typeof sendChartToRoom === "function") {
      try { sendChartToRoom(payload); } catch(_){}
    }
  }

  function emitControlPatch(patch, opts = {}){
    if (!patch || typeof patch !== "object") return;
    const ts = Number.isFinite(opts.ts) ? opts.ts : Date.now();
    const payload = { ...patch, origin: CONTROL_ORIGIN, ts };
    sendControlPayload(payload, opts);
  }

  function sendCommand(text){
    const payload = String(text || '').trim();
    if (!payload) return;

    const serialReady = !!(window.port && window.port.writable);
    if (serialReady && window.SerialBridge && typeof window.SerialBridge.send === 'function') {
      try { window.SerialBridge.send(payload); return; } catch(e){ log(`Falha SerialBridge: ${e && e.message || e}`, "warn"); }
    }

    const room = (window.Flowgate && window.Flowgate.room) ? window.Flowgate.room : window.__TRYSTERO_ROOM__;
    if (room && typeof room.makeAction === 'function') {
      const pair = room.makeAction('cmd');
      const sendCmd = Array.isArray(pair) ? pair[0] : null;
      if (typeof sendCmd === 'function') {
        try {
          const msg = {
            text: payload.slice(0, 400),
            name: getUsername(),
            timestamp: Date.now(),
            id: `cmd:${Date.now()}:${Math.random().toString(36).slice(2)}`
          };
          sendCmd(msg);
          return;
        } catch(e) {
          log(`Falha Flowgate (room cmd): ${e && e.message || e}`, "warn");
        }
      }
    }

    const cmdBus = (window.__TRYSTERO_CMD__ && typeof window.__TRYSTERO_CMD__.send === 'function') ? window.__TRYSTERO_CMD__ : null;
    if (cmdBus && (!cmdBus.isReady || cmdBus.isReady())) {
      const ok = cmdBus.send(payload.slice(0, 400), { via: 'maincontrol' });
      if (!ok) log('Falha Flowgate (cmd): comando nao enviado.', "warn");
      return;
    }

    const chatBus = (window.__TRYSTERO_CHAT__ && typeof window.__TRYSTERO_CHAT__.send === 'function') ? window.__TRYSTERO_CHAT__ : null;
    if (chatBus && (!chatBus.isReady || chatBus.isReady())) {
      try {
        const maybe = chatBus.send(payload.slice(0, 400), { via: 'maincontrol' });
        if (maybe && typeof maybe.catch === 'function') {
          maybe.catch((err) => log(`Falha Flowgate (chat): ${err && err.message || err}`, "warn"));
        }
        return;
      } catch(e) {
        log(`Falha Flowgate (chat): ${e && e.message || e}`, "warn");
        return;
      }
    }

    log('Flowgate/SerialBridge indisponivel: comando nao enviado.', "warn");
  }

  // ===== Helpers UI =====
  function initTooltips(){
    if (!(window.bootstrap && window.bootstrap.Tooltip)) return;
    $$('#remoteControlCard [data-bs-toggle="tooltip"]').forEach(el => {
      if (el.id === "levelSlider") return;
      new window.bootstrap.Tooltip(el);
    });
  }

  // Removido: funções ensureAnchor e ensureSliderTooltip (tooltip do slider de nível)

  function updateSliderTooltip(n){
    // Tooltip removido: não faz mais nada
  }

  function syncLevelInputWidth(){
    const el = $("#levelValue");
    if (!el) return;
    const len = Math.max(1, (el.value || "").length);
    el.style.width = `${len + 0.5}ch`;
  }

  function showSliderTooltip(){
    // Tooltip removido: não faz mais nada
  }

  function hideSliderTooltip(){
    // Tooltip removido: não faz mais nada
  }

  function updateLevelUi(n){
    const slider = $("#levelSlider");
    const levelInput = $("#levelValue");
    if (slider) {
      const color = MODE_LEVEL_COLORS[currentMode] || "#10b981";
      slider.style.setProperty('--lvl', `${n}%`);
      slider.style.setProperty('--lvlColor', color);
      slider.style.setProperty('--thumb', color);
      slider.style.background = `linear-gradient(90deg, ${color} 0%, ${color} ${n}%, #2c3040 ${n}%, #2c3040 100%)`;
    }
    if (levelInput) {
      levelInput.value = `${n}%`;
      syncLevelInputWidth();
    }
    syncIntensityReadout();
    updateSliderTooltip(n);
  }

  function broadcastBasics(reason){
    emitControlPatch({
      mode: currentMode,
      level,
      channel,
      pulses: advanced.pulses,
      gapMs: advanced.delayMs,
      baseMs: advanced.durationMs,
      preDelayMs: advanced.preDelayMs,
      reason: reason || "remote-basic"
    });
  }

  const formatModeLabel = (mode)=> MODE_LABELS[mode] || mode;
  function syncModeReadout(){
    if (modeReadoutEl) modeReadoutEl.textContent = formatModeLabel(currentMode);
  }
  function syncIntensityReadout(){
    if (!intensityReadoutEl) return;
    intensityReadoutEl.textContent = modeSupportsLevel(currentMode) ? `${level}%` : "—";
  }
  function syncChannelReadout(){
    if (channelReadoutEl) channelReadoutEl.textContent = `${channel}`;
  }
  function syncAdvancedReadouts(){
    const durationText = advancedOpen ? `${msToSecStr(advanced.durationMs, "durationMs")}s` : "—";
    const pulsesText = advancedOpen ? `${advanced.pulses}` : "—";
    if (durationReadoutEl) durationReadoutEl.textContent = durationText;
    if (pulsesReadoutEl) pulsesReadoutEl.textContent = pulsesText;
  }

  function applyModeTheme(mode){
    if (!remoteControlCard) return;
    const theme = MODE_GLASS_THEMES[mode] || MODE_GLASS_THEMES.DEFAULT;
    remoteControlCard.style.setProperty("--glass-grad-start", theme.start);
    remoteControlCard.style.setProperty("--glass-grad-end", theme.end);
    remoteControlCard.style.setProperty("--glass-border", theme.border);
    remoteControlCard.style.setProperty("--glass-glow", theme.glow);
  }

  function syncModeUi(){
    $$(".mode-btn").forEach(b => b.classList.toggle("active", b.dataset.mode === currentMode));
    applyModeTheme(currentMode);
  }

  function syncAdvancedUi(){
    advanced = normalizeAdvancedState(advanced);
    if (advancedInputs.pulses) advancedInputs.pulses.value = advanced.pulses;
    if (advancedInputs.duration) advancedInputs.duration.value = msToSecStr(advanced.durationMs, "durationMs");
    if (advancedInputs.delay) advancedInputs.delay.value = msToSecStr(advanced.delayMs, "delayMs");
    if (advancedInputs.preDelay) advancedInputs.preDelay.value = msToSecStr(advanced.preDelayMs, "preDelayMs");
  }

  function updateScoreboardToggleTooltip(label){
    if (!scoreboardToggleBtn) return;
    scoreboardToggleBtn.setAttribute("title", label);
    scoreboardToggleBtn.setAttribute("aria-label", label);
    scoreboardToggleBtn.setAttribute("data-bs-original-title", label);
    const tipInstance = (window.bootstrap && window.bootstrap.Tooltip)
      ? window.bootstrap.Tooltip.getInstance(scoreboardToggleBtn)
      : null;
    if (tipInstance) {
      if (typeof tipInstance.setContent === "function") {
        tipInstance.setContent({ ".tooltip-inner": label });
      } else if (tipInstance.tip) {
        const inner = tipInstance.tip.querySelector(".tooltip-inner");
        if (inner) inner.textContent = label;
      }
    }
  }

  function syncScoreboardArmedState(visible, opts){
    const armed = !!visible;
    if (!opts?.force && lastScoreboardArmedState === armed) return;
    lastScoreboardArmedState = armed;
    emitControlPatch({
      armed,
      reason: armed ? "scoreboard-visible" : "scoreboard-hidden"
    });
  }

  function setScoreboardOpen(next, opts){
    const desired = !!next;
    if (!opts?.force && scoreboardOpen === desired) {
      if (opts?.persist === false) return;
    }
    scoreboardOpen = desired;
    if (scoreboardBlockEl) {
      scoreboardBlockEl.classList.toggle("collapsed", !scoreboardOpen);
      scoreboardBlockEl.setAttribute("aria-hidden", scoreboardOpen ? "false" : "true");
    }
    if (scoreboardToggleBtn) {
      scoreboardToggleBtn.classList.toggle("active", scoreboardOpen);
      scoreboardToggleBtn.setAttribute("aria-pressed", scoreboardOpen ? "true" : "false");
      scoreboardToggleBtn.setAttribute("aria-expanded", scoreboardOpen ? "true" : "false");
      const icon = scoreboardToggleBtn.querySelector("i");
      if (icon) icon.className = scoreboardOpen ? "fa-solid fa-trophy" : "fa-solid fa-flag-checkered";
      updateScoreboardToggleTooltip(scoreboardOpen ? "Ocultar placar" : "Mostrar placar");
    }
    if (opts?.persist !== false) persistState();
    if (opts?.signalArmed !== false) {
      syncScoreboardArmedState(scoreboardOpen, { force: opts?.force });
    }
  }

  function updateAudioToggleTooltip(label){
    if (!audioToggleBtn) return;
    audioToggleBtn.setAttribute("title", label);
    audioToggleBtn.setAttribute("aria-label", label);
    audioToggleBtn.setAttribute("data-bs-original-title", label);
    const tipInstance = (window.bootstrap && window.bootstrap.Tooltip)
      ? window.bootstrap.Tooltip.getInstance(audioToggleBtn)
      : null;
    if (tipInstance) {
      if (typeof tipInstance.setContent === "function") {
        tipInstance.setContent({ ".tooltip-inner": label });
      } else if (tipInstance.tip) {
        const inner = tipInstance.tip.querySelector(".tooltip-inner");
        if (inner) inner.textContent = label;
      }
    }
  }

  function setAudioOpen(next, opts){
    const desired = !!next;
    if (!opts?.force && audioOpen === desired) {
      if (opts?.persist === false) return;
    }
    audioOpen = desired;
    if (audioBlockEl) {
      audioBlockEl.classList.toggle("collapsed", !audioOpen);
      audioBlockEl.setAttribute("aria-hidden", audioOpen ? "false" : "true");
    }
    if (audioToggleBtn) {
      audioToggleBtn.classList.toggle("active", audioOpen);
      audioToggleBtn.setAttribute("aria-pressed", audioOpen ? "true" : "false");
      audioToggleBtn.setAttribute("aria-expanded", audioOpen ? "true" : "false");
      const icon = audioToggleBtn.querySelector("i");
      if (icon) icon.className = audioOpen ? "fa-solid fa-wave-square" : "fa-solid fa-headphones";
      updateAudioToggleTooltip(audioOpen ? "Ocultar audio" : "Mostrar audio");
    }
    if (!audioOpen && typeof window.__audioCollarStopAllSources === "function") {
      try { window.__audioCollarStopAllSources(); } catch(_){}
    }
    if (opts?.persist !== false) persistState();
    if (opts?.broadcast !== false) emitControlPatch({ audioOpen, reason: opts?.reason || "audio-toggle" });
  }

  function updateNavalToggleTooltip(label){
    if (!navalToggleBtn) return;
    navalToggleBtn.setAttribute("title", label);
    navalToggleBtn.setAttribute("aria-label", label);
    navalToggleBtn.setAttribute("data-bs-original-title", label);
    const tipInstance = (window.bootstrap && window.bootstrap.Tooltip)
      ? window.bootstrap.Tooltip.getInstance(navalToggleBtn)
      : null;
    if (tipInstance) {
      if (typeof tipInstance.setContent === "function") {
        tipInstance.setContent({ ".tooltip-inner": label });
      } else if (tipInstance.tip) {
        const inner = tipInstance.tip.querySelector(".tooltip-inner");
        if (inner) inner.textContent = label;
      }
    }
  }

  function setNavalOpen(next, opts){
    const desired = !!next;
    if (!opts?.force && navalOpen === desired) {
      if (opts?.persist === false) return;
    }
    navalOpen = desired;
    if (navalBlockEl) {
      navalBlockEl.classList.toggle("collapsed", !navalOpen);
      navalBlockEl.setAttribute("aria-hidden", navalOpen ? "false" : "true");
    }
    if (navalToggleBtn) {
      navalToggleBtn.classList.toggle("active", navalOpen);
      navalToggleBtn.setAttribute("aria-pressed", navalOpen ? "true" : "false");
      navalToggleBtn.setAttribute("aria-expanded", navalOpen ? "true" : "false");
      const icon = navalToggleBtn.querySelector("i");
      if (icon) icon.className = navalOpen ? "fa-solid fa-anchor" : "fa-solid fa-ship";
      updateNavalToggleTooltip(navalOpen ? "Ocultar Batalha Naval" : "Mostrar Batalha Naval");
    }
    if (opts?.persist !== false) persistState();
    if (opts?.broadcast !== false) emitControlPatch({ navalOpen, reason: opts?.reason || "naval-toggle" });
  }

  function updatePulseToggleTooltip(label){
    if (!pulseToggleBtn) return;
    pulseToggleBtn.setAttribute("title", label);
    pulseToggleBtn.setAttribute("aria-label", label);
    pulseToggleBtn.setAttribute("data-bs-original-title", label);
    const tipInstance = (window.bootstrap && window.bootstrap.Tooltip)
      ? window.bootstrap.Tooltip.getInstance(pulseToggleBtn)
      : null;
    if (tipInstance) {
      if (typeof tipInstance.setContent === "function") {
        tipInstance.setContent({ ".tooltip-inner": label });
      } else if (tipInstance.tip) {
        const inner = tipInstance.tip.querySelector(".tooltip-inner");
        if (inner) inner.textContent = label;
      }
    }
  }

  function setPulseOpen(next, opts){
    const desired = !!next;
    if (!opts?.force && pulseOpen === desired) {
      if (opts?.persist === false) return;
    }
    pulseOpen = desired;
    if (pulseBlockEl) {
      pulseBlockEl.classList.toggle("collapsed", !pulseOpen);
      pulseBlockEl.setAttribute("aria-hidden", pulseOpen ? "false" : "true");
    }
    if (pulseToggleBtn) {
      pulseToggleBtn.classList.toggle("active", pulseOpen);
      pulseToggleBtn.setAttribute("aria-pressed", pulseOpen ? "true" : "false");
      pulseToggleBtn.setAttribute("aria-expanded", pulseOpen ? "true" : "false");
      const icon = pulseToggleBtn.querySelector("i");
      if (icon) icon.className = pulseOpen ? "fa-solid fa-wave-square" : "fa-solid fa-sliders";
      updatePulseToggleTooltip(pulseOpen ? "Ocultar Sequenciador" : "Mostrar Sequenciador");
    }
    if (opts?.persist !== false) persistState();
    if (opts?.broadcast !== false) emitControlPatch({ pulseOpen, reason: opts?.reason || "pulse-toggle" });
  }

  function updateVideoToggleTooltip(label){
    if (!videoToggleBtn) return;
    videoToggleBtn.setAttribute("title", label);
    videoToggleBtn.setAttribute("aria-label", label);
    videoToggleBtn.setAttribute("data-bs-original-title", label);
    const tipInstance = (window.bootstrap && window.bootstrap.Tooltip)
      ? window.bootstrap.Tooltip.getInstance(videoToggleBtn)
      : null;
    if (tipInstance) {
      if (typeof tipInstance.setContent === "function") {
        tipInstance.setContent({ ".tooltip-inner": label });
      } else if (tipInstance.tip) {
        const inner = tipInstance.tip.querySelector(".tooltip-inner");
        if (inner) inner.textContent = label;
      }
    }
  }

  function setVideoOpen(next, opts){
    const desired = !!next;
    if (!opts?.force && videoOpen === desired) {
      if (opts?.persist === false) return;
    }
    videoOpen = desired;
    if (videoBlockEl) {
      videoBlockEl.classList.toggle("collapsed", !videoOpen);
      videoBlockEl.setAttribute("aria-hidden", videoOpen ? "false" : "true");
    }
    if (videoToggleBtn) {
      videoToggleBtn.classList.toggle("active", videoOpen);
      videoToggleBtn.setAttribute("aria-pressed", videoOpen ? "true" : "false");
      videoToggleBtn.setAttribute("aria-expanded", videoOpen ? "true" : "false");
      const icon = videoToggleBtn.querySelector("i");
      if (icon) icon.className = videoOpen ? "fa-solid fa-circle-play" : "fa-solid fa-clapperboard";
      updateVideoToggleTooltip(videoOpen ? "Ocultar Video" : "Mostrar Video");
    }
    if (opts?.persist !== false) persistState();
    if (opts?.broadcast !== false) emitControlPatch({ videoOpen, reason: opts?.reason || "video-toggle" });
  }

  function setChartOpen(next, opts){
    const desired = !!next;
    if (!opts?.force && chartOpen === desired) {
      if (opts?.persist === false) return;
    }
    chartOpen = desired;
    if (chartBlockEl) {
      chartBlockEl.classList.toggle("collapsed", !chartOpen);
      chartBlockEl.setAttribute("aria-hidden", chartOpen ? "false" : "true");
    }
    if (chartToggleBtn) {
      chartToggleBtn.classList.toggle("active", chartOpen);
      chartToggleBtn.setAttribute("aria-pressed", chartOpen ? "true" : "false");
      chartToggleBtn.setAttribute("aria-expanded", chartOpen ? "true" : "false");
    }
    if (opts?.persist !== false) persistState();
    if (opts?.broadcast !== false) emitControlPatch({ chartOpen, reason: opts?.reason || "chart-toggle" });
  }

  function getLiveAdvanced(){
    const next = { ...advanced };
    if (advancedInputs.pulses && advancedInputs.pulses.value !== "") {
      const v = parseInt(advancedInputs.pulses.value, 10);
      if (Number.isFinite(v)) next.pulses = v;
    }
    if (advancedInputs.duration && advancedInputs.duration.value !== "") {
      const v = parseFloat(advancedInputs.duration.value);
      if (Number.isFinite(v)) next.durationMs = secToMs(v, "durationMs");
    }
    if (advancedInputs.delay && advancedInputs.delay.value !== "") {
      const v = parseFloat(advancedInputs.delay.value);
      if (Number.isFinite(v)) next.delayMs = secToMs(v, "delayMs");
    }
    if (advancedInputs.preDelay && advancedInputs.preDelay.value !== "") {
      const v = parseFloat(advancedInputs.preDelay.value);
      if (Number.isFinite(v)) next.preDelayMs = secToMs(v, "preDelayMs");
    }
    return normalizeAdvancedState(next);
  }

  function applyAdvancedPatch(payload, opts = {}){
    if (!payload || typeof payload !== "object") return;
    const next = { ...advanced };
    let changed = false;
    if (payload.pulses != null && Number.isFinite(Number(payload.pulses))) {
      next.pulses = Number(payload.pulses);
      changed = true;
    }
    if (payload.baseMs != null && Number.isFinite(Number(payload.baseMs))) {
      next.durationMs = Number(payload.baseMs);
      changed = true;
    }
    if (payload.gapMs != null && Number.isFinite(Number(payload.gapMs))) {
      next.delayMs = Number(payload.gapMs);
      changed = true;
    }
    if (payload.preDelayMs != null && Number.isFinite(Number(payload.preDelayMs))) {
      next.preDelayMs = Number(payload.preDelayMs);
      changed = true;
    }
    if (!changed) return;
    advanced = normalizeAdvancedState(next);
    syncAdvancedUi();
    syncAdvancedReadouts();
    if (opts.persist !== false) persistState();
    if (opts.broadcast !== false) broadcastBasics(opts.reason || "advanced-sync");
  }

  function updateAdvancedValue(key, raw){
    if (!advanced) advanced = { ...ADV_DEFAULTS };
    if (key === "durationMs" || key === "delayMs" || key === "preDelayMs") {
      advanced[key] = secToMs(raw, key);
    } else {
      advanced[key] = raw;
    }
    advanced = normalizeAdvancedState(advanced);
    syncAdvancedUi();
    persistState();
    syncAdvancedReadouts();
    broadcastBasics("advanced-change");
  }

  function resetAdvanced(){
    advanced = { ...ADV_DEFAULTS };
    syncAdvancedUi();
    persistState();
    syncAdvancedReadouts();
    broadcastBasics("advanced-reset");
    stopAdvCountdown(false);
  }

  function getStepDecimals(input){
    const rawStep = (input && input.step) ? input.step.toString() : "1";
    if (!rawStep || rawStep === "any") return 0;
    const parts = rawStep.split(".");
    return parts[1] ? parts[1].length : 0;
  }

  function initNumberSpinners(){
    $$(".number-spinner").forEach(spinner => {
      const input = spinner.querySelector('input[type="number"]');
      if (!input) return;
      const decimals = getStepDecimals(input);
      const step = Number.parseFloat(input.step) || 1;
      const parseVal = () => Number.parseFloat(input.value) || 0;
      const clamp = (v) => {
        let next = v;
        if (input.min !== "" && !Number.isNaN(Number(input.min))) next = Math.max(Number(input.min), next);
        if (input.max !== "" && !Number.isNaN(Number(input.max))) next = Math.min(Number(input.max), next);
        return next;
      };
      const format = (v) => decimals > 0 ? v.toFixed(decimals) : String(Math.round(v));
      const bump = (dir) => {
        const next = clamp(parseVal() + dir * step);
        input.value = format(next);
        input.dispatchEvent(new Event("change", { bubbles: true }));
      };
      let holdDelayTimer = null;
      let holdInterval = null;
      let suppressClick = false;
      const clearHoldTimers = () => {
        if (holdDelayTimer) clearTimeout(holdDelayTimer);
        if (holdInterval) clearInterval(holdInterval);
        holdDelayTimer = null;
        holdInterval = null;
      };
      const startHold = (dir) => {
        bump(dir); // primeira interação imediata
        clearHoldTimers();
        holdDelayTimer = setTimeout(() => {
          holdInterval = setInterval(() => bump(dir), 200);
        }, 450);
      };
      spinner.querySelectorAll("button[data-spin]").forEach(btn => {
        const dir = btn.dataset.spin === "inc" ? 1 : -1;
        btn.addEventListener("pointerdown", e => {
          e.preventDefault();
          suppressClick = true;
          startHold(dir);
        });
        ["pointerup","pointerleave","pointercancel"].forEach(ev => {
          btn.addEventListener(ev, () => {
            clearHoldTimers();
            if (ev !== "pointerup") suppressClick = false;
          });
        });
        // fallback para teclado/space/enter
        btn.addEventListener("click", () => {
          if (suppressClick) { suppressClick = false; return; }
          bump(dir);
        });
      });
      window.addEventListener("pointerup", () => {
        clearHoldTimers();
      }, { passive: true });
    });
  }

  function setAdvStatus(text, state="idle"){
    if (!advStatusPill) return;
    advStatusPill.textContent = text;
    advStatusPill.className = "pill " + (state === "run" ? "pill-run" : state === "done" ? "pill-done" : "pill-idle");
    setAdvLedPhase(state === "run" ? "on" : "off");
    if (advStopBtn) advStopBtn.classList.toggle("d-none", state !== "run");
  }

  function setAdvLedPhase(phase){
    if (!advLed) return;
    advLed.classList.remove("led-on", "led-off", "led-gap");
    const cls = phase === "on" ? "led-on" : (phase === "gap" ? "led-gap" : "led-off");
    advLed.classList.add(cls);
  }

  let advButtonLatchDepth = 0;
  function updateAdvButtonLatch(){
    if (!btnSend) return;
    btnSend.classList.toggle("adv-running", advButtonLatchDepth > 0);
  }
  function latchAdvancedButton(){
    advButtonLatchDepth += 1;
    updateAdvButtonLatch();
  }
  function releaseAdvancedButton(){
    advButtonLatchDepth = Math.max(0, advButtonLatchDepth - 1);
    updateAdvButtonLatch();
  }

  function stopAdvCountdown(done=false, resetSignal=true){
    if (advCountdownTimer) clearInterval(advCountdownTimer);
    advCountdownTimer = null;
    advCountdownEndAt = 0;
    if (advCountdownText) advCountdownText.textContent = "-";
    setAdvStatus(done ? "Concluido" : "Pronto", done ? "done" : "idle");
    if (resetSignal && advStopSignal) {
      advStopSignal.stop = false;
      advStopSignal.holdActive = false;
    }
  }

  function ensureAdvHoldOff(){
    if (!advStopSignal || !advStopSignal.holdActive) return;
    advStopSignal.holdActive = false;
    sendCommand("HOLDOFF");
  }

  function requestAdvStop(){
    if (!advStopSignal) return;
    if (!advStopSignal.stop) {
      advStopSignal.stop = true;
    }
    ensureAdvHoldOff();
    clearRouletteAutoTimer();
    releaseRoulettePointer();
    stopAdvCountdown(false, false);
    setAdvStatus("Parado", "idle");
    setAdvLedPhase("off");
  }

  function startAdvCountdown(plan){
    if (!advCountdownText || !advStatusPill) return;
    stopAdvCountdown(false);
    const total = calcBurstTotalMs(plan);
    const endAt = Date.now() + total;
    advCountdownEndAt = endAt;
    setAdvStatus("Executando", "run");
    const tick = ()=>{
      const remain = Math.max(0, advCountdownEndAt - Date.now());
      if (advCountdownText) advCountdownText.textContent = remain <= 0 ? "0.00s" : fmtRemain(remain);
      if (remain <= 0) stopAdvCountdown(true);
    };
    tick();
    advCountdownTimer = setInterval(tick, 120);
  }

  function setAdvancedOpen(open, opts = {}){
    advancedOpen = !!open;
    window.__ADVANCED_PANEL_OPEN__ = advancedOpen;
    if (advancedPanelEl) {
      advancedPanelEl.classList.toggle("adv-open", advancedOpen);
      advancedPanelEl.classList.toggle("adv-collapsed", !advancedOpen);
    }
    if (advancedToggleBtn) {
      advancedToggleBtn.setAttribute("aria-expanded", open ? "true" : "false");
      const icon = advancedToggleBtn.querySelector("i");
      if (icon) icon.className = open ? "fa-solid fa-chevron-up" : "fa-solid fa-chevron-down";
    }
    if (opts.persist !== false) persistState();
    syncAdvancedReadouts();
    if (!advancedOpen) {
      requestAdvStop();
    }
    if (opts.broadcast !== false) {
      emitControlPatch({ advancedOpen, reason: opts.reason || "advanced-toggle" });
    }
  }

  function shouldUseAdvancedBurst(cfg){
    if (!advancedOpen) return false;
    const normalized = normalizeAdvancedState(cfg || { ...advanced });
    return normalized.pulses > 1
      || normalized.durationMs !== ADV_DEFAULTS.durationMs
      || normalized.delayMs !== ADV_DEFAULTS.delayMs
      || normalized.preDelayMs !== ADV_DEFAULTS.preDelayMs;
  }

  function shouldUseRouletteSequence(cfg){
    if (!advancedOpen) return false;
    const normalized = normalizeAdvancedState(cfg || { ...advanced });
    return normalized.pulses > 1
      || normalized.delayMs !== ADV_DEFAULTS.delayMs
      || normalized.preDelayMs !== ADV_DEFAULTS.preDelayMs;
  }

  function setSectionVisibility(el, shouldShow){
    if (!el) return;
    const show = !!shouldShow;
    el.classList.toggle("is-collapsed", !show);
    el.setAttribute("aria-hidden", show ? "false" : "true");
  }

  function setMode(m, opts = {}){
    currentMode = m; window.currentMode = m;
    const showLevel = modeSupportsLevel(m);
    setSectionVisibility(sliderRowEl, showLevel);
    const sliderEl = $("#levelSlider");
    if (sliderEl) sliderEl.disabled = !showLevel;
    setSectionVisibility(rouletteRowEl, m === "ROULETTE");
    // Mantem o nivel atual mesmo quando o modo nao usa slider; o collar ignora o valor.
    if (m !== "ROULETTE") {
      clearRouletteAutoTimer();
      releaseRoulettePointer();
      if (btnSend) btnSend.classList.remove("holding");
    }
    syncModeUi();
    syncModeReadout();
    updateLevelUi(level);
    log(`Modo: ${m}`);
    if (opts.persist !== false) persistState();
    if (opts.broadcast !== false) broadcastBasics(opts.reason || "mode-change");
  }
  function cycleMode(direction=1){
    const idx = MODES.indexOf(currentMode);
    const next = MODES[(idx + direction + MODES.length) % MODES.length] || MODES[0];
    setMode(next);
  }

  function setLevel(v, opts = {}){
    const n = Math.max(0, Math.min(100, Number(v)||0));
    const broadcast = opts.broadcast !== false;
    const changed = n !== level;
    level = n; window.level = n;
    $("#levelSlider").value=n;
    updateLevelUi(n);
    if (broadcast && changed) {
      clearTimeout(levelDebounce);
      levelDebounce = setTimeout(()=> emitControlPatch({ level: n, reason: opts.reason || LEVEL_PATCH_REASON }), 80);
    }
    persistState();
    syncModeUi(); // garante que UI de modo não seja alterada por efeitos colaterais
    if (!changed && broadcast === false) return; // evita refazer tooltip em loop de mesma leitura
  }

  function setChannel(c, opts = {}){
    channel = c; window.channel = c;
    const sw = $("#chanSwitch");
    if (sw) sw.checked = channel === 2;
    const label = $("#channelSwitchValue");
    if (label) label.textContent = String(channel);
    log(`Canal: ${channel}`);
    syncChannelReadout();
    if (opts.persist !== false) persistState();
    if (opts.broadcast !== false) broadcastBasics(opts.reason || "channel-change");
  }

  function buildCmdLine(durationOverride){
    const lvl = modeSupportsLevel(currentMode) ? level : 0;
    const base = `${currentMode},${lvl},${channel}`;
    const dur = Number(durationOverride);
    if (Number.isFinite(dur) && dur > 0) {
      const clamped = clampNum(Math.round(dur), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
      return `${base},${clamped}`;
    }
    return base;
  }

  async function pulseForDuration(durationMs, useHold){
    const dur = clampNum(Math.round(durationMs || 0), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
    if (!useHold) {
      sendCommand(buildCmdLine(dur));
      await waitWithStop(dur);
      return;
    }
    if (!advStopSignal) {
      advStopSignal = { stop: false, holdActive: false };
    }
    advStopSignal.holdActive = true;
    sendCommand(`HOLDON ${buildCmdLine()}`);
    await waitWithStop(dur);
    ensureAdvHoldOff();
  }

  // ===== Envio =====
  const sleep = (ms)=> new Promise(r => setTimeout(r, Math.max(0, ms || 0)));
  const ADV_WAIT_SLICE_MS = 60;
  async function waitWithStop(ms){
    const total = Math.max(0, Number(ms) || 0);
    if (!advStopSignal || total === 0) {
      return advStopSignal ? advStopSignal.stop : false;
    }
    let remaining = total;
    while (remaining > 0 && !advStopSignal.stop) {
      const chunk = Math.min(ADV_WAIT_SLICE_MS, remaining);
      await sleep(chunk);
      remaining -= chunk;
    }
    return advStopSignal.stop;
  }
  function runBurst(cfg){
    advStopSignal = { stop: false, holdActive: false };
    const normalized = normalizeAdvancedState(cfg || { ...ADV_DEFAULTS });
    const pulses = clampNum(Math.round(normalized.pulses || 1), ADV_LIMITS.pulses.min, ADV_LIMITS.pulses.max);
    const dur = clampNum(Math.round(normalized.durationMs || ADV_DEFAULTS.durationMs), ADV_LIMITS.durationMs.min, ADV_LIMITS.durationMs.max);
    const gap = clampNum(Math.round(normalized.delayMs || ADV_DEFAULTS.delayMs), ADV_LIMITS.delayMs.min, ADV_LIMITS.delayMs.max);
    const preDelay = clampNum(Math.round(normalized.preDelayMs || ADV_DEFAULTS.preDelayMs), ADV_LIMITS.preDelayMs.min, ADV_LIMITS.preDelayMs.max);
    const useHold = dur !== ADV_DEFAULTS.durationMs;
    latchAdvancedButton();
    startAdvCountdown({ preDelayMs: preDelay, pulses, durationMs: dur, delayMs: gap });
    (async ()=>{
      try {
        let aborted = false;
        if (preDelay > 0) {
          setAdvLedPhase("gap");
          aborted = await waitWithStop(preDelay);
        }
        for (let i=0;i<pulses && !aborted;i++){
          setAdvLedPhase("on");
          // usa estado atual (modo/level/canal) a cada pulso
          await pulseForDuration(dur, useHold);
          if (advStopSignal.stop) {
            aborted = true;
            break;
          }
          const isLast = i === pulses - 1;
          if (!isLast && gap > 0 && !aborted) {
            setAdvLedPhase("gap");
            aborted = await waitWithStop(gap);
          }
        }
        const completed = !(aborted || advStopSignal.stop);
        stopAdvCountdown(completed);
      } catch(_){
        stopAdvCountdown(false);
      } finally {
        ensureAdvHoldOff();
        setAdvLedPhase("off");
        releaseAdvancedButton();
      }
    })();
  }
  function runRouletteBurst(cfg){
    advStopSignal = { stop: false, holdActive: false };
    const normalized = normalizeAdvancedState({ ...ADV_DEFAULTS, ...(cfg || {}) });
    const pulses = clampNum(Math.round(normalized.pulses || 1), ADV_LIMITS.pulses.min, ADV_LIMITS.pulses.max);
    const gap = clampNum(Math.round(normalized.delayMs || ADV_DEFAULTS.delayMs), ADV_LIMITS.delayMs.min, ADV_LIMITS.delayMs.max);
    const preDelay = clampNum(Math.round(normalized.preDelayMs || ADV_DEFAULTS.preDelayMs), ADV_LIMITS.preDelayMs.min, ADV_LIMITS.preDelayMs.max);
    const holdMs = getRouletteSpinDurationMs(normalized);
    latchAdvancedButton();
    startAdvCountdown({ preDelayMs: preDelay, pulses, durationMs: holdMs, delayMs: gap });
    (async () => {
      try {
        clearRouletteAutoTimer();
        releaseRoulettePointer();
        let aborted = false;
        if (preDelay > 0) {
          setAdvLedPhase("gap");
          aborted = await waitWithStop(preDelay);
        }
        for (let i = 0; i < pulses && !aborted; i++) {
          if (advStopSignal.stop) { aborted = true; break; }
          setAdvLedPhase("on");
          if (!startRoulettePointer()) {
            aborted = true;
            break;
          }
          const finishPromise = waitForRouletteResult();
          const holdStopped = await waitWithStop(holdMs);
          releaseRoulettePointer();
          const finishInfo = await finishPromise;
          if (holdStopped || advStopSignal.stop || finishInfo.reason === "stopped") {
            aborted = true;
            break;
          }
          if (finishInfo.reason === "timeout") {
            log("Roleta nao sinalizou conclusao; prosseguindo apos timeout.", "warn");
          }
          const isLast = i === pulses - 1;
          if (!isLast && gap > 0) {
            setAdvLedPhase("gap");
            aborted = await waitWithStop(gap);
          }
        }
        const completed = !(aborted || advStopSignal.stop);
        stopAdvCountdown(completed);
      } catch(_){
        stopAdvCountdown(false);
      } finally {
        releaseRoulettePointer();
        clearRouletteAutoTimer();
        setAdvLedPhase("off");
        releaseAdvancedButton();
      }
    })();
  }
  function sendOnce(){
    const liveCfg = getLiveAdvanced();
    advanced = liveCfg;
    persistState();
    if (currentMode === "ROULETTE") {
      if (shouldUseRouletteSequence(liveCfg)) {
        runRouletteBurst(liveCfg);
      } else {
        stopAdvCountdown(false);
        triggerRouletteAutoSpin(liveCfg);
      }
      return;
    }
    if (!advancedOpen) {
      stopAdvCountdown(false);
      sendCommand(buildCmdLine());
      return;
    }
    if (!shouldUseAdvancedBurst(liveCfg)) {
      stopAdvCountdown(false);
      const useHold = liveCfg.durationMs !== ADV_DEFAULTS.durationMs;
      if (useHold) {
        pulseForDuration(liveCfg.durationMs, true);
      } else {
        sendCommand(buildCmdLine());
      }
      return;
    }
    runBurst(liveCfg);
  }
  function holdOn(){
    if (btnSend) btnSend.classList.add("holding");
    if (currentMode === "ROULETTE") {
      clearRouletteAutoTimer();
      if (!startRoulettePointer()) {
        if (btnSend) btnSend.classList.remove("holding");
      }
      return;
    }
    sendCommand(`HOLDON ${buildCmdLine()}`);
  }
  function holdOff(){
    if (btnSend) btnSend.classList.remove("holding");
    if (currentMode === "ROULETTE") {
      clearRouletteAutoTimer();
      releaseRoulettePointer();
      return;
    }
    sendCommand("HOLDOFF");
  }

  // ===== Botao: clique unico vs segurar =====
  let pressActive = false;
  let holdStarted = false;
  let holdIntentTimer = null;
  let globalFailSafeTimer = null;
  let lastPointerId = null;

  function armGlobalFailsafe(){
    clearTimeout(globalFailSafeTimer);
    globalFailSafeTimer = setTimeout(() => {
      if (pressActive) stopPress(true);
    }, GLOBAL_HARD_LIMIT * 1000);
  }
  function disarmGlobalFailsafe(){
    clearTimeout(globalFailSafeTimer);
    globalFailSafeTimer = null;
  }

  function startPress(e){
    if (pressActive) return;
    pressActive = true;
    holdStarted = false;

    try {
      if (e && e.pointerId != null && btnSend.setPointerCapture) {
        lastPointerId = e.pointerId;
        btnSend.setPointerCapture(e.pointerId);
      }
    } catch(_) {}

    btnSend.classList.add("pressed");

    clearTimeout(holdIntentTimer);
    holdIntentTimer = setTimeout(() => {
      if (!pressActive || holdStarted) return;
      holdStarted = true;
      holdOn();
      armGlobalFailsafe();
    }, HOLD_THRESHOLD_MS);
  }

  function stopPress(fromFailsafe=false){
    if (!pressActive) return;
    pressActive = false;

    clearTimeout(holdIntentTimer);
    disarmGlobalFailsafe();
    btnSend.classList.remove("pressed");
    btnSend.classList.remove("holding");

    try {
      if (lastPointerId != null && btnSend.releasePointerCapture) {
        btnSend.releasePointerCapture(lastPointerId);
      }
    } catch(_) {}
    lastPointerId = null;

    if (holdStarted) holdOff();
    else sendOnce();
  }

  // Eventos
  btnSend.addEventListener("pointerdown", (e) => {
    if (e && e.cancelable) e.preventDefault();
    startPress(e);
  }, { passive: false });
  btnSend.addEventListener("pointerup",   () => stopPress(false));
  btnSend.addEventListener("pointerleave",() => stopPress(false));
  btnSend.addEventListener("pointercancel",() => stopPress(false));

  // Redes de seguranca
  window.addEventListener("pointerup",   () => stopPress(false), { passive: true });
  window.addEventListener("mouseup",     () => stopPress(false), { passive: true });
  window.addEventListener("touchend",    () => stopPress(false), { passive: true });
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState !== "visible") stopPress(false);
  });
  window.addEventListener("blur",        () => stopPress(false));
  window.addEventListener("pagehide",    () => stopPress(false));
  window.addEventListener("beforeunload",() => stopPress(false));

  // Toggle de exibicao
  const toggleBtn = $("#toggleControl");
  const flowgateModalBtn = $("#flowgateModalBtn");
  const serialModalBtn = $("#serialModalBtn");
  const keepawakeModalBtn = $("#keepawakeModalBtn");
  const interfaceSoundBtn = $("#interfaceSoundToggle");
  const wrapperEl = $("#remoteControlWrapper");
  const PIN_STATE_KEY = "remoteControlInlineState";
  const SOUND_STORAGE_KEY = "interfaceSoundMuted";
  const SOUND_EVENT_NAME = "interface:sound_toggle";
  let pendingHowlerSyncTimer = null;

  function readInlinePreference(){
    try {
      const stored = localStorage.getItem(PIN_STATE_KEY);
      if (stored === null) return true;
      return stored === "inline";
    } catch(_) {
      return true;
    }
  }

  function persistInlinePreference(isInline){
    try {
      localStorage.setItem(PIN_STATE_KEY, isInline ? "inline" : "pinned");
    } catch(_) {}
  }
  function refreshTooltipContent(target, label){
    if (!target || !(window.bootstrap && window.bootstrap.Tooltip)) return;
    const tooltipInstance = window.bootstrap.Tooltip.getInstance(target);
    if (!tooltipInstance) return;
    if (typeof tooltipInstance.setContent === "function") {
      tooltipInstance.setContent({ ".tooltip-inner": label });
    } else if (tooltipInstance.tip) {
      const inner = tooltipInstance.tip.querySelector(".tooltip-inner");
      if (inner) inner.textContent = label;
    }
  }
  function updateToggleBtnUi(isInline){
    if (!toggleBtn) return;
    const icon = toggleBtn.querySelector("i");
    const label = isInline ? "Fixar controle na tela" : "Fechar";
    if (icon) {
      icon.className = isInline ? "fa-solid fa-thumbtack" : "fa-solid fa-xmark";
    }
    toggleBtn.setAttribute("aria-label", label);
    toggleBtn.setAttribute("title", label);
    toggleBtn.setAttribute("data-bs-original-title", label);
    refreshTooltipContent(toggleBtn, label);
  }
  function setInlineMode(state, opts={}){
    if (!wrapperEl) return;
    const nextState = !!state;
    wrapperEl.classList.toggle("inline-mode", nextState);
    updateToggleBtnUi(nextState);
    if (!opts.skipPersist) {
      persistInlinePreference(nextState);
    }
  }

  function readSoundPreference(){
    try {
      const stored = localStorage.getItem(SOUND_STORAGE_KEY);
      if (stored === null) return false;
      return stored === "muted";
    } catch(_) {
      return false;
    }
  }

  function persistSoundPreference(isMuted){
    try {
      localStorage.setItem(SOUND_STORAGE_KEY, isMuted ? "muted" : "unmuted");
    } catch(_) {}
  }

  function updateSoundBtnUi(muted){
    if (!interfaceSoundBtn) return;
    const icon = interfaceSoundBtn.querySelector("i");
    const label = muted ? "Ativar sons" : "Mutar sons";
    if (icon) {
      icon.className = muted ? "fa-solid fa-volume-xmark" : "fa-solid fa-volume-high";
    }
    interfaceSoundBtn.classList.toggle("is-muted", muted);
    interfaceSoundBtn.setAttribute("aria-label", label);
    interfaceSoundBtn.setAttribute("title", label);
    interfaceSoundBtn.setAttribute("aria-pressed", muted ? "true" : "false");
    interfaceSoundBtn.setAttribute("data-bs-original-title", label);
    refreshTooltipContent(interfaceSoundBtn, label);
  }

  function syncHowlerMuteState(muted){
    if (window.Howler && typeof window.Howler.mute === "function") {
      try { window.Howler.mute(muted); } catch(_) {}
      return true;
    }
    return false;
  }

  function ensureHowlerSync(){
    if (pendingHowlerSyncTimer) return;
    let tries = 0;
    pendingHowlerSyncTimer = setInterval(() => {
      tries += 1;
      if (syncHowlerMuteState(window.__INTERFACE_SOUND_MUTED__) || tries > 15) {
        clearInterval(pendingHowlerSyncTimer);
        pendingHowlerSyncTimer = null;
      }
    }, 400);
  }

  function syncSoundOutputs(muted){
    document.querySelectorAll("audio").forEach((audioEl) => {
      audioEl.muted = muted;
      if (muted) {
        try {
          audioEl.pause();
          audioEl.currentTime = 0;
        } catch(_) {}
      }
    });
    if (!syncHowlerMuteState(muted)) ensureHowlerSync();
  }

  function ensureAudioMuteGuard(){
    if (window.__INTERFACE_AUDIO_PATCHED__) return;
    const proto = (window.Audio && window.Audio.prototype) || (window.HTMLAudioElement && window.HTMLAudioElement.prototype);
    if (!proto) return;
    const nativePlay = proto.play;
    if (typeof nativePlay !== "function") return;
    window.__INTERFACE_AUDIO_PATCHED__ = true;
    proto.play = function(...args){
      if (window.__INTERFACE_SOUND_MUTED__) {
        try {
          this.pause();
          this.currentTime = 0;
        } catch(_) {}
        return typeof Promise !== "undefined" ? Promise.resolve() : undefined;
      }
      const result = nativePlay.apply(this, args);
      if (result && typeof result.catch === "function") {
        result.catch(() => {});
      }
      return result;
    };
  }

  function setInterfaceSoundMuted(muted, opts={}){
    const nextState = !!muted;
    const prevState = typeof window.__INTERFACE_SOUND_MUTED__ === "boolean" ? window.__INTERFACE_SOUND_MUTED__ : false;
    window.__INTERFACE_SOUND_MUTED__ = nextState;
    if (document.documentElement && document.documentElement.classList) {
      document.documentElement.classList.toggle("interface-sound-muted", nextState);
    }
    updateSoundBtnUi(nextState);
    window.__FS_SCORE_SOUND_MUTED__ = nextState;
    if (!opts.skipPersist) {
      persistSoundPreference(nextState);
    }
    syncSoundOutputs(nextState);
    if (opts.force || prevState !== nextState) {
      try { window.dispatchEvent(new CustomEvent(SOUND_EVENT_NAME, { detail: { muted: nextState } })); } catch(_) {}
    }
    return nextState;
  }
  if (wrapperEl) {
    setInlineMode(readInlinePreference(), { skipPersist: true });
  }
  if (toggleBtn && wrapperEl) {
    toggleBtn.addEventListener("click", () => {
      const nextState = !wrapperEl.classList.contains("inline-mode");
      setInlineMode(nextState);
    });
  }

  ensureAudioMuteGuard();
  setInterfaceSoundMuted(readSoundPreference(), { skipPersist: true, force: true });

  function ensureFlowgateModal() {
    let modalEl = document.getElementById("flowgate-module-modal");
    if (modalEl) {
      const hiddenHostWrap = modalEl.closest(".host-only");
      if (hiddenHostWrap && document.body) {
        document.body.appendChild(modalEl);
      }
      return modalEl;
    }
    const wrapper = document.createElement("div");
    wrapper.innerHTML = `
      <div class="modal fade" id="flowgate-module-modal" tabindex="-1" aria-labelledby="flowgate-module-modal-label" aria-hidden="true">
        <div class="modal-dialog modal-xl modal-dialog-scrollable">
          <div class="modal-content" style="background:#111;border:1px solid #333;color:#e5e7eb;">
            <div class="modal-header" style="border-bottom:1px solid #2a2a2a;">
              <h5 class="modal-title" id="flowgate-module-modal-label">
                <i class="fa-solid fa-gear me-2"></i>Flowgate
              </h5>
              <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fechar"></button>
            </div>
            <div class="modal-body">
              <div id="flowgate-module-modal-body"></div>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(wrapper.firstElementChild);
    return document.getElementById("flowgate-module-modal");
  }

  function openFlowgateModalFromControl(){
    const navTrigger = document.getElementById("mod-flowgate");
    if (navTrigger && typeof navTrigger.click === "function") {
      navTrigger.click();
      return true;
    }
    const modalEl = ensureFlowgateModal();
    if (!modalEl) {
      const panel = document.getElementById("flowgate-panel");
      if (panel) {
        panel.classList.remove("flowgate-hidden");
        panel.style.display = "";
      }
      if (panel && typeof panel.scrollIntoView === "function") {
        panel.scrollIntoView({ behavior: "smooth", block: "start" });
      }
      return false;
    }
    const modalBody = document.getElementById("flowgate-module-modal-body");
    if (modalBody && modalBody.dataset.bound !== "true") {
      const slot = document.querySelector('section[data-module-src="Modules/Flowgate.html"]');
      if (slot && slot.children.length) {
        const wrapper = document.createElement("div");
        while (slot.firstChild) wrapper.appendChild(slot.firstChild);
        modalBody.appendChild(wrapper);
        modalBody.dataset.bound = "true";
        slot.style.display = "none";
        const panel = document.getElementById("flowgate-panel");
        if (panel) {
          panel.classList.remove("flowgate-hidden");
          panel.style.display = "";
        }
      }
    }
    if (window.bootstrap && typeof window.bootstrap.Modal === "function") {
      window.bootstrap.Modal.getOrCreateInstance(modalEl).show();
    } else {
      modalEl.classList.add("show");
      modalEl.style.display = "block";
      modalEl.removeAttribute("aria-hidden");
    }
    return true;
  }

  function openSerialModalFromControl(){
    const navTrigger = document.getElementById("mod-serial");
    if (navTrigger && typeof navTrigger.click === "function") {
      navTrigger.click();
      return true;
    }
    const modalEl = document.getElementById("serial-module-modal");
    if (!modalEl) {
      const card = document.getElementById("serialPortCard");
      if (card && typeof card.scrollIntoView === "function") {
        card.scrollIntoView({ behavior: "smooth", block: "start" });
      }
      return false;
    }
    const modalBody = document.getElementById("serial-module-modal-body");
    if (modalBody && modalBody.dataset.bound !== "true") {
      const slot = document.querySelector('section[data-module-src="Modules (Host-only)/serialport.html"]');
      if (slot && slot.children.length) {
        const wrapper = document.createElement("div");
        while (slot.firstChild) wrapper.appendChild(slot.firstChild);
        modalBody.appendChild(wrapper);
        modalBody.dataset.bound = "true";
        slot.style.display = "none";
      }
    }
    if (window.bootstrap && typeof window.bootstrap.Modal === "function") {
      window.bootstrap.Modal.getOrCreateInstance(modalEl).show();
    } else {
      modalEl.classList.add("show");
      modalEl.style.display = "block";
      modalEl.removeAttribute("aria-hidden");
    }
    return true;
  }

  function openKeepawakeModalFromControl(){
    const navTrigger = document.getElementById("mod-keepawake");
    if (navTrigger && typeof navTrigger.click === "function") {
      navTrigger.click();
      return true;
    }
    const modalEl = document.getElementById("keepawake-module-modal");
    if (!modalEl) {
      const card = document.getElementById("hbka-widget");
      if (card && typeof card.scrollIntoView === "function") {
        card.scrollIntoView({ behavior: "smooth", block: "start" });
      }
      return false;
    }
    const modalBody = document.getElementById("keepawake-module-modal-body");
    if (modalBody && modalBody.dataset.bound !== "true") {
      const slot = document.querySelector('section[data-module-src="Modules/Keepawake.html"]');
      if (slot && slot.children.length) {
        const wrapper = document.createElement("div");
        while (slot.firstChild) wrapper.appendChild(slot.firstChild);
        modalBody.appendChild(wrapper);
        modalBody.dataset.bound = "true";
        slot.style.display = "none";
      }
    }
    if (window.bootstrap && typeof window.bootstrap.Modal === "function") {
      window.bootstrap.Modal.getOrCreateInstance(modalEl).show();
    } else {
      modalEl.classList.add("show");
      modalEl.style.display = "block";
      modalEl.removeAttribute("aria-hidden");
    }
    return true;
  }

  if (flowgateModalBtn) {
    flowgateModalBtn.addEventListener("click", () => {
      openFlowgateModalFromControl();
    });
  }

  if (serialModalBtn) {
    serialModalBtn.addEventListener("click", () => {
      openSerialModalFromControl();
    });
  }

  if (keepawakeModalBtn) {
    keepawakeModalBtn.addEventListener("click", () => {
      openKeepawakeModalFromControl();
    });
  }

  if (interfaceSoundBtn) {
    interfaceSoundBtn.addEventListener("click", () => {
      setInterfaceSoundMuted(!window.__INTERFACE_SOUND_MUTED__);
    });
  }

  // Controles
  $$(".mode-btn").forEach(b => b.addEventListener("click", () => setMode(b.dataset.mode)));
  $("#chanSwitch").addEventListener("change", e => setChannel(e.target.checked ? 2 : 1));
  $("#levelSlider").addEventListener("input", e => setLevel(e.target.value));
  $("#levelSlider").addEventListener("pointerenter", showSliderTooltip);
  $("#levelSlider").addEventListener("pointerleave", hideSliderTooltip);
  $("#levelSlider").addEventListener("focus", showSliderTooltip);
  $("#levelSlider").addEventListener("blur", hideSliderTooltip);
  if (advancedToggleBtn) advancedToggleBtn.addEventListener("click", () => setAdvancedOpen(!advancedOpen));
  if (scoreboardToggleBtn) scoreboardToggleBtn.addEventListener("click", () => setScoreboardOpen(!scoreboardOpen));
  if (audioToggleBtn) audioToggleBtn.addEventListener("click", () => setAudioOpen(!audioOpen));
  if (navalToggleBtn) navalToggleBtn.addEventListener("click", () => setNavalOpen(!navalOpen));
  if (pulseToggleBtn) pulseToggleBtn.addEventListener("click", () => setPulseOpen(!pulseOpen));
  if (videoToggleBtn) videoToggleBtn.addEventListener("click", () => setVideoOpen(!videoOpen));
  if (chartToggleBtn) chartToggleBtn.addEventListener("click", () => setChartOpen(!chartOpen));
  if (advancedInputs.pulses) advancedInputs.pulses.addEventListener("change", e => updateAdvancedValue("pulses", parseInt(e.target.value,10)));
  if (advancedInputs.duration) advancedInputs.duration.addEventListener("change", e => updateAdvancedValue("durationMs", parseFloat(e.target.value)));
  if (advancedInputs.delay) advancedInputs.delay.addEventListener("change", e => updateAdvancedValue("delayMs", parseFloat(e.target.value)));
  if (advancedInputs.preDelay) advancedInputs.preDelay.addEventListener("change", e => updateAdvancedValue("preDelayMs", parseFloat(e.target.value)));
  initNumberSpinners();
  const advResetBtn = $("#advResetBtn");
  if (advResetBtn) advResetBtn.addEventListener("click", resetAdvanced);
  if (advStopBtn) advStopBtn.addEventListener("click", requestAdvStop);
  initTooltips();
  const levelInputEl = $("#levelValue");
  if (levelInputEl) {
    const commitLevelInput = () => {
      const raw = (levelInputEl.value || "").replace(/\D/g, "");
      setLevel(raw === "" ? 0 : raw);
    };
    levelInputEl.addEventListener("change", commitLevelInput);
    levelInputEl.addEventListener("blur", commitLevelInput);
    levelInputEl.addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        commitLevelInput();
      }
    });
  }

  function embedCustomButtons(){
    const mount = document.getElementById("customButtonsMount");
    const panel = document.getElementById("customPads");
    if (!mount || !panel) return false;
    if (mount.contains(panel)) return true;
    mount.appendChild(panel);
    panel.classList.add("embedded-custom-pads");
    return true;
  }


  // === Dynamic loader for custom buttons widget ===
  function loadCustomButtonsWidget() {
    const mount = document.getElementById("customButtonsMount");
    if (!mount) return;
    // Move the already-loaded module into the control area.
    if (embedCustomButtons()) return;
    // If the module loads later, keep trying briefly.
    if (window.__customPadsMoveTimer) return;
    window.__customPadsMoveTimer = setInterval(() => {
      if (embedCustomButtons()) {
        clearInterval(window.__customPadsMoveTimer);
        window.__customPadsMoveTimer = null;
      }
    }, 200);
  }
  loadCustomButtonsWidget();

    function initStatusNavbar(){
      const flowgatePill = document.getElementById("fg-status-pill");
      const flowgateStateEl = document.getElementById("fg-conn-state");
      const peerCountEl = document.getElementById("fg-peer-count");
      const botCountEl = document.getElementById("fg-bot-count");
      const peerListEl = document.getElementById("fg-peer-list");
      const peerEmptyEl = document.getElementById("fg-peer-empty");
      const serialPill = document.getElementById("serial-status-pill");
      const serialStateEl = document.getElementById("serial-conn-state");
      const serialDevicesPill = document.getElementById("serial-devices-pill");
    const serialDeviceListEl = document.getElementById("serial-device-list");
    const serialDeviceEmptyEl = document.getElementById("serial-device-empty");
    if (!flowgateStateEl || !peerCountEl || !peerListEl || !peerEmptyEl || !serialStateEl) return;

    const setPillState = (pill, state) => {
      if (!pill) return;
      pill.dataset.status = state;
    };

    const setSerialState = (isOpen) => {
      serialStateEl.textContent = isOpen ? "aberta" : "fechada";
      setPillState(serialPill, isOpen ? "ok" : "off");
    };

    const setFlowgateState = (label) => {
      const text = (label || "desconectado").trim();
      flowgateStateEl.textContent = text;
      const lower = text.toLowerCase();
      if (lower.includes("conectado")) setPillState(flowgatePill, "ok");
      else if (lower.includes("erro")) setPillState(flowgatePill, "warn");
      else setPillState(flowgatePill, "off");
    };

    const normalizeLabel = (label) => label.replace(/\s+/g, " ").trim();

    const collectPeerMeta = () => {
      const metaList = [];
      const seen = new Set();
      const bots = new Set();
      const pull = (root) => {
        if (!root) return;
        Array.from(root.children).forEach((row) => {
          const badges = Array.from(row.querySelectorAll(".badge"));
          if (!badges.length) return;
          const mainBadge = badges[0];
          const raw = normalizeLabel(mainBadge.textContent || "");
          if (!raw) return;
          if (/^bot-/i.test(raw)) {
            bots.add(raw);
            return;
          }
          if (seen.has(raw)) return;
          seen.add(raw);
          const tags = badges
            .slice(1)
            .map((b) => normalizeLabel(b.textContent || "").toLowerCase())
            .filter(Boolean);
          metaList.push({ label: raw, title: mainBadge.title || raw, tags });
        });
      };
      const pullBots = (root) => {
        if (!root) return;
        Array.from(root.children).forEach((row) => {
          const badges = Array.from(row.querySelectorAll(".badge"));
          if (!badges.length) return;
          const mainBadge = badges[0];
          const raw = normalizeLabel(mainBadge.textContent || "");
          if (!raw) return;
          bots.add(raw);
        });
      };
      pull(document.getElementById("tr-host-list"));
      pull(document.getElementById("tr-peer-list"));
      pullBots(document.getElementById("tr-bot-list"));
      return { peers: metaList, bots: bots.size };
    };

    const renderSerialDevices = (entries) => {
      if (!serialDevicesPill || !serialDeviceListEl) return;
      serialDeviceListEl.innerHTML = "";
      const hasDevices = Array.isArray(entries) && entries.length > 0;
      serialDevicesPill.dataset.status = hasDevices ? "ok" : "off";
      if (serialDeviceEmptyEl) serialDeviceEmptyEl.classList.toggle("d-none", hasDevices);
      if (!hasDevices) return;
      entries.forEach((peer) => {
        const chip = document.createElement("span");
        chip.className = "serial-device-chip";
        chip.textContent = peer.label;
        chip.title = peer.title;
        serialDeviceListEl.appendChild(chip);
      });
    };

    const renderPeers = () => {
      const { peers: metaList, bots } = collectPeerMeta();
      const peers = metaList.map(({ label, title }) => ({ label, title }));
      peerListEl.innerHTML = "";
      if (!peers.length) {
        peerEmptyEl.classList.remove("d-none");
      } else {
        peerEmptyEl.classList.add("d-none");
        peers.forEach((peer) => {
          const chip = document.createElement("span");
          chip.className = "peer-chip";
          chip.textContent = peer.label;
          chip.title = peer.title;
          peerListEl.appendChild(chip);
        });
      }
      renderSerialDevices(metaList.filter((entry) => entry.tags.includes("serial")));
      peerCountEl.textContent = String(peers.length);
      if (botCountEl) botCountEl.textContent = String(bots);
    };

    const refreshFlowgate = () => {
      const status = document.getElementById("connection-status");
      if (status) setFlowgateState(status.textContent || "desconectado");
      renderPeers();
    };

    const bindPeerObservers = () => {
      const hostList = document.getElementById("tr-host-list");
      const peerList = document.getElementById("tr-peer-list");
      const botList = document.getElementById("tr-bot-list");
      if (!hostList || !peerList) return false;
      const observer = new MutationObserver(() => renderPeers());
      observer.observe(hostList, { childList: true, subtree: true });
      observer.observe(peerList, { childList: true, subtree: true });
      if (botList) observer.observe(botList, { childList: true, subtree: true });
      return true;
    };

    window.addEventListener("flowgate:room_changed", (ev) => {
      setFlowgateState(ev?.detail?.connected ? "conectado" : "desconectado");
      renderPeers();
    });
    window.addEventListener("flowgate:peer_connected", renderPeers);
    window.addEventListener("flowgate:peer_disconnected", renderPeers);

    window.addEventListener("serial-connected", () => setSerialState(true));
    window.addEventListener("serial:connected", () => setSerialState(true));
    window.addEventListener("serial-disconnected", () => setSerialState(false));
    window.addEventListener("serial:disconnected", () => setSerialState(false));

    setSerialState(false);
    setFlowgateState("desconectado");

    let tries = 0;
    const pollTimer = setInterval(() => {
      tries += 1;
      refreshFlowgate();
      if (bindPeerObservers() || tries > 20) clearInterval(pollTimer);
    }, 300);
  }
  initStatusNavbar();

  function getRoletaBtn(){
    return document.getElementById("r3Btn");
  }
  function forwardRoletaEvent(type, srcEvt){
    const bridge = window.__ROULETTE_BRIDGE__;
    if (bridge) {
      if (type === "pointerdown" && typeof bridge.nativePress === "function") {
        return bridge.nativePress(srcEvt) !== false;
      }
      if (type === "pointerup" && typeof bridge.nativeRelease === "function") {
        return bridge.nativeRelease(srcEvt) !== false;
      }
    }
    const target = getRoletaBtn();
    if (!target) return false;
    const opts = { bubbles: true, cancelable: true };
    if (srcEvt && srcEvt.pointerType) opts.pointerType = srcEvt.pointerType;
    if (srcEvt && srcEvt.isPrimary != null) opts.isPrimary = srcEvt.isPrimary;
    let ev;
    try { ev = new PointerEvent(type, opts); } catch(_){ ev = new Event(type, { bubbles: true }); }
    try { return target.dispatchEvent(ev); } catch(_){ return false; }
  }
  window.__ROULETTE_BRIDGE__ = window.__ROULETTE_BRIDGE__ || {};
  window.__ROULETTE_BRIDGE__.forwardEvent = forwardRoletaEvent;

  function clearRouletteAutoTimer(){
    if (rouletteAutoReleaseTimer) {
      clearTimeout(rouletteAutoReleaseTimer);
      rouletteAutoReleaseTimer = null;
    }
  }
  function releaseRoulettePointer(){
    if (!roulettePointerActive) return;
    roulettePointerActive = false;
    forwardRoletaEvent("pointerup");
  }
  function startRoulettePointer(srcEvt){
    if (roulettePointerActive) return true;
    const ok = forwardRoletaEvent("pointerdown", srcEvt);
    if (!ok) {
      log("Roleta indisponivel (#r3Btn nao encontrado)", "warn");
      return false;
    }
    roulettePointerActive = true;
    return true;
  }
  function waitForRouletteResult(timeoutMs = ROULETTE_RESULT_TIMEOUT_MS){
    return new Promise(resolve => {
      let settled = false;
      const safeTimeout = Math.max(0, Number(timeoutMs) || ROULETTE_RESULT_TIMEOUT_MS);
      let stopWatcher = null;
      let timerId = null;
      const cleanup = () => {
        window.removeEventListener("roulette:finished", onFinish);
        if (stopWatcher) clearInterval(stopWatcher);
        if (timerId) clearTimeout(timerId);
      };
      const settle = (reason, detail) => {
        if (settled) return;
        settled = true;
        cleanup();
        resolve({ reason, detail });
      };
      const onFinish = (ev) => settle("event", ev?.detail || null);
      timerId = setTimeout(() => settle("timeout"), safeTimeout);
      stopWatcher = setInterval(() => {
        if (advStopSignal?.stop) settle("stopped");
      }, 80);
      window.addEventListener("roulette:finished", onFinish, { once: true });
    });
  }
  function getRouletteSpinDurationMs(cfg){
    if (!advancedOpen) return ROULETTE_DEFAULT_HOLD_MS;
    const normalized = normalizeAdvancedState({ ...ADV_DEFAULTS, ...(cfg || advanced) });
    const raw = Math.round(normalized.durationMs || ROULETTE_DEFAULT_HOLD_MS);
    return clampNum(raw, ROULETTE_HOLD_LIMITS.min, ROULETTE_HOLD_LIMITS.max);
  }
  function triggerRouletteAutoSpin(cfg){
    const holdMs = getRouletteSpinDurationMs(cfg);
    clearRouletteAutoTimer();
    releaseRoulettePointer();
    if (!startRoulettePointer()) return;
    rouletteAutoReleaseTimer = setTimeout(() => {
      rouletteAutoReleaseTimer = null;
      releaseRoulettePointer();
    }, holdMs);
  }

  function shouldIgnoreKey(e){
    const el = e.target;
    if (!el) return false;
    if (el.isContentEditable) return true;
    if (el.tagName === "TEXTAREA") return true;
    if (el.tagName === "INPUT") {
      const type = (el.getAttribute("type") || "").toLowerCase();
      if (["text","search","number","email","password","tel","url"].includes(type)) return true;
    }
    return false;
  }

  document.addEventListener("keydown", e => {
    if (shouldIgnoreKey(e)) return;
    const key = e.key.toLowerCase();
    if (key === "m") {
      e.preventDefault();
      cycleMode(1);
      return;
    }
    if (key === "c") {
      e.preventDefault();
      setChannel(channel === 1 ? 2 : 1);
      return;
    }
    if (key === " " || e.code === "Space") {
      e.preventDefault();
      startPress();
    }
  });

  document.addEventListener("keyup", e => {
    if (shouldIgnoreKey(e)) return;
    if (e.key === " " || e.code === "Space") {
      e.preventDefault();
      stopPress(false);
    }
  });

  function applyControlPayload(payload, opts = {}){
    if (!payload || typeof payload !== "object") return false;
    const ts = Number.isFinite(payload.ts) ? payload.ts : (payload.ts ? Number(payload.ts) : 0);
    const origin = payload.origin || "unknown";
    if (origin === CONTROL_ORIGIN) return false;
    const prev = lastControlTs.get(origin) || 0;
    if (ts && ts <= prev) return false;
    if (ts) lastControlTs.set(origin, ts);
    if (payload.mode && MODES.includes(payload.mode)) {
      setMode(payload.mode, { broadcast:false, reason:"bus-sync" });
    }
    if (payload.channel != null) {
      const nextChannel = Number(payload.channel);
      if (Number.isFinite(nextChannel)) {
        setChannel(nextChannel, { broadcast:false, reason:"bus-sync" });
      }
    }
    if (payload.level != null) {
      setLevel(payload.level, { broadcast:false, reason:"bus-sync" });
    }
    if (payload.advancedOpen != null) {
      setAdvancedOpen(!!payload.advancedOpen, { broadcast:false });
    }
    if (payload.audioOpen != null) {
      setAudioOpen(!!payload.audioOpen, { force:true, broadcast:false });
    }
    if (payload.navalOpen != null) {
      setNavalOpen(!!payload.navalOpen, { force:true, broadcast:false });
    }
    if (payload.pulseOpen != null) {
      setPulseOpen(!!payload.pulseOpen, { force:true, broadcast:false });
    }
    if (payload.videoOpen != null) {
      setVideoOpen(!!payload.videoOpen, { force:true, broadcast:false });
    }
    if (payload.chartOpen != null) {
      setChartOpen(!!payload.chartOpen, { force:true, broadcast:false });
    }
    applyAdvancedPatch(payload, { broadcast:false, reason:"bus-sync" });
    if (payload.scoreboardOpen != null) {
      setScoreboardOpen(!!payload.scoreboardOpen, { force:true, signalArmed:false });
    } else if (payload.armed != null) {
      setScoreboardOpen(!!payload.armed, { force:true, signalArmed:false });
    }
    if (opts.relayBus) sendControlPayload(payload, { toBus:true, toRoom:false });
    if (opts.relayRoom) sendControlPayload(payload, { toBus:false, toRoom:true });
    return true;
  }

  function bindControlRoom(nextRoom){
    boundControlRoom = nextRoom || null;
    sendControlToRoom = null;
    sendChartToRoom = null;
    if (!boundControlRoom || typeof boundControlRoom.makeAction !== "function") return;
    try {
      const pair = boundControlRoom.makeAction("fs-control");
      if (Array.isArray(pair) && pair.length >= 2) {
        sendControlToRoom = pair[0];
        const getControl = pair[1];
        if (typeof getControl === "function") {
          getControl((payload) => {
            if (!payload) return;
            if (payload.__fs_req === "control-state") {
              if (payload.origin && payload.origin === CONTROL_ORIGIN) return;
              const tsNow = Date.now();
              const snap = buildControlSnapshot("request-sync");
              sendControlPayload({ ...snap, ts: tsNow, origin: CONTROL_ORIGIN }, { toBus:false, toRoom:true });
              return;
            }
            applyControlPayload(payload, { relayBus:true });
          });
        }
      }
    } catch(_){}
    try { sendControlPayload({ __fs_req:"control-state", origin: CONTROL_ORIGIN }, { toBus:false, toRoom:true }); } catch(_){}
    try {
      const pair = boundControlRoom.makeAction("fs-chart");
      if (Array.isArray(pair) && pair.length >= 2) {
        sendChartToRoom = pair[0];
        const getChart = pair[1];
        if (typeof getChart === "function") {
          getChart((payload) => {
            if (!payload) return;
            sendChartPayload({ ...payload, via: "room" }, { toBus:true, toRoom:false });
          });
        }
      }
    } catch(_){}
  }

  function handleBusMessage(msg){
    if (!msg || !msg.type) return;
    if (msg.type === "request-control") {
      if (msg.from && msg.from === CONTROL_ORIGIN) return;
      emitControlPatch(buildControlSnapshot("request-sync"), { toRoom:false });
      return;
    }
    if (msg.type === "fs-chart") {
      if (!msg.payload) return;
      if (msg.payload.via === "room") return;
      sendChartPayload({ ...msg.payload, via: "bus" }, { toBus:false, toRoom:true });
      return;
    }
    if (msg.type !== "fs-control" || !msg.payload) return;
    applyControlPayload(msg.payload, { relayRoom:true });
  }
  if (window.__FS_BUS__ && typeof window.__FS_BUS__.on === "function") {
    window.__FS_BUS__.on(handleBusMessage);
    try { window.__FS_BUS__.send({ type:"request-control", from: CONTROL_ORIGIN }); } catch(_){}
  }

  window.addEventListener("flowgate:room_changed", (ev) => bindControlRoom(ev?.detail?.room || null));
  window.addEventListener("trystero:room", (ev) => bindControlRoom(ev?.detail?.room || null));
  if (window.Flowgate && window.Flowgate.room) bindControlRoom(window.Flowgate.room);
  else if (window.__TRYSTERO_ROOM__) bindControlRoom(window.__TRYSTERO_ROOM__);

  // Inicial
  const savedState = loadState();
  if (savedState?.advanced) {
    advanced = normalizeAdvancedState({ ...ADV_DEFAULTS, ...savedState.advanced });
  }
  advancedOpen = !!savedState?.advancedOpen;
  const initialMode = savedState?.mode || "SHOCK";
  const initialLevel = savedState?.level ?? 0;
  const initialChannel = savedState?.channel || 1;
  const initialScoreboardOpen = savedState?.scoreboardOpen ?? false;
  const initialAudioOpen = savedState?.audioOpen ?? false;
  const initialNavalOpen = savedState?.navalOpen ?? false;
  const initialPulseOpen = savedState?.pulseOpen ?? false;
  const initialVideoOpen = savedState?.videoOpen ?? false;
  const initialChartOpen = savedState?.chartOpen ?? false;
  setMode(initialMode);
  setLevel(initialLevel, { broadcast:false });
  setChannel(initialChannel);
  setScoreboardOpen(initialScoreboardOpen, { persist:false, force:true, signalArmed:false });
  setAudioOpen(initialAudioOpen, { persist:false, force:true, broadcast:false });
  setNavalOpen(initialNavalOpen, { persist:false, force:true, broadcast:false });
  setPulseOpen(initialPulseOpen, { persist:false, force:true, broadcast:false });
  setVideoOpen(initialVideoOpen, { persist:false, force:true, broadcast:false });
  setChartOpen(initialChartOpen, { persist:false, force:true, broadcast:false });
  syncAdvancedUi();
  setAdvancedOpen(advancedOpen, { broadcast:false });
  stopAdvCountdown(false);
  syncLevelInputWidth();
  broadcastBasics("remote-init");
})();
</script>
