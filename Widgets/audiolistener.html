<!-- AUDIO→COLLAR (blog widget) — v2.1 (comandos locais + sync de pico)
  - Comandos executados apenas no host (SerialBridge)
  - Flowgate usado somente para sync de picos (audio.level)
  - Modo espacial: distribui nivel entre canais 1/2 a partir do pan
-->
<div class="card p-3 mt-3" id="audio-collar-widget">
  <div class="d-flex align-items-center gap-2 mb-2 audio-card-header">
    <h5 class="m-0"><i class="fa-solid fa-wave-square me-2"></i>Audio</h5>
    <span id="audio-collar-status" class="small ms-auto text-secondary">pronto</span>
    <span id="audio-collar-spatial-status" class="small text-secondary">Stereo</span>
    <button id="audio-collar-spatial" class="btn btn-sm btn-outline-secondary" type="button" aria-pressed="false" data-bs-toggle="tooltip" data-bs-title="Espacial (Stereo)">
      <i class="fa-solid fa-headphones"></i>
    </button>
    <button id="audio-collar-log-toggle" class="btn btn-sm btn-outline-secondary"
            type="button" title="Mostrar/ocultar log" aria-expanded="false">
      <i class="fa-solid fa-terminal"></i>
    </button>
  </div>

  <div>
         <div id="audio-collar-bar"
             style="position:relative;height:32px;border-radius:9px;overflow:hidden;cursor:pointer">
          <div id="audio-collar-overdrive"
            style="position:absolute;top:0;bottom:0;left:0;width:0;z-index:1"></div>
          <div id="audio-collar-fill"
            style="position:absolute;right:0;top:0;height:100%;width:100%;z-index:2"></div>
      <div id="audio-collar-peak"
         style="position:absolute;top:0;bottom:0;width:2px;opacity:.95;left:0%;z-index:2"></div>
      <div id="audio-collar-threshold"
         style="position:absolute;top:0;bottom:0;width:10px;height:150%;opacity:1;left:20%;z-index:3"></div>
      <div id="audio-collar-th-emoji"
           style="position:absolute;top:-16px;left:20%;transform:translateX(-50%);font-size:16px;line-height:1;z-index:4;">⚡</div>
    </div>
    <div class="d-flex justify-content-between mt-1">
      <small>Volume (RMS): <span id="audio-collar-vol">0%</span></small>
      <small>Pico: <span id="audio-collar-peaklbl">0%</span></small>
      <small>Limite: <span id="audio-collar-th">90%</span></small>
    </div>
  </div>

  <div class="audio-spectrum mt-3">
    <div class="audio-spectrum-shell">
      <canvas id="audio-collar-spectrum" height="120" aria-label="Audio spectrum"></canvas>
    </div>
    <div class="mt-2" aria-label="Spatialidade">
      <div class="d-flex justify-content-between small text-secondary">
        <span>Esquerda</span>
        <span>Centro</span>
        <span>Direita</span>
      </div>
      <div id="audio-collar-spatial-bar" class="audio-spatial-bar">
        <div id="audio-collar-spatial-left" class="audio-spatial-fill is-left" aria-hidden="true"></div>
        <div id="audio-collar-spatial-right" class="audio-spatial-fill is-right" aria-hidden="true"></div>
      </div>
    </div>
  </div>
  <div class="row g-2 mt-2">
    <div class="col-12 col-md-4 d-flex align-items-center gap-2">
      <label class="small mb-0">Gamma</label>
      <input id="audio-collar-gamma" type="range" min="1.0" max="30.0" step="0.1" 
 class="form-range" style="max-width:160px;" />
      <small id="audio-collar-gammalbl" class="text-secondary">4</small>
    </div>
    <div class="col-12 col-md-4 d-flex align-items-center gap-2">
      <label class="small mb-0">Ruído</label>
      <input id="audio-collar-nf" type="range" min="0" max="20" step="1" 
 class="form-range" style="max-width:160px;" />
      <small id="audio-collar-nflbl" class="text-secondary">20%</small>
    </div>
    <div class="col-12 col-md-4 d-flex align-items-center gap-2">
      <label class="small mb-0">Sensibilidade</label>
      <button id="audio-collar-sens-dec" type="button" class="btn btn-sm btn-outline-light px-2">−</button>
      <input id="audio-collar-sens" type="number" step="1" min="-24" max="36"
             class="form-control form-control-sm" style="max-width:80px;" />
      <button id="audio-collar-sens-inc" type="button" class="btn btn-sm btn-outline-light px-2">+</button>
      <small class="text-secondary small">dB</small>
    </div>
  </div>


  <div class="row g-2 mt-2">
    <div class="col-12 d-flex align-items-center gap-2 flex-wrap">
      <label class="small mb-0">Hz Range</label>
      <div id="audio-collar-freq-range" class="audio-range-slider" aria-label="Hz range"></div>
      <input id="audio-collar-freq-minval" type="number" min="20" max="20000" step="10"
             class="form-control form-control-sm" style="max-width:90px;" />
      <span class="text-secondary">-</span>
      <input id="audio-collar-freq-maxval" type="number" min="20" max="20000" step="10"
             class="form-control form-control-sm" style="max-width:90px;" />
    </div>
  </div>

  <div class="row g-2 mt-2">
    <div class="col-12 col-md-6">
      <label class="small mb-0">Preset Hz</label>
      <div class="dropdown">
        <button id="audio-collar-freq-preset-btn" class="btn btn-sm btn-outline-light dropdown-toggle w-100 text-start"
                type="button" data-bs-toggle="dropdown" aria-expanded="false">
          Buscar preset...
        </button>
        <div class="dropdown-menu p-2 w-100 audio-preset-menu">
          <input id="audio-collar-freq-preset-search" type="text" class="form-control form-control-sm mb-2"
                 placeholder="Buscar preset..." autocomplete="off" />
          <div id="audio-collar-freq-preset-list" class="audio-preset-list">
            <button class="dropdown-item" type="button" data-min="30" data-max="70">Ideal (30-70)</button>
            <button class="dropdown-item" type="button" data-min="20" data-max="60">Sub-bass (20-60)</button>
            <button class="dropdown-item" type="button" data-min="50" data-max="120">Kick (50-120)</button>
            <button class="dropdown-item" type="button" data-min="60" data-max="80">Transicao (60-80)</button>
            <button class="dropdown-item" type="button" data-min="40" data-max="100">Bumbo (40-100)</button>
            <button class="dropdown-item" type="button" data-min="60" data-max="200">Baixo (60-200)</button>
            <button class="dropdown-item" type="button" data-min="20" data-max="20000">Full (20-20000)</button>
            <button class="dropdown-item" type="button" data-min="20" data-max="80">Sub graves (20-80)</button>
            <button class="dropdown-item" type="button" data-min="60" data-max="250">Graves (60-250)</button>
            <button class="dropdown-item" type="button" data-min="250" data-max="2000">Medios (250-2000)</button>
            <button class="dropdown-item" type="button" data-min="300" data-max="3400">Voz (300-3400)</button>
            <button class="dropdown-item" type="button" data-min="4000" data-max="12000">Agudos (4000-12000)</button>
            <button class="dropdown-item" type="button" data-min="2000" data-max="5000">Apito basquete (2000-5000)</button>
            <button class="dropdown-item" type="button" data-min="150" data-max="250">Caixa (150-250)</button>
            <button class="dropdown-item" type="button" data-min="1000" data-max="3000">Beeps (1000-3000)</button>
            <button class="dropdown-item" type="button" data-min="5000" data-max="12000">Pratos (5000-12000)</button>
            <button class="dropdown-item" type="button" data-min="27" data-max="4186">Piano (27-4186)</button>
            <button class="dropdown-item" type="button" data-min="80" data-max="1200">Guitarra (80-1200)</button>
            <button class="dropdown-item" type="button" data-min="82" data-max="1200">Violao (82-1200)</button>
            <button class="dropdown-item" type="button" data-min="196" data-max="3136">Violino (196-3136)</button>
            <button class="dropdown-item" type="button" data-min="130" data-max="2637">Viola (130-2637)</button>
            <button class="dropdown-item" type="button" data-min="65" data-max="1000">Cello (65-1000)</button>
            <button class="dropdown-item" type="button" data-min="41" data-max="400">Contrabaixo (41-400)</button>
            <button class="dropdown-item" type="button" data-min="262" data-max="2093">Flauta (262-2093)</button>
            <button class="dropdown-item" type="button" data-min="147" data-max="1568">Clarinete (147-1568)</button>
            <button class="dropdown-item" type="button" data-min="165" data-max="988">Trompete (165-988)</button>
            <button class="dropdown-item" type="button" data-min="82" data-max="698">Trombone (82-698)</button>
            <button class="dropdown-item" type="button" data-min="138" data-max="830">Sax Alto (138-830)</button>
            <button class="dropdown-item" type="button" data-min="110" data-max="700">Sax Tenor (110-700)</button>
            <button class="dropdown-item" type="button" data-min="220" data-max="1760">Oboe (220-1760)</button>
            <button class="dropdown-item" type="button" data-min="58" data-max="700">Fagote (58-700)</button>
            <button class="dropdown-item" type="button" data-min="33" data-max="2000">Harpa (33-2000)</button>
            <button class="dropdown-item" type="button" data-min="60" data-max="200">Timpano (60-200)</button>
            <button class="dropdown-item" type="button" data-min="150" data-max="400">Conga (150-400)</button>
            <button class="dropdown-item" type="button" data-min="2000" data-max="6000">Tamborim (2000-6000)</button>
            <button class="dropdown-item" type="button" data-min="3000" data-max="12000">Triangulo (3000-12000)</button>
            <button class="dropdown-item" type="button" data-min="20" data-max="18000">Geral (20-18000)</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="mt-3">
    <label class="form-label small mb-1">Fontes de áudio</label>
    <div class="mb-2">
      <div class="d-flex flex-wrap gap-2">
        <button id="audio-collar-refresh-media" class="btn btn-sm btn-outline-light">
          <i class="fa-solid fa-music me-1"></i> Escutar página
        </button>
        <button id="audio-collar-capture-tab" class="btn btn-sm btn-outline-light"
                title="Capturar guia/janela com áudio (getDisplayMedia)">
          <i class="fa-solid fa-desktop me-1"></i> Capturar guia/janela
        </button>
        <div class="d-flex align-items-center gap-2 flex-wrap">
          <label for="audio-collar-mic-select" class="small mb-0 text-secondary">Microfone</label>
          <select id="audio-collar-mic-select" class="form-select form-select-sm" style="min-width: 120px; max-width: 140px;">
            <option value="" />Padrão do sistema
          </select>
          <button id="audio-collar-mic" class="btn btn-sm btn-outline-light"
                  title="Capturar microfone (getUserMedia)">
            <i class="fa-solid fa-microphone-lines me-1"></i> Escutar
          </button>
          <button id="audio-collar-stop-source" class="btn btn-sm btn-outline-danger"
                  title="Parar fonte de áudio ativa">
            <i class="fa-solid fa-circle-stop me-1"></i> Stop
          </button>
        </div>
      </div>
    </div>

    <div class="form-text text-secondary small mt-1">
      Guia/janela e microfone usam as permissões padrão do navegador.
      A lista de microfones aparece completa após conceder permissão de áudio.
    </div>
  </div>

  <div id="audio-collar-log-wrap" class="mt-3 d-none">
        <div id="audio-collar-log"
          class="small"
          style="max-height:160px;overflow:auto;border-radius:6px;padding:6px;font-family:ui-monospace,Menlo,Consolas,monospace;">
    </div>
  </div>
</div>

  <style>
    #audio-collar-widget {
      --audio-accent: #38bdf8;
      --audio-accent-strong: rgba(14,165,233,0.95);
      --audio-accent-soft: rgba(56,189,248,0.2);
      --audio-border: rgba(56,189,248,0.4);
      --audio-muted: #bae6fd;
      --audio-text: #e0f2fe;
      --audio-surface: rgba(1,4,12,0.95);
      --audio-panel: rgba(5,11,22,0.85);
      background: radial-gradient(circle at top, rgba(56,189,248,0.25), rgba(1,4,12,0.95));
      border: 1px solid var(--audio-border);
      border-radius: .95rem;
      color: var(--audio-text);
      box-shadow: 0 20px 40px rgba(0,0,0,0.55);
    }
    #audio-collar-widget h5 {
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    #audio-collar-widget .audio-card-header {
      border-bottom: 1px solid var(--audio-border);
      padding-bottom: .6rem;
      margin-bottom: 1.1rem;
    }
    #audio-collar-status {
      color: var(--audio-muted);
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    #audio-collar-widget small,
    #audio-collar-widget label,
    #audio-collar-widget .form-text,
    #audio-collar-widget .text-secondary {
      color: var(--audio-muted) !important;
    }
    #audio-collar-widget .btn-outline-light,
    #audio-collar-widget .btn-outline-secondary,
    #audio-collar-widget .btn-outline-info {
      border-color: var(--audio-border);
      color: var(--audio-text);
      background: rgba(5,9,20,0.6);
      box-shadow: 0 6px 16px rgba(0,0,0,0.35);
      transition: border-color .15s ease, color .15s ease, background .15s ease, box-shadow .15s ease, transform .15s ease;
    }
    #audio-collar-widget .btn-outline-light:hover,
    #audio-collar-widget .btn-outline-secondary:hover,
    #audio-collar-widget .btn-outline-info:hover,
    #audio-collar-widget .btn-outline-light:focus-visible,
    #audio-collar-widget .btn-outline-secondary:focus-visible,
    #audio-collar-widget .btn-outline-info:focus-visible {
      border-color: var(--audio-accent);
      color: #fff;
      background: var(--audio-accent-soft);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.3), 0 10px 24px rgba(0,0,0,0.45);
      transform: translateY(-1px);
    }
    #audio-collar-widget .btn-outline-danger {
      border-color: rgba(248,113,113,0.75);
      color: #fecaca;
      background: rgba(60,8,15,0.6);
    }
    #audio-collar-widget .btn-outline-danger:hover,
    #audio-collar-widget .btn-outline-danger:focus-visible {
      color: #fff;
      border-color: rgba(248,113,113,0.95);
      background: rgba(127,29,29,0.8);
      box-shadow: 0 0 0 2px rgba(248,113,113,0.35);
    }
    #audio-collar-widget .form-control,
    #audio-collar-widget .form-select,
    #audio-collar-widget .input-group-text {
      background: var(--audio-panel);
      border-color: var(--audio-border);
      color: var(--audio-text);
    }
    #audio-collar-widget .form-control:focus,
    #audio-collar-widget .form-select:focus {
      border-color: var(--audio-accent);
      box-shadow: 0 0 0 2px rgba(56,189,248,0.35);
      color: #fff;
    }
    #audio-collar-widget .form-range {
      accent-color: var(--audio-accent);
    }
    #audio-collar-widget .form-range::-webkit-slider-runnable-track {
      background: linear-gradient(90deg, rgba(56,189,248,0.35), rgba(6,40,70,0.75));
      height: 6px;
      border-radius: 999px;
    }
    #audio-collar-widget .form-range::-webkit-slider-thumb {
      background: var(--audio-accent-strong);
      border: 1px solid rgba(255,255,255,0.45);
      width: 16px;
      height: 16px;
      margin-top: -5px;
      box-shadow: 0 4px 12px rgba(56,189,248,0.55);
    }
    #audio-collar-widget .form-range::-moz-range-track {
      background: linear-gradient(90deg, rgba(56,189,248,0.35), rgba(6,40,70,0.75));
      height: 6px;
      border-radius: 999px;
    }
    #audio-collar-widget .form-range::-moz-range-thumb {
      background: var(--audio-accent-strong);
      border: 1px solid rgba(255,255,255,0.45);
      width: 16px;
      height: 16px;
      box-shadow: 0 4px 12px rgba(56,189,248,0.55);
    }
    #audio-collar-widget .audio-range-slider {
      width: 100%;
      max-width: 260px;
      flex: 1 1 220px;
    }
    #audio-collar-widget .audio-range-slider.noUi-target,
    #audio-collar-widget .audio-range-slider .noUi-target {
      background: linear-gradient(90deg, rgba(148,163,184,0.35), rgba(6,40,70,0.75));
      border: 1px solid var(--audio-border);
      border-radius: 999px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
      height: 8px;
    }
    #audio-collar-widget .audio-range-slider .noUi-connect {
      background: linear-gradient(90deg, rgba(34,197,94,0.85), rgba(34,197,94,0.65));
    }
    #audio-collar-widget .audio-range-slider .noUi-handle {
      width: 16px;
      height: 16px;
      right: -8px;
      top: -5px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.45);
      background: var(--audio-accent-strong);
      box-shadow: 0 4px 12px rgba(56,189,248,0.55);
    }
    #audio-collar-widget .audio-range-slider .noUi-handle::before,
    #audio-collar-widget .audio-range-slider .noUi-handle::after {
      display: none;
    }
    #audio-collar-widget .audio-preset-menu {
      background: var(--audio-panel);
      border: 1px solid var(--audio-border);
      box-shadow: 0 16px 30px rgba(0,0,0,0.45);
    }
    #audio-collar-widget .audio-preset-list {
      max-height: 180px;
      overflow: auto;
    }
    #audio-collar-widget .audio-preset-menu .dropdown-item {
      color: var(--audio-text);
    }
    #audio-collar-widget .audio-preset-menu .dropdown-item:hover,
    #audio-collar-widget .audio-preset-menu .dropdown-item:focus {
      background: rgba(56,189,248,0.18);
      color: #fff;
    }
    #audio-collar-bar {
      background: linear-gradient(90deg, rgba(56,189,248,0.95), rgba(14,165,233,0.95), rgba(59,130,246,0.85));
      border: 1px solid var(--audio-border);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05), 0 12px 28px rgba(0,0,0,0.45);
    }
    #audio-collar-overdrive {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 0;
      background: linear-gradient(90deg, rgba(248,113,113,0.15), rgba(248,113,113,0.65), rgba(239,68,68,0.95));
      box-shadow: inset 0 0 0 1px rgba(248,113,113,0.35);
      opacity: 0;
      z-index: 1;
      transition: opacity .12s ease;
    }
    #audio-collar-overdrive.is-hot {
      opacity: 1;
    }
    #audio-collar-fill {
      background: linear-gradient(90deg, rgba(0,2,12,0.95), rgba(0,6,18,0.7));
      z-index: 2;
    }
    #audio-collar-peak {
      background: var(--audio-accent-strong);
      box-shadow: 0 0 14px rgba(56,189,248,0.9);
    }
    #audio-collar-threshold {
      background: linear-gradient(180deg, #fde047, #facc15);
      border-radius: 8px;
      box-shadow: 0 0 18px rgba(250,204,21,0.5);
    }
    #audio-collar-th-emoji {
      color: #fff;
      text-shadow: 0 6px 16px rgba(0,0,0,0.6);
    }
    #audio-collar-log {
      background: rgba(1,4,12,0.75);
      border: 1px solid rgba(255,255,255,0.05);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
    }
    #audio-collar-widget .audio-spectrum-shell {
      background: linear-gradient(135deg, rgba(15,23,42,0.9), rgba(2,6,23,0.85));
      border: 1px solid var(--audio-border);
      border-radius: 14px;
      padding: 8px 10px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03), 0 16px 30px rgba(0,0,0,0.45);
    }
    #audio-collar-widget .audio-spatial-bar {
      position: relative;
      height: 20px;
      border-radius: 2px;
      background: rgba(148,163,184,0.16);
      border: 1px solid var(--audio-border);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.03);
      margin-top: 6px;
      overflow: hidden;
    }
    #audio-collar-widget .audio-spatial-fill {
      position: absolute;
      top: 50%;
      height: 100%;
      transform: translateY(-50%);
      background: rgba(148,163,184,0.6);
      box-shadow: 0 0 10px rgba(148,163,184,0.35);
      transition: width 80ms linear;
      width: 0%;
      opacity: 0.9;
    }
    #audio-collar-widget .audio-spatial-fill.is-left {
      right: 50%;
      border-radius: 2px 0 0 2px;
    }
    #audio-collar-widget .audio-spatial-fill.is-right {
      left: 50%;
      border-radius: 0 2px 2px 0;
    }
    #audio-collar-spectrum {
      display: block;
      width: 100%;
      height: 120px;
    }
    #audio-collar-widget .form-switch .form-check-input {
      border-color: var(--audio-border);
      background-color: rgba(2,8,23,0.8);
    }
    #audio-collar-widget .form-switch .form-check-input:checked {
      background-color: var(--audio-accent);
    }
  </style>

<script>
(function(){
  'use strict';
  const widgetRoot = document.getElementById('audio-collar-widget');
  if (!widgetRoot) return;
  const prevInstance = window.__AUDIO_COLLAR_WIDGET_V20__;
  const prevRoot = prevInstance && prevInstance.root;
  const prevReady = !!(prevRoot && prevRoot.dataset && prevRoot.dataset.audioCollarReady === '1');
  if (prevRoot && document.body.contains(prevRoot) && prevReady) return;
  if (prevInstance && typeof prevInstance.teardown === 'function') {
    try { prevInstance.teardown('reinit'); } catch(_){ }
  }
  window.__AUDIO_COLLAR_WIDGET_V20__ = { root: widgetRoot, teardown: null };

  // ---------- CONFIG ----------
  const POLL_MS   = 35;     // leitura do audio (mais rapida)
  const COMMIT_MS = 120;    // commit do estado hold (baixo delay / baixo jitter)
  const LEVEL_BROADCAST_MS = 90; // minimo entre pacotes quando acima do threshold
  const LEVEL_BROADCAST_MS_IDLE = 260; // mais lento quando abaixo do threshold
  const LEVEL_KEEPALIVE_MS = 2000; // keepalive acima do threshold
  const LEVEL_KEEPALIVE_MS_IDLE = 8000; // keepalive abaixo do threshold
  const LEVEL_DELTA_PCT = 1; // mudanca minima para enviar nivel antes do keepalive
  const CFG_BROADCAST_MS = 180; // throttle de envio de config ao arrastar sliders
  const STEP_PCT  = 10;
  const LS_PREFIX = 'audioCollarWidget.';

  const PEAK_ENV_DECAY = 0.98;
  const PEAK_MIN_FLOOR = 0.0;
  const SENS_DB_MIN  = -24;
  const SENS_DB_MAX  =  36;
  const SENS_DB_STEP =   3;

  const FREQ_MIN_LIMIT = 20;
  const FREQ_MAX_LIMIT = 20000;
  const FREQ_GAP_HZ = 10;

  const SPECTRUM_BARS = 36;
  const SPECTRUM_MIN_HZ = 20;
  const SPECTRUM_MAX_HZ = 20000;
  const SPECTRUM_FLOOR = 0.04;
  const SPECTRUM_GAMMA = 0.8;

  // Spatial/pan (deterministico)
  const SPATIAL_PAN_SMOOTH = 0.2;  // EMA fixo
  const SPATIAL_PAN_DEADZONE = 0.08;
  const SPATIAL_PAN_QUANT = 0.02;
  const SPATIAL_TIME_SAMPLES = 256;

  // Estabilidade do limiar
  const THRESH_HYST = 2;        // histerese (%)
  const DWELL_ON_MS = 40;       // precisa ficar acima por X ms (antes 80; evita perder picos)
  const DWELL_OFF_MS = 120;     // precisa ficar abaixo por X ms
  const FAST_TRIP_MARGIN = 10;  // se passar muito do threshold, dispara sem dwell

  // Receiver watchdog (se perder heartbeat, solta)
  const RX_TIMEOUT_MS = 950;
  const CFG_SYNC_ACTION = 'audioCollar';
  const LEVEL_SYNC_ACTION = 'audioLevel';

  // Bridge: converte hold.state em chat:message HOLDON/HOLDOFF (para seu executor legado)
  const EMIT_CHAT_BRIDGE = false;
  const SIMPLIFY_LEGACY_COMMANDS = false;

  // ---------- STORAGE ----------
  const LS = {
    get(k, d){
      try {
        const v = localStorage.getItem(LS_PREFIX + k);
        return v === null ? d : JSON.parse(v);
      } catch(e){ return d; }
    },
    set(k, v){
      try { localStorage.setItem(LS_PREFIX + k, JSON.stringify(v)); } catch(e){}
    }
  };

  // ---------- UI helpers ----------
  const clamp = (n,min,max) => Math.max(min, Math.min(max, n));
  const $  = sel => document.querySelector(sel);
  const ALLOWED_MODES = ['BEEP','VIBRATION','SHOCK','LIGHT','ROULETTE'];
  const sanitizeMode = (m) => {
    const v = String(m || '').toUpperCase();
    return ALLOWED_MODES.includes(v) ? v : 'BEEP';
  };
  const normalizeChannel = (c) => (Number(c) === 2 ? 2 : 1);

  function normalizeFreqRange(minHz, maxHz, sampleRate){
    const nyquist = sampleRate ? (sampleRate / 2) : FREQ_MAX_LIMIT;
    const maxLimit = Math.min(FREQ_MAX_LIMIT, Math.max(FREQ_MIN_LIMIT + FREQ_GAP_HZ, Math.floor(nyquist)));
    let min = clamp(Math.round(minHz), FREQ_MIN_LIMIT, maxLimit - FREQ_GAP_HZ);
    let max = clamp(Math.round(maxHz), min + FREQ_GAP_HZ, maxLimit);
    if (max - min < FREQ_GAP_HZ) {
      max = clamp(min + FREQ_GAP_HZ, FREQ_MIN_LIMIT + FREQ_GAP_HZ, maxLimit);
      min = clamp(max - FREQ_GAP_HZ, FREQ_MIN_LIMIT, maxLimit - FREQ_GAP_HZ);
    }
    return { min, max };
  }

  function connectToAnalysers(node){
    if (analyserVis) {
      try { node.connect(analyserVis); } catch(_){ }
    }
    if (analyserDet) {
      try { node.connect(analyserDet); } catch(_){ }
    }
    if (spatialSplitter) {
      try { node.connect(spatialSplitter); } catch(_){ }
    }
  }

  function setStatus(txt, ok){
    const s = $('#audio-collar-status');
    if (!s) return;
    s.textContent = txt;
    s.classList.toggle('text-success', !!ok);
  }

  function appendLog(txt){
    const el = $('#audio-collar-log'); if (!el) return;
    const d = document.createElement('div');
    const t = new Date();
    const hh = String(t.getHours()).padStart(2,'0');
    const mm = String(t.getMinutes()).padStart(2,'0');
    const ss = String(t.getSeconds()).padStart(2,'0');
    d.textContent = `[${hh}:${mm}:${ss}] ${txt}`;
    el.appendChild(d);
    el.scrollTop = el.scrollHeight;
    try { window.appLog && window.appLog('[Audio→Collar] ' + txt, 'info'); } catch(_) {}
  }

  // ---------- STATE ----------
  let control = {
    mode: sanitizeMode(window.currentMode || 'BEEP'),
    channel: normalizeChannel(window.channel || 1)
  };
  let cfg = {
    thresholdPct:  LS.get('thresholdPct', 90),
    gamma:         LS.get('gamma', 4),
    noiseFloorPct: LS.get('noiseFloorPct', 20),
    sensDb:        LS.get('sensDb', 0),
    freqMinHz:     LS.get('freqMinHz', 20),
    freqMaxHz:     LS.get('freqMaxHz', 70),
    spatialEnabled: LS.get('spatialEnabled', false)
  };

  // Áudio
  let audioCtx = null;
  let analyserVis = null;
  let analyserDet = null;
  let analyserDetL = null;
  let analyserDetR = null;
  let spatialSplitter = null;
  let elementSources = [];
  let streamSource   = null;
  let micStream = null;
  let tabStream = null;
  let envPeakAbs = 0;
  let envPeakAbsL = 0;
  let envPeakAbsR = 0;
  let spatialPanState = 0;
  let lastSpatialPan = 0;
  let lastSpatialSeenAt = 0;
  let spatialAvailable = true;
  let spectrumCanvas = null;
  let spectrumCtx = null;
  let spectrumW = 0;
  let spectrumH = 0;
  let spectrumDpr = 1;
  let spectrumData = null;
  let spectrumDragActive = false;
  let spectrumDragStartHz = null;
  let spectrumDragMode = null;
  let setFreqRangeExternal = null;
  let freqSlider = null;
  let freqSliderLock = false;
  let freqSliderBound = false;
  let freqSliderInitTimer = null;

  // holdSync transport
  let holdTx = null;          // sendHold
  let holdRxBound = false;    // listener instalado?
  let roomBound = null;
  let cfgSyncTx = null;
  let cfgSyncRxBound = false;
  let lastCfgTs = 0;
  let levelSyncTx = null;
  let levelSyncRxBound = false;
  let lastLevelTs = 0;
  let lastLevelSentAt = 0;
  let lastLevelSentPeak = 0;
  let lastLevelSentPct = 0;
  let remoteLevel = null;
  let cfgBroadcastTimer = null;
  let lastCfgBroadcastAt = 0;
  let pendingCfgReason = '';

  // Controle por estado
  let seq = 1;
  let desired = { on:false, mode: control.mode, level: 0, ch: control.channel, level1: 0, level2: 0, pan: 0, split: false, seq: 0 };
  let lastCommittedSeq = 0;
  let controlBusBound = false;
  let lastRxSig = null;
  let warnedNoHoldTx = false;
  let warnedNoSerial = false;
  let rouletteHoldActive = false;
  let warnedNoRoulette = false;
  let lastSpatialCmdAt = 0;
  let lastSpatialPeak = 0;
  let destroyed = false;
  let tickTimer = null;
  let commitTimer = null;
  let controlTimer = null;
  let spatialTooltip = null;

  function isMounted(){
    return !!(widgetRoot && document.body.contains(widgetRoot));
  }

  function isHost(){
    try {
      const peer = (window.Flowgate && window.Flowgate.localPeer) ? window.Flowgate.localPeer : window.__TRYSTERO_PEER__;
      const tags = (peer && typeof peer.getLocalTags === 'function') ? peer.getLocalTags() : [];
      const hasTag = Array.isArray(tags) && tags.map(t => String(t || '').toLowerCase()).includes('host');
      if (hasTag) return true;
      return document.documentElement.classList.contains('host-on');
    } catch { return false; }
  }

  function teardown(reason){
    if (destroyed) return;
    destroyed = true;
    if (tickTimer) { clearInterval(tickTimer); tickTimer = null; }
    if (commitTimer) { clearInterval(commitTimer); commitTimer = null; }
    if (controlTimer) { clearInterval(controlTimer); controlTimer = null; }
    if (rxWatchdogTimer) { clearInterval(rxWatchdogTimer); rxWatchdogTimer = null; }
    if (cfgBroadcastTimer) { clearTimeout(cfgBroadcastTimer); cfgBroadcastTimer = null; }
    if (freqSliderInitTimer) { clearInterval(freqSliderInitTimer); freqSliderInitTimer = null; }
    try { stopAllSources(); } catch(_){ }
    window.__AUDIO_COLLAR_WIDGET_V20__ = null;
    if (reason) appendLog('Widget finalizado: ' + reason);
  }

  function setControlState(next){
    appendLog(`setControlState: next=${JSON.stringify(next)}`);
    const nextMode = (next && next.mode != null) ? sanitizeMode(next.mode) : control.mode;
    const nextChan = (next && next.channel != null) ? normalizeChannel(next.channel) : control.channel;
    const changed = nextMode !== control.mode || nextChan !== control.channel;
    control.mode = nextMode;
    control.channel = nextChan;
    if (changed) {
      const nextSeq = desired.on ? ++seq : desired.seq;
      const nextCh = (cfg.spatialEnabled && spatialAvailable) ? desired.ch : control.channel;
      desired = Object.assign({}, desired, { mode: control.mode, ch: nextCh, seq: nextSeq });
      appendLog(`Controle Manual: modo ${control.mode}, canal ${control.channel}. Desired state updated.`);
    } else {
      appendLog(`Controle Manual: modo ${control.mode}, canal ${control.channel}. No change.`);
    }
  }

  // Anti-chatter (dwell)
  let aboveSince = 0;
  let belowSince = 0;

  // Receiver state (aplicação local + watchdog)
  let rxLastSeq = 0;
  let rxLastSeenAt = 0;
  let rxWatchdogTimer = null;

  // ---------- Bridge (opcional) ----------
  function emitChatMessage(text, origin, extra){
    const t = String(text || '').trim();
    if (!t) return;
    if (window.SerialBridge && typeof window.SerialBridge.send === 'function') {
      try { window.SerialBridge.send(t); } catch(_){}
      return;
    }
    try { console.warn('[audio-collar] SerialBridge.send indisponivel.'); } catch(_){}
  }

  function forwardRoulettePointer(type, srcEvt){
    const bridge = window.__ROULETTE_BRIDGE__;
    if (bridge) {
      if (typeof bridge.forwardEvent === 'function') {
        return bridge.forwardEvent(type, srcEvt);
      }
      if (type === 'pointerdown' && typeof bridge.nativePress === 'function') {
        return bridge.nativePress(srcEvt);
      }
      if (type === 'pointerup' && typeof bridge.nativeRelease === 'function') {
        return bridge.nativeRelease(srcEvt);
      }
    }
    const target = document.getElementById('r3Btn');
    if (!target) return false;
    const opts = { bubbles: true, cancelable: true };
    if (srcEvt && srcEvt.pointerType) opts.pointerType = srcEvt.pointerType;
    if (srcEvt && srcEvt.isPrimary != null) opts.isPrimary = srcEvt.isPrimary;
    let ev;
    try { ev = new PointerEvent(type, opts); } catch(_){ ev = new Event(type, { bubbles: true }); }
    try { return target.dispatchEvent(ev); } catch(_){ return false; }
  }

  function applyRouletteHoldState(shouldHold, meta){
    const next = !!shouldHold;
    if (next === rouletteHoldActive) return;
    const ok = forwardRoulettePointer(next ? 'pointerdown' : 'pointerup', meta && meta.srcEvt);
    if (ok === false) {
      if (!warnedNoRoulette) {
        appendLog('Roleta indisponivel (#r3Btn nao encontrado).');
        warnedNoRoulette = true;
      }
      return;
    }
    warnedNoRoulette = false;
    rouletteHoldActive = next;
  }

  function applyHoldStateLocal(state, meta){
    // Emite evento próprio
    try { window.dispatchEvent(new CustomEvent('hold:state', { detail: { state, meta } })); } catch(_){}

    const modeKey = String(state && state.mode || control.mode || '').toUpperCase();
    if (modeKey === 'ROULETTE') {
      applyRouletteHoldState(!!state.on, meta);
      return;
    }
    if (rouletteHoldActive) applyRouletteHoldState(false, meta);

    if (!EMIT_CHAT_BRIDGE) return;

    // Converte para comandos legados (para o executor atual)
    if (state.on) {
      if (SIMPLIFY_LEGACY_COMMANDS) {
        emitChatMessage(`H ${state.mode.charAt(0)} ${state.level} ${state.ch}`, 'trystero-in', {
          loopback: true,
          silent: true,
          meta: Object.assign({ via: 'holdSync.bridge' }, meta || {})
        });
      } else {
        emitChatMessage(`HOLDON ${state.mode},${state.level},${state.ch}`, 'trystero-in', {
          loopback: true,
          silent: true,
          meta: Object.assign({ via: 'holdSync.bridge' }, meta || {})
        });
      }
    } else {
      if (SIMPLIFY_LEGACY_COMMANDS) {
        emitChatMessage('O', 'trystero-in', {
          loopback: true,
          silent: true,
          meta: Object.assign({ via: 'holdSync.bridge' }, meta || {})
        });
      } else {
        emitChatMessage('HOLDOFF', 'trystero-in', {
          loopback: true,
          silent: true,
          meta: Object.assign({ via: 'holdSync.bridge' }, meta || {})
        });
      }
    }
  }

  // ---------- Transport bind ----------
  function bindHoldSyncToRoom(room){
    roomBound = room || null;
    holdTx = null;
    holdRxBound = false;

    if (!room) {
      setStatus('conecte no Flowgate', false);
      appendLog('Sem sala Flowgate: aguardando conexao.');
      return;
    }

    try {
      const pair = room.makeAction('holdSync');
      const sendHold = Array.isArray(pair) ? pair[0] : null;
      const onHold   = Array.isArray(pair) ? pair[1] : null;

      if (typeof sendHold !== 'function' || typeof onHold !== 'function') {
        setStatus('erro holdSync', false);
        appendLog('Falha ao criar action holdSync.');
        return;
      }

      holdTx = sendHold;

      // Receiver: aplica qualquer hold.state recebido
      onHold((data, peerId) => {
        const s = (data && typeof data === 'object') ? data : null;
        if (!s || s.type !== 'hold.state') return;

        const sseq = Number(s.seq || 0);
        if (sseq <= rxLastSeq) return; // idempotência
        rxLastSeq = sseq;
        rxLastSeenAt = Date.now();

        const level1 = clamp(Number(s.ch1Level || 0), 0, 100);
        const level2 = clamp(Number(s.ch2Level || 0), 0, 100);
        const state = {
          on: !!s.on,
          mode: String(s.mode || control.mode),
          level: clamp(Number(s.level || 0), 0, 100),
          ch: clamp(Number(s.ch || 1), 1, 2),
          level1,
          level2,
          pan: clamp(Number(s.pan || 0), -1, 1),
          split: !!s.split,
          seq: sseq
        };

        applyHoldStateLocal(state, { fromPeer: String(peerId || ''), via: 'holdSync.rx' });
      });

      holdRxBound = true;
      setStatus('holdSync pronto', true);
      appendLog('holdSync ligado (TX/RX).');

      // Watchdog: se parar heartbeat, solta
      if (rxWatchdogTimer) clearInterval(rxWatchdogTimer);
      rxWatchdogTimer = setInterval(() => {
        if (!isMounted()) {
          teardown('unmounted');
          return;
        }
        if (!rxLastSeenAt) return;
        const age = Date.now() - rxLastSeenAt;
        // só faz sentido se o último estado aplicado foi ON
        // (não guardamos "rxOn" separado porque o executor legado já lida; aqui garantimos soltura)
        if (age > RX_TIMEOUT_MS) {
          rxLastSeenAt = 0;
          applyHoldStateLocal({ on:false, mode: control.mode, level:0, ch: control.channel, seq: ++rxLastSeq }, { via: 'holdSync.watchdog' });
        }
      }, 200);

    } catch (e) {
      setStatus('erro holdSync', false);
      appendLog('Erro bind holdSync: ' + (e?.message || String(e)));
    }
  }

  // Bind imediato se ja existir sala
  if (window.Flowgate && window.Flowgate.room) bindRoom(window.Flowgate.room);
  else if (window.__TRYSTERO_ROOM__) bindRoom(window.__TRYSTERO_ROOM__);
  window.addEventListener('flowgate:room_changed', (ev) => bindRoom(ev?.detail?.room || null));
  window.addEventListener('trystero:room', (ev) => bindRoom(ev?.detail?.room || null));

 
  // ---------- Config sync (gamma / sens / threshold / noise) ----------
  function applyRemoteCfg(payload){
    const patch = payload || {};
    let changed = false;
    if (Number.isFinite(patch.thresholdPct)) {
      cfg.thresholdPct = clamp(patch.thresholdPct, 0, 100);
      LS.set('thresholdPct', cfg.thresholdPct);
      changed = true;
    }
    if (Number.isFinite(patch.gamma)) {
      cfg.gamma = clamp(patch.gamma, 1.0, 30.0);
      LS.set('gamma', cfg.gamma);
      changed = true;
    }
    if (Number.isFinite(patch.noiseFloorPct)) {
      cfg.noiseFloorPct = clamp(patch.noiseFloorPct, 0, 50);
      LS.set('noiseFloorPct', cfg.noiseFloorPct);
      changed = true;
    }
    if (Number.isFinite(patch.sensDb)) {
      cfg.sensDb = clamp(patch.sensDb, SENS_DB_MIN, SENS_DB_MAX);
      LS.set('sensDb', cfg.sensDb);
      changed = true;
    }
    if (Number.isFinite(patch.freqMinHz) || Number.isFinite(patch.freqMaxHz)) {
      const nextMin = Number.isFinite(patch.freqMinHz) ? patch.freqMinHz : cfg.freqMinHz;
      const nextMax = Number.isFinite(patch.freqMaxHz) ? patch.freqMaxHz : cfg.freqMaxHz;
      const range = normalizeFreqRange(nextMin, nextMax, audioCtx ? audioCtx.sampleRate : null);
      cfg.freqMinHz = range.min;
      cfg.freqMaxHz = range.max;
      LS.set('freqMinHz', cfg.freqMinHz);
      LS.set('freqMaxHz', cfg.freqMaxHz);
      changed = true;
    }
    if (typeof patch.spatialEnabled === 'boolean') {
      cfg.spatialEnabled = !!patch.spatialEnabled;
      LS.set('spatialEnabled', cfg.spatialEnabled);
      changed = true;
    }
    if (changed) {
      updateThresholdUI();
      updateSensUI();
      updateFreqUI();
      updateSpatialUI();
      
      const g = $('#audio-collar-gamma');
      const gl = $('#audio-collar-gammalbl');
      const nf = $('#audio-collar-nf');
      const nfl = $('#audio-collar-nflbl');
      if (g && gl) { g.value = String(cfg.gamma); gl.textContent = String(cfg.gamma); }
      if (nf && nfl) { nf.value = String(cfg.noiseFloorPct); nfl.textContent = cfg.noiseFloorPct + '%'; }
      appendLog('Config recebida via Flowgate.');
    }
  }

  function broadcastCfg(reason){
    if (!cfgSyncTx) return;
    try {
      cfgSyncTx({
        type: 'audio.cfg',
        thresholdPct: cfg.thresholdPct,
        gamma: cfg.gamma,
        noiseFloorPct: cfg.noiseFloorPct,
        sensDb: cfg.sensDb,
        freqMinHz: cfg.freqMinHz,
        freqMaxHz: cfg.freqMaxHz,
        spatialEnabled: !!cfg.spatialEnabled,
        ts: Date.now(),
        reason: reason || 'update'
      });
    } catch(_){}
  }

  function requestCfgBroadcast(reason){
    if (!cfgSyncTx) return;
    const now = Date.now();
    const elapsed = now - lastCfgBroadcastAt;
    if (reason) pendingCfgReason = reason;
    if (elapsed >= CFG_BROADCAST_MS) {
      lastCfgBroadcastAt = now;
      const r = pendingCfgReason || 'update';
      pendingCfgReason = '';
      broadcastCfg(r);
      return;
    }
    if (!cfgBroadcastTimer) {
      const delay = Math.max(0, CFG_BROADCAST_MS - elapsed);
      cfgBroadcastTimer = setTimeout(() => {
        cfgBroadcastTimer = null;
        lastCfgBroadcastAt = Date.now();
        const r = pendingCfgReason || 'update';
        pendingCfgReason = '';
        broadcastCfg(r);
      }, delay);
    }
  }

  function flushCfgBroadcast(reason){
    if (!cfgSyncTx) return;
    if (cfgBroadcastTimer) {
      clearTimeout(cfgBroadcastTimer);
      cfgBroadcastTimer = null;
    }
    pendingCfgReason = '';
    lastCfgBroadcastAt = Date.now();
    broadcastCfg(reason || 'update');
  }

  function bindCfgSyncToRoom(room){
    cfgSyncTx = null;
    cfgSyncRxBound = false;
    if (!room) return;
    try {
      const pair = room.makeAction(CFG_SYNC_ACTION);
      const tx = Array.isArray(pair) ? pair[0] : null;
      const rx = Array.isArray(pair) ? pair[1] : null;
      if (typeof tx !== 'function' || typeof rx !== 'function') {
        appendLog('Falha ao criar action audioCollar (cfg sync).');
        return;
      }
      cfgSyncTx = tx;
      rx((data) => {
        if (!data || data.type !== 'audio.cfg') return;
        const ts = Number(data.ts || 0);
        if (ts && ts <= lastCfgTs) return;
        lastCfgTs = ts || Date.now();
        applyRemoteCfg(data);
      });
      cfgSyncRxBound = true;
      appendLog('Sync de config ligado (Flowgate).');
      broadcastCfg('bind');
    } catch(e){
      appendLog('Erro bind audio.cfg: ' + (e?.message || String(e)));
    }
  }

  function bindRoom(room){
    bindLevelSyncToRoom(room);
  }

  // ---------- Level sync (picos em tempo real) ----------
  function applyRemoteLevel(payload){
    const p = payload || {};
    const ts = Number(p.ts || 0);
    if (ts && ts <= lastLevelTs) return;
    lastLevelTs = ts || Date.now();
    const pct = clamp(Number(p.pct || 0), 0, 100);
    const peakPct = clamp(Number(p.peakPct || 0), 0, 100);
    remoteLevel = { pct, peakPct, ts: lastLevelTs };
  }

  function broadcastLevel(pct, peakPct){
    if (!levelSyncTx) return;
    const now = Date.now();
    const since = now - lastLevelSentAt;
    const peakDelta = Math.abs(peakPct - lastLevelSentPeak);
    const pctDelta = Math.abs(pct - lastLevelSentPct);
    const hasChange = peakDelta >= LEVEL_DELTA_PCT || pctDelta >= LEVEL_DELTA_PCT;
    const thresholdPct = clamp(cfg.thresholdPct || 0, 0, 100);
    const isHot = peakPct >= thresholdPct;
    const minInterval = isHot ? LEVEL_BROADCAST_MS : LEVEL_BROADCAST_MS_IDLE;
    const keepaliveInterval = isHot ? LEVEL_KEEPALIVE_MS : LEVEL_KEEPALIVE_MS_IDLE;
    if (!hasChange && since < keepaliveInterval) return;
    if (hasChange && since < minInterval) return;
    lastLevelSentAt = now;
    lastLevelSentPeak = peakPct;
    lastLevelSentPct = pct;
    try {
      levelSyncTx({ type: 'audio.level', pct, peakPct, ts: now });
    } catch(_){}
  }

  function bindLevelSyncToRoom(room){
    levelSyncTx = null;
    levelSyncRxBound = false;
    if (!room) return;
    try {
      const pair = room.makeAction(LEVEL_SYNC_ACTION);
      const tx = Array.isArray(pair) ? pair[0] : null;
      const rx = Array.isArray(pair) ? pair[1] : null;
      if (typeof tx !== 'function' || typeof rx !== 'function') {
        appendLog('Falha ao criar action audioLevel.');
        return;
      }
      levelSyncTx = tx;
      rx((data) => {
        if (!data || data.type !== 'audio.level') return;
        applyRemoteLevel(data);
      });
      levelSyncRxBound = true;
      appendLog('Sync de pico ligado (Flowgate).');
    } catch(e){
      appendLog('Erro bind audioLevel: ' + (e?.message || String(e)));
    }
  }

  // ---------- AUDIO ----------
  function ensureSpatialNodes(){
    if (!audioCtx) return;
    if (!spatialSplitter){
      spatialSplitter = audioCtx.createChannelSplitter(2);
    }
    try { spatialSplitter.channelCount = 2; } catch(_){ }
    try { spatialSplitter.channelCountMode = 'explicit'; } catch(_){ }
    try { spatialSplitter.channelInterpretation = 'speakers'; } catch(_){ }
    if (!analyserDetL){
      analyserDetL = audioCtx.createAnalyser();
      analyserDetL.fftSize = 1024;
      analyserDetL.smoothingTimeConstant = 0.0;
    }
    if (!analyserDetR){
      analyserDetR = audioCtx.createAnalyser();
      analyserDetR.fftSize = 1024;
      analyserDetR.smoothingTimeConstant = 0.0;
    }
    try { spatialSplitter.disconnect(); } catch(_){ }
    try { spatialSplitter.connect(analyserDetL, 0); } catch(_){ }
    try { spatialSplitter.connect(analyserDetR, 1); } catch(_){ }
  }

  function ensureSpatialConnections(){
    if (!spatialSplitter) return;
    const sources = [];
    if (streamSource) sources.push(streamSource);
    if (elementSources && elementSources.length) sources.push(...elementSources);
    sources.forEach((src) => {
      if (!src || src.__audioCollarSpatialAttached) return;
      try { src.connect(spatialSplitter); } catch(_){ }
      src.__audioCollarSpatialAttached = true;
    });
  }

  async function ensureAudio(rescanElements){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (!analyserVis){
      analyserVis = audioCtx.createAnalyser();
      analyserVis.fftSize = 1024;
      analyserVis.smoothingTimeConstant = 0.0;
    }
    if (!analyserDet){
      analyserDet = audioCtx.createAnalyser();
      analyserDet.fftSize = 1024;
      analyserDet.smoothingTimeConstant = 0.0;
    }
    ensureSpatialNodes();
    ensureSpatialConnections();

    if (rescanElements || !elementSources.length){
      const mediaEls = Array.from(document.querySelectorAll('audio,video'));
      mediaEls.forEach(el=>{
        try {
          if (el.__audioCollarAttached) return;
          const src = audioCtx.createMediaElementSource(el);
          try { src.channelCount = 2; } catch(_){ }
          try { src.channelCountMode = 'explicit'; } catch(_){ }
          try { src.channelInterpretation = 'speakers'; } catch(_){ }
          src.__audioCollarSpatialAttached = false;
          connectToAnalysers(src);
          src.connect(audioCtx.destination);
          elementSources.push(src);
          el.__audioCollarAttached = true;
        } catch(e){}
      });
      ensureSpatialConnections();
    }

    if (audioCtx.state === 'suspended'){
      const resume = ()=>{
        audioCtx.resume().catch(()=>{});
        document.removeEventListener('pointerdown', resume);
      };
      document.addEventListener('pointerdown', resume, {once:true});
    }
  }

  async function tryTabCapture(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia){
      throw new Error('getDisplayMedia não suportado neste navegador.');
    }
    if (tabStream){
      tabStream.getTracks().forEach(t=>t.stop());
      tabStream = null;
    }
    const s = await navigator.mediaDevices.getDisplayMedia({
      video: true,
      audio: { echoCancellation:false, noiseSuppression:false, channelCount: 2 }
    });
    tabStream = s;
    attachStream(s);
  }

  async function tryMicCapture(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      throw new Error('getUserMedia não suportado neste navegador.');
    }

    if (micStream){
      micStream.getTracks().forEach(t=>t.stop());
      micStream = null;
    }

    const sel = $('#audio-collar-mic-select');
    const deviceId = sel ? (sel.value || null) : null;

    const constraints = {
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      },
      video: false
    };
    if (deviceId) constraints.audio.deviceId = { exact: deviceId };

    const s = await navigator.mediaDevices.getUserMedia(constraints);
    micStream = s;
    attachStream(s);
  }

  function attachStream(stream){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (!analyserVis){
      analyserVis = audioCtx.createAnalyser();
      analyserVis.fftSize = 1024;
      analyserVis.smoothingTimeConstant = 0.0;
    }
    if (!analyserDet){
      analyserDet = audioCtx.createAnalyser();
      analyserDet.fftSize = 1024;
      analyserDet.smoothingTimeConstant = 0.0;
    }
    try { streamSource && streamSource.disconnect(); } catch(_){}
    streamSource = audioCtx.createMediaStreamSource(stream);
    streamSource.__audioCollarSpatialAttached = false;
    try { streamSource.channelCount = 2; } catch(_){ }
    try { streamSource.channelCountMode = 'explicit'; } catch(_){ }
    try { streamSource.channelInterpretation = 'speakers'; } catch(_){ }
    connectToAnalysers(streamSource);
    ensureSpatialConnections();
    updateSpatialAvailability(detectStereoFromStream(stream));
  }

  function detectStereoFromStream(stream){
    try {
      const track = stream && stream.getAudioTracks ? stream.getAudioTracks()[0] : null;
      if (!track) return true;
      const settings = (typeof track.getSettings === 'function') ? track.getSettings() : {};
      const caps = (typeof track.getCapabilities === 'function') ? track.getCapabilities() : {};
      const capCh = caps.channelCount;
      if (Array.isArray(capCh)) {
        const maxCap = Math.max.apply(null, capCh.map(Number).filter(Number.isFinite));
        if (Number.isFinite(maxCap) && maxCap >= 2) return true;
      } else if (Number.isFinite(Number(capCh)) && Number(capCh) >= 2) {
        return true;
      }
      const ch = Number(settings.channelCount || 0);
      if (ch >= 2) return true;
      if (ch === 1) return false;
    } catch(_) {}
    return true;
  }

  function updateSpatialAvailability(isStereo){
    spatialAvailable = !!isStereo;
    const spatialToggle = $('#audio-collar-spatial');
    const spatialStatus = $('#audio-collar-spatial-status');
    if (!spatialToggle) return;
    spatialToggle.disabled = !spatialAvailable;
    spatialToggle.setAttribute('aria-disabled', spatialAvailable ? 'false' : 'true');
    if (spatialStatus) spatialStatus.textContent = spatialAvailable ? 'Stereo' : 'Mono';
    const tip = `Espacial (${spatialAvailable ? 'Stereo' : 'Mono'})`;
    spatialToggle.setAttribute('data-bs-title', tip);
    spatialToggle.setAttribute('aria-label', tip);
    if (spatialTooltip && typeof spatialTooltip.setContent === 'function') {
      try { spatialTooltip.setContent({ '.tooltip-inner': tip }); } catch(_){ }
    }
    if (!spatialAvailable) {
      cfg.spatialEnabled = false;
      LS.set('spatialEnabled', cfg.spatialEnabled);
      lastSpatialPan = 0;
      lastSpatialSeenAt = 0;
      lastSpatialPeak = 0;
      lastSpatialCmdAt = 0;
      spatialToggle.classList.remove('active');
      spatialToggle.classList.remove('btn-info');
      spatialToggle.classList.remove('btn-outline-info');
      spatialToggle.classList.add('btn-outline-secondary');
      spatialToggle.setAttribute('aria-pressed', 'false');
    }
  }

  function stopAllSources(){
    try {
      if (tabStream) { tabStream.getTracks().forEach(t => t.stop()); tabStream = null; }
      if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
      if (streamSource) { streamSource.disconnect(); streamSource = null; }
      elementSources.forEach(src => { try { src.disconnect(); } catch(_){} });
      elementSources = [];
      envPeakAbs = 0;
      envPeakAbsL = 0;
      envPeakAbsR = 0;
      spatialPanState = 0;
      lastSpatialPan = 0;
      lastSpatialSeenAt = 0;
      lastSpatialPeak = 0;
      lastSpatialCmdAt = 0;
      spatialAvailable = true;
      remoteLevel = null;
      const fill    = $('#audio-collar-fill');
      const over    = $('#audio-collar-overdrive');
      const volEl   = $('#audio-collar-vol');
      const peakEl  = $('#audio-collar-peak');
      const peakLbl = $('#audio-collar-peaklbl');
      if (fill)    fill.style.width = '100%';
      if (over) {
        over.style.width = '0%';
        over.classList.remove('is-hot');
      }
      if (volEl)   volEl.textContent = '0%';
      if (peakEl)  peakEl.style.left = '0%';
      if (peakLbl) peakLbl.textContent = '0%';
      clearSpectrum();
      appendLog('Fonte de áudio interrompida.');
    } catch(e){
      appendLog('Falha ao parar fonte: ' + (e?.message || String(e)));
    }
  }

  function exposeStopper(){
    window.__audioCollarStopAllSources = stopAllSources;
  }

  function initSpectrumCanvas(){
    spectrumCanvas = $('#audio-collar-spectrum');
    if (!spectrumCanvas) return;
    spectrumCtx = spectrumCanvas.getContext('2d');
    resizeSpectrumCanvas();
    window.addEventListener('resize', resizeSpectrumCanvas);
    spectrumCanvas.addEventListener('pointerdown', (ev) => {
      if (!setFreqRangeExternal) return;
      const rect = spectrumCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const nyquist = audioCtx && audioCtx.sampleRate ? (audioCtx.sampleRate / 2) : 22050;
      const maxHz = Math.min(SPECTRUM_MAX_HZ, nyquist);
      const minHz = Math.min(SPECTRUM_MIN_HZ, maxHz);
      const ratio = clamp(x / Math.max(1, rect.width), 0, 1);
      const clickedHz = minHz * Math.pow(maxHz / minHz, ratio);
      if (ev.shiftKey) {
        spectrumDragMode = 'range';
        spectrumDragStartHz = clickedHz;
      } else {
        const distMin = Math.abs(clickedHz - cfg.freqMinHz);
        const distMax = Math.abs(clickedHz - cfg.freqMaxHz);
        spectrumDragMode = (distMin <= distMax) ? 'min' : 'max';
        spectrumDragStartHz = null;
      }
      spectrumDragActive = true;
      spectrumCanvas.setPointerCapture(ev.pointerId);
    });
    spectrumCanvas.addEventListener('pointermove', (ev) => {
      if (!spectrumDragActive || !setFreqRangeExternal) return;
      const rect = spectrumCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const nyquist = audioCtx && audioCtx.sampleRate ? (audioCtx.sampleRate / 2) : 22050;
      const maxHz = Math.min(SPECTRUM_MAX_HZ, nyquist);
      const minHz = Math.min(SPECTRUM_MIN_HZ, maxHz);
      const ratio = clamp(x / Math.max(1, rect.width), 0, 1);
      const currentHz = minHz * Math.pow(maxHz / minHz, ratio);
      if (spectrumDragMode === 'range' && spectrumDragStartHz != null) {
        const a = Math.min(spectrumDragStartHz, currentHz);
        const b = Math.max(spectrumDragStartHz, currentHz);
        setFreqRangeExternal(a, b, { flush: false });
      } else if (spectrumDragMode === 'max') {
        setFreqRangeExternal(cfg.freqMinHz, currentHz, { flush: false });
      } else {
        setFreqRangeExternal(currentHz, cfg.freqMaxHz, { flush: false });
      }
    });
    spectrumCanvas.addEventListener('pointerup', (ev) => {
      if (!spectrumDragActive || !setFreqRangeExternal) return;
      spectrumDragActive = false;
      const rect = spectrumCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const nyquist = audioCtx && audioCtx.sampleRate ? (audioCtx.sampleRate / 2) : 22050;
      const maxHz = Math.min(SPECTRUM_MAX_HZ, nyquist);
      const minHz = Math.min(SPECTRUM_MIN_HZ, maxHz);
      const ratio = clamp(x / Math.max(1, rect.width), 0, 1);
      const currentHz = minHz * Math.pow(maxHz / minHz, ratio);
      if (spectrumDragMode === 'range' && spectrumDragStartHz != null) {
        const a = Math.min(spectrumDragStartHz, currentHz);
        const b = Math.max(spectrumDragStartHz, currentHz);
        setFreqRangeExternal(a, b, { flush: true });
      } else if (spectrumDragMode === 'max') {
        setFreqRangeExternal(cfg.freqMinHz, currentHz, { flush: true });
      } else {
        setFreqRangeExternal(currentHz, cfg.freqMaxHz, { flush: true });
      }
      spectrumDragStartHz = null;
      spectrumDragMode = null;
      try { spectrumCanvas.releasePointerCapture(ev.pointerId); } catch(_){ }
    });
    spectrumCanvas.addEventListener('pointercancel', () => {
      spectrumDragActive = false;
      spectrumDragStartHz = null;
      spectrumDragMode = null;
    });
  }

  function resizeSpectrumCanvas(){
    if (!spectrumCanvas || !spectrumCtx) return;
    const rect = spectrumCanvas.getBoundingClientRect();
    const nextW = Math.max(1, Math.floor(rect.width));
    const nextH = Math.max(1, Math.floor(rect.height));
    const nextDpr = window.devicePixelRatio || 1;
    if (nextW === spectrumW && nextH === spectrumH && nextDpr === spectrumDpr) return;
    spectrumW = nextW;
    spectrumH = nextH;
    spectrumDpr = nextDpr;
    spectrumCanvas.width = Math.floor(nextW * nextDpr);
    spectrumCanvas.height = Math.floor(nextH * nextDpr);
    spectrumCtx.setTransform(nextDpr, 0, 0, nextDpr, 0, 0);
  }

  function clearSpectrum(){
    if (!spectrumCtx) return;
    spectrumCtx.clearRect(0, 0, spectrumW, spectrumH);
  }

  function readLevelsFromAnalyser(analyser, envKey){
    if (!analyser) return { pct: 0, peakPct: 0, rawPeakPct: 0, procAvgPct: 0 };

    const binCount = analyser.frequencyBinCount;
    const data = new Uint8Array(binCount);
    analyser.getByteFrequencyData(data);

    const nyquist = audioCtx && audioCtx.sampleRate ? (audioCtx.sampleRate / 2) : 22050;
    const range = normalizeFreqRange(cfg.freqMinHz, cfg.freqMaxHz, audioCtx ? audioCtx.sampleRate : null);
    const minHz = Math.min(range.min, nyquist);
    const maxHz = Math.min(range.max, nyquist);
    const idx0 = clamp(Math.floor((minHz / nyquist) * binCount), 0, binCount - 1);
    const idx1 = clamp(Math.ceil((maxHz / nyquist) * binCount), idx0 + 1, binCount);

    let sum = 0;
    let peak = 0;
    const count = Math.max(1, idx1 - idx0);
    for (let i = idx0; i < idx1; i++) {
      const v = data[i] / 255;
      sum += v;
      if (v > peak) peak = v;
    }

    let env = envPeakAbs;
    if (envKey === 'left') env = envPeakAbsL;
    else if (envKey === 'right') env = envPeakAbsR;
    env = Math.max(peak, env * PEAK_ENV_DECAY, PEAK_MIN_FLOOR);
    if (envKey === 'left') envPeakAbsL = env;
    else if (envKey === 'right') envPeakAbsR = env;
    else envPeakAbs = env;

    const sensDb = clamp(cfg.sensDb || 0, SENS_DB_MIN, SENS_DB_MAX);
    const gain = Math.pow(10, sensDb / 20);

    let avg = Math.min(1, (sum / count) * gain);
    const pct = clamp(Math.round(avg * 100 * 1.4), 0, 100);

    let envScaled = Math.min(1, env * gain);
    let rawScaled = Math.min(1, peak * gain);

    const nf = clamp(cfg.noiseFloorPct/100, 0, 0.99);
    let p = envScaled;
    if (p <= nf) p = 0;
    else {
      p = (p - nf) / (1 - nf);
      p = Math.pow(p, Math.max(1.0, cfg.gamma));
    }
    const peakPct = clamp(Math.round(p*100), 0, 100);

    let pa = avg;
    if (pa <= nf) pa = 0;
    else {
      pa = (pa - nf) / (1 - nf);
      pa = Math.pow(pa, Math.max(1.0, cfg.gamma));
    }
    const procAvgPct = clamp(Math.round(pa*100), 0, 100);

    let pr = rawScaled;
    if (pr <= nf) pr = 0;
    else {
      pr = (pr - nf) / (1 - nf);
      pr = Math.pow(pr, Math.max(1.0, cfg.gamma));
    }
    const rawPeakPct = clamp(Math.round(pr*100), 0, 100);

    return { pct, peakPct, rawPeakPct, procAvgPct };
  }

  function readLevelsInstant(){
    return readLevelsFromAnalyser(analyserDet, 'mono');
  }

  function quantizeLevel(val){
    return clamp(Math.floor(val / STEP_PCT) * STEP_PCT, 0, 100);
  }

  function computeSpatialPan(peakL, peakR){
    const l = clamp(Number(peakL || 0), 0, 100);
    const r = clamp(Number(peakR || 0), 0, 100);
    const sum = l + r + 0.0001;
    let pan = (r - l) / sum;
    if (Math.abs(pan) < SPATIAL_PAN_DEADZONE) pan = 0;
    spatialPanState = (spatialPanState * (1 - SPATIAL_PAN_SMOOTH)) + (pan * SPATIAL_PAN_SMOOTH);
    const q = SPATIAL_PAN_QUANT > 0 ? (Math.round(spatialPanState / SPATIAL_PAN_QUANT) * SPATIAL_PAN_QUANT) : spatialPanState;
    return { raw: clamp(pan, -1, 1), smooth: clamp(q, -1, 1) };
  }


  function computeSplitLevels(baseLevel, pan){
    const p = clamp(Number(pan || 0), -1, 1);
    const w1 = (1 - p) / 2;
    const w2 = 1 - w1;
    let lvl1 = Math.round(baseLevel * w1);
    let lvl2 = Math.round(baseLevel - lvl1);
    lvl1 = clamp(lvl1, 0, 100);
    lvl2 = clamp(lvl2, 0, 100);
    return { lvl1, lvl2 };
  }

  function updateSpectrum(){
    if (!spectrumCtx || !analyserVis || !audioCtx) return;
    if (!spectrumW || !spectrumH) resizeSpectrumCanvas();
    if (!spectrumW || !spectrumH) return;

    const binCount = analyserVis.frequencyBinCount;
    if (!spectrumData || spectrumData.length !== binCount) {
      spectrumData = new Uint8Array(binCount);
    }
    analyserVis.getByteFrequencyData(spectrumData);

    const nyquist = audioCtx.sampleRate ? (audioCtx.sampleRate / 2) : 22050;
    const range = normalizeFreqRange(cfg.freqMinHz, cfg.freqMaxHz, audioCtx.sampleRate);
    const maxHz = Math.min(SPECTRUM_MAX_HZ, nyquist);
    const minHz = Math.min(SPECTRUM_MIN_HZ, maxHz);
    const labelHeight = 16;
    const height = Math.max(12, spectrumH - labelHeight - 4);
    const top = 2;
    const bottom = top + height;

    spectrumCtx.clearRect(0, 0, spectrumW, spectrumH);

    const barsCount = clamp(Math.floor(spectrumW / 18), 12, 48);
    const gap = 2;
    const totalGap = gap * (barsCount - 1);
    const barW = Math.max(2, (spectrumW - totalGap) / barsCount);

    for (let i = 0; i < barsCount; i++) {
      const ratio0 = i / barsCount;
      const ratio1 = (i + 1) / barsCount;
      const f0 = minHz * Math.pow(maxHz / minHz, ratio0);
      const f1 = minHz * Math.pow(maxHz / minHz, ratio1);
      const fMid = Math.sqrt(f0 * f1);
      const inRange = fMid >= range.min && fMid <= range.max;

      let idx0 = Math.floor((f0 / nyquist) * binCount);
      let idx1 = Math.floor((f1 / nyquist) * binCount);
      idx0 = clamp(idx0, 0, binCount - 1);
      idx1 = clamp(idx1, idx0 + 1, binCount);

      let sum = 0;
      for (let j = idx0; j < idx1; j++) sum += spectrumData[j];
      const avg = sum / Math.max(1, idx1 - idx0);
      let level = avg / 255;
      if (level <= SPECTRUM_FLOOR) level = 0;
      else level = (level - SPECTRUM_FLOOR) / (1 - SPECTRUM_FLOOR);
      level = Math.pow(level, SPECTRUM_GAMMA);

      const barH = Math.max(2, level * height);
      const x = i * (barW + gap);

      spectrumCtx.fillStyle = 'rgba(148,163,184,0.16)';
      spectrumCtx.fillRect(x, top, barW, height);
      if (inRange) {
        spectrumCtx.fillStyle = level > 0.01 ? 'rgba(34,197,94,0.95)' : 'rgba(34,197,94,0.65)';
      } else {
        spectrumCtx.fillStyle = level > 0.01 ? 'rgba(148,163,184,0.6)' : 'rgba(148,163,184,0.35)';
      }
      spectrumCtx.fillRect(x, bottom - barH, barW, barH);

      const hz = Math.round(fMid);
      const label = hz >= 1000 ? (hz / 1000).toFixed(1).replace(/\.0$/, '') + 'k' : String(hz);
      spectrumCtx.fillStyle = 'rgba(148,163,184,0.85)';
      spectrumCtx.font = '11px sans-serif';
      spectrumCtx.textAlign = 'center';
      spectrumCtx.textBaseline = 'alphabetic';
      spectrumCtx.fillText(label, x + barW / 2, spectrumH - 2);
    }

    {
      const rangeMin = Math.max(range.min, minHz);
      const rangeMax = Math.min(range.max, maxHz);
      const logSpan = Math.log(maxHz / minHz);
      if (rangeMax > rangeMin && logSpan > 0) {
        const toX = (f) => (Math.log(f / minHz) / logSpan) * spectrumW;
        const xStart = toX(rangeMin);
        const xEnd = toX(rangeMax);
        const points = 64;
        const nf = clamp(cfg.noiseFloorPct / 100, 0, 0.99);
        const gamma = Math.max(1.0, cfg.gamma || 1.0);
        spectrumCtx.save();
        spectrumCtx.strokeStyle = 'rgba(56,189,248,0.95)';
        spectrumCtx.lineWidth = 1.5;
        spectrumCtx.beginPath();
        for (let i = 0; i < points; i++) {
          const xNorm = i / (points - 1);
          let yNorm = 0;
          if (xNorm > nf) {
            yNorm = Math.pow((xNorm - nf) / (1 - nf), gamma);
          }
          const x = xStart + xNorm * (xEnd - xStart);
          const y = bottom - (yNorm * height);
          if (i === 0) spectrumCtx.moveTo(x, y);
          else spectrumCtx.lineTo(x, y);
        }
        spectrumCtx.stroke();
        spectrumCtx.restore();
      }
    }

  }

  // ---------- Desired-state update (dwell + hysterese) ----------
  function updateDesiredFromPeak(peakPct, spatial){
    const now = Date.now();
    const thrOn  = clamp(cfg.thresholdPct, 0, 100);
    const isRoulette = control.mode === 'ROULETTE';
    const spatialOn = !!(cfg.spatialEnabled && spatialAvailable && !isRoulette);
    const spatialInfo = spatialOn ? (spatial || { pan: lastSpatialPan, left: 0, right: 0 }) : null;
    if (isRoulette) {
      const shouldHold = peakPct >= thrOn;
      if (shouldHold && !desired.on) {
        desired = { on:true, mode: control.mode, level: 0, ch: control.channel, level1: 0, level2: 0, pan: 0, split: false, seq: ++seq };
        aboveSince = 0;
        belowSince = 0;
      } else if (!shouldHold && desired.on) {
        desired = { on:false, mode: control.mode, level: 0, ch: control.channel, level1: 0, level2: 0, pan: 0, split: false, seq: ++seq };
        aboveSince = 0;
        belowSince = 0;
      }
      return;
    }
    const thrOff = clamp(thrOn - THRESH_HYST, 0, 100);

    if (!desired.on) {
      // Fast-path: pico bem acima do threshold dispara sem esperar dwell
      if (peakPct >= (thrOn + FAST_TRIP_MARGIN)) {
        const minLevel = Math.ceil(thrOn/STEP_PCT)*STEP_PCT;
        const lvl = Math.max(minLevel, quantizeLevel(peakPct));
        let next = { on:true, mode: control.mode, level: clamp(lvl, 0, 100), ch: control.channel, level1: 0, level2: 0, pan: 0, split: false, seq: ++seq };
        if (spatialOn && spatialInfo) {
          const split = computeSplitLevels(next.level, spatialInfo.pan);
          const dominantCh = split.lvl1 >= split.lvl2 ? 1 : 2;
          const dominantLvl = Math.max(split.lvl1, split.lvl2);
          next = Object.assign({}, next, { level: dominantLvl, ch: dominantCh, level1: split.lvl1, level2: split.lvl2, pan: spatialInfo.pan, split: true });
        }
        desired = next;
        aboveSince = 0;
        belowSince = 0;
        return;
      }

      if (peakPct >= thrOn) {
        if (!aboveSince) aboveSince = now;
        if ((now - aboveSince) >= DWELL_ON_MS) {
          // vira ON
          const minLevel = Math.ceil(thrOn/STEP_PCT)*STEP_PCT;
          const lvl = Math.max(minLevel, quantizeLevel(peakPct));
          let next = { on:true, mode: control.mode, level: clamp(lvl, 0, 100), ch: control.channel, level1: 0, level2: 0, pan: 0, split: false, seq: ++seq };
          if (spatialOn && spatialInfo) {
            const split = computeSplitLevels(next.level, spatialInfo.pan);
            const dominantCh = split.lvl1 >= split.lvl2 ? 1 : 2;
            const dominantLvl = Math.max(split.lvl1, split.lvl2);
            next = Object.assign({}, next, { level: dominantLvl, ch: dominantCh, level1: split.lvl1, level2: split.lvl2, pan: spatialInfo.pan, split: true });
          }
          desired = next;
          belowSince = 0;
          aboveSince = 0;
        }
      } else {
        aboveSince = 0;
      }
      return;
    }

    // desired.on === true
    if (peakPct < thrOff) {
      if (!belowSince) belowSince = now;
      if ((now - belowSince) >= DWELL_OFF_MS) {
        desired = { on:false, mode: control.mode, level: 0, ch: control.channel, level1: 0, level2: 0, pan: 0, split: false, seq: ++seq };
        aboveSince = 0;
        belowSince = 0;
        return;
      }
    } else {
      belowSince = 0;
    }

    // Atualiza nível enquanto ON (seguindo pico)
    const minLevel = Math.ceil(thrOn/STEP_PCT)*STEP_PCT;
    const newLevel = Math.max(minLevel, quantizeLevel(peakPct));
    let next = {
      on:true,
      mode: control.mode,
      level: clamp(newLevel, 0, 100),
      ch: control.channel,
      level1: 0,
      level2: 0,
      pan: 0,
      split: false,
      seq: desired.seq
    };
    if (spatialOn && spatialInfo) {
      const split = computeSplitLevels(next.level, spatialInfo.pan);
      const dominantCh = split.lvl1 >= split.lvl2 ? 1 : 2;
      const dominantLvl = Math.max(split.lvl1, split.lvl2);
      next = Object.assign({}, next, { level: dominantLvl, ch: dominantCh, level1: split.lvl1, level2: split.lvl2, pan: spatialInfo.pan, split: true });
    }
    const changed = next.level !== desired.level || next.level1 !== desired.level1 || next.level2 !== desired.level2 || next.split !== desired.split || control.mode !== desired.mode || next.ch !== desired.ch;
    if (changed) {
      next.seq = ++seq;
      desired = next;
    }
  }

  // ---------- Commit loop (heartbeat + loopback) ----------
  function sendHoldState(state, meta){
    applyHoldStateLocal(state, Object.assign({ via: 'local.command' }, meta || {}));

    if (!isHost()) return;

    const modeKey = String(state.mode || control.mode || '').toUpperCase();
    if (!modeKey) return;
    if (modeKey === 'ROULETTE') return;

    let level1 = clamp(Number(state.level1 || 0), 0, 100);
    let level2 = clamp(Number(state.level2 || 0), 0, 100);
    const dominantCh = level1 >= level2 ? 1 : 2;
    const dominantLvl = Math.max(level1, level2, clamp(Number(state.level || 0), 0, 100));
    const ch = clamp(Number(state.ch || dominantCh), 1, 2);
    const shouldDual = !!(cfg.spatialEnabled && spatialAvailable && modeKey !== 'ROULETTE');

    if (shouldDual && (!state.split || (level1 === 0 && level2 === 0))) {
      const split = computeSplitLevels(dominantLvl, lastSpatialPan);
      level1 = split.lvl1;
      level2 = split.lvl2;
    }

    if (shouldDual && state.on) {
      const peakNow = Math.max(level1, level2, dominantLvl);
      const now = Date.now();
      const minInterval = COMMIT_MS * 2;
      if (peakNow > lastSpatialPeak) {
        lastSpatialPeak = peakNow;
      } else if ((now - lastSpatialCmdAt) < minInterval) {
        return; // skip to reduce flood, but never skip a new max
      }
      lastSpatialCmdAt = now;
    } else if (!state.on) {
      lastSpatialPeak = 0;
      lastSpatialCmdAt = 0;
    }

    let cmd = '';
    if (!state.on) {
      cmd = 'HOLDOFF';
    } else if (shouldDual) {
      cmd = `HOLDON DUALX ${modeKey},${Math.round(level1)},1+${modeKey},${Math.round(level2)},2`;
    } else {
      cmd = `HOLDON ${modeKey},${Math.round(dominantLvl)},${ch}`;
    }

    if (!(window.SerialBridge && typeof window.SerialBridge.send === 'function')) {
      if (!warnedNoSerial) {
        appendLog('WARN: SerialBridge indisponivel (modo host).');
        warnedNoSerial = true;
      }
      return;
    }
    warnedNoSerial = false;

    try {
      window.SerialBridge.send(cmd);
    } catch (e) {
      appendLog('ERRO ao enviar comando local: ' + (e?.message || e));
    }
  }

  function startCommitLoop(){
    commitTimer = setInterval(() => {
      if (!isMounted()) {
        teardown('unmounted');
        return;
      }
      // Heartbeat: se ON, reenviar mesmo sem mudança (robustez)
      if (desired.on) {
        // Se não mudou, ainda assim reenviamos com o mesmo seq para manter idempotência?
        // Melhor: heartbeat com seq novo, para o receiver saber que é fresco.
        // Mas o receiver ignora seq menor/igual; então heartbeat precisa incrementar seq.
        // Fazemos um heartbeat leve só se não houve commit recente.
        const age = (Date.now() - (rxLastSeenAt || 0)); // local apenas para referência
        const shouldHeartbeat = true; // simplificado: sempre

        if (shouldHeartbeat) {
          // se já commitou este seq, criamos heartbeat com novo seq sem mudar estado
          if (desired.seq === lastCommittedSeq) {
            desired = Object.assign({}, desired, { seq: ++seq });
          }
        }
      }

      // Commit: se mudou seq, envia
      if (desired.seq !== lastCommittedSeq) {
        lastCommittedSeq = desired.seq;
        sendHoldState(desired, { reason: 'commit' });
        setStatus(desired.on ? `HOLD ${desired.level}` : 'pronto', desired.on);
        appendLog(`commit hold.state: on=${desired.on} lvl=${desired.level} ch=${desired.ch} seq=${desired.seq}`);
      } else if (desired.on) {
        // Mesmo seq não acontece por conta do heartbeat acima; aqui fica como fallback
        // sendHoldState(desired, { reason: 'heartbeat' });
      }
    }, COMMIT_MS);
  }

  // ---------- Controle manual (modo/canal) ----------
  function bindControlBus(){
    const bus = window.__FS_BUS__;
    if (controlBusBound || !bus || typeof bus.on !== 'function') return;
    try {
      controlBusBound = true;
      bus.on((msg) => {
        if (msg && msg.type === 'fs-control' && msg.payload) {
          setControlState({ mode: msg.payload.mode, channel: msg.payload.channel });
        }
      });
    } catch(_) {
      controlBusBound = false;
    }
  }

  function startControlPolling(){
    controlTimer = setInterval(() => {
      if (!isMounted()) {
        teardown('unmounted');
        return;
      }
      if (!controlBusBound) bindControlBus();
      const nextMode = sanitizeMode(window.currentMode || control.mode);
      const nextChan = normalizeChannel(window.channel || control.channel);
      if (nextMode !== control.mode || nextChan !== control.channel) {
        setControlState({ mode: nextMode, channel: nextChan });
      }
    }, 500);
  }

  // ---------- UI ----------
  function updateThresholdUI(){
    const thr = $('#audio-collar-threshold');
    const thLabel = $('#audio-collar-th');
    const emoji = $('#audio-collar-th-emoji');
    if (thr)   thr.style.left = cfg.thresholdPct + '%';
    if (thLabel) thLabel.textContent = cfg.thresholdPct + '%';
    if (emoji) emoji.style.left = cfg.thresholdPct + '%';
  }
  function updateSensUI(){
    const input = $('#audio-collar-sens');
    if (input) input.value = cfg.sensDb.toFixed(0);
  }

  function updateFreqUI(opts){
    const minInput = $('#audio-collar-freq-minval');
    const maxInput = $('#audio-collar-freq-maxval');
    if (minInput) minInput.value = String(cfg.freqMinHz);
    if (maxInput) maxInput.value = String(cfg.freqMaxHz);
    const skipSlider = opts && opts.skipSlider;
    if (!skipSlider && freqSlider && !freqSliderLock) {
      freqSliderLock = true;
      try { freqSlider.set([cfg.freqMinHz, cfg.freqMaxHz]); } catch(_) {}
      freqSliderLock = false;
    }
  }

  async function populateMicSelect(){
    const sel = $('#audio-collar-mic-select');
    if (!sel || !navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return;
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const mics = devices.filter(d => d.kind === 'audioinput');
      sel.innerHTML = '<option value="">Padrão do sistema</option>';
      mics.forEach((d, idx)=>{
        const opt = document.createElement('option');
        opt.value = d.deviceId || '';
        opt.textContent = d.label || `Microfone ${idx+1}`;
        sel.appendChild(opt);
      });
      appendLog(`Foram encontrados ${mics.length} microfones.`);
    } catch(e){
      appendLog('Não foi possível listar microfones (talvez sem permissão ainda).');
    }
  }

  function makeUIBindings(){
    const btnTest = $('#audio-collar-test');
    if (btnTest){
      btnTest.addEventListener('click', ()=>{
        // publica um pulso ON curto via desired-state
        const nextCh = (cfg.spatialEnabled && spatialAvailable) ? desired.ch : control.channel;
        desired = { on:true, mode: control.mode, level: 100, ch: nextCh, seq: ++seq };
        setTimeout(() => {
          const offCh = (cfg.spatialEnabled && spatialAvailable) ? desired.ch : control.channel;
          desired = { on:false, mode: control.mode, level: 0, ch: offCh, seq: ++seq };
        }, 250);
      });
    }

    const g   = $('#audio-collar-gamma');
    const gl  = $('#audio-collar-gammalbl');
    const nf  = $('#audio-collar-nf');
    const nfl = $('#audio-collar-nflbl');
    const rangeEl = $('#audio-collar-freq-range');
    const freqMinInput = $('#audio-collar-freq-minval');
    const freqMaxInput = $('#audio-collar-freq-maxval');
    const presetBtn = $('#audio-collar-freq-preset-btn');
    const presetSearch = $('#audio-collar-freq-preset-search');
    const presetList = $('#audio-collar-freq-preset-list');
    const spatialToggle = $('#audio-collar-spatial');

    if (g && gl){
      g.value = String(cfg.gamma);
      gl.textContent = String(cfg.gamma);
      g.addEventListener('input', ()=>{
        cfg.gamma = parseFloat(g.value) || 1.0;
        gl.textContent = g.value;
        LS.set('gamma', cfg.gamma);
        requestCfgBroadcast('gamma');
      });
      g.addEventListener('change', ()=> flushCfgBroadcast('gamma'));
    }
    if (nf && nfl){
      nf.value = String(cfg.noiseFloorPct);
      nfl.textContent = cfg.noiseFloorPct + '%';
      nf.addEventListener('input', ()=>{
        cfg.noiseFloorPct = parseInt(nf.value, 10) || 0;
        nfl.textContent = cfg.noiseFloorPct + '%';
        LS.set('noiseFloorPct', cfg.noiseFloorPct);
        requestCfgBroadcast('noise');
      });
      nf.addEventListener('change', ()=> flushCfgBroadcast('noise'));
    }

    function setSpatialEnabled(val, opts){
      cfg.spatialEnabled = !!val;
      LS.set('spatialEnabled', cfg.spatialEnabled);
      updateSpatialUI();
      if (opts && opts.flush) flushCfgBroadcast('spatial');
      else requestCfgBroadcast('spatial');
    }
    if (spatialToggle){
      if (window.bootstrap && typeof window.bootstrap.Tooltip === 'function') {
        try { spatialTooltip = new window.bootstrap.Tooltip(spatialToggle); } catch(_){ }
      }
      spatialToggle.addEventListener('click', () => {
        if (spatialToggle.disabled) return;
        setSpatialEnabled(!cfg.spatialEnabled, { flush: true });
      });
    }

    function setFreqRange(nextMin, nextMax, opts){
      const range = normalizeFreqRange(parseFloat(nextMin), parseFloat(nextMax), audioCtx ? audioCtx.sampleRate : null);
      cfg.freqMinHz = range.min;
      cfg.freqMaxHz = range.max;
      LS.set('freqMinHz', cfg.freqMinHz);
      LS.set('freqMaxHz', cfg.freqMaxHz);
      const fromSlider = opts && opts.fromSlider;
      if (fromSlider) freqSliderLock = true;
      updateFreqUI({ skipSlider: !!fromSlider });
      if (fromSlider) freqSliderLock = false;
      if (opts && opts.flush) {
        flushCfgBroadcast('freq');
      } else {
        requestCfgBroadcast('freq');
      }
    }

    setFreqRangeExternal = setFreqRange;

    function bindFreqInputs(){
      if (!freqMinInput || !freqMaxInput) return;
      const commit = (flush) => {
        setFreqRange(freqMinInput.value, freqMaxInput.value, { flush: !!flush });
      };
      freqMinInput.addEventListener('change', () => commit(true));
      freqMaxInput.addEventListener('change', () => commit(true));
      freqMinInput.addEventListener('blur', () => commit(true));
      freqMaxInput.addEventListener('blur', () => commit(true));
      freqMinInput.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') commit(true);
      });
      freqMaxInput.addEventListener('keydown', (ev) => {
        if (ev.key === 'Enter') commit(true);
      });
    }

    function applyFreqPreset(label, minHz, maxHz){
      if (!Number.isFinite(minHz) || !Number.isFinite(maxHz)) return;
      setFreqRange(minHz, maxHz, { flush: true });
      if (presetBtn) presetBtn.textContent = label;
      appendLog(`Preset Hz aplicado: ${label}`);
    }

    function initFreqSlider(){
      if (!rangeEl) return;
      if (!(window.noUiSlider && typeof window.noUiSlider.create === 'function')) return;
      if (!rangeEl.noUiSlider) {
        window.noUiSlider.create(rangeEl, {
          start: [cfg.freqMinHz, cfg.freqMaxHz],
          connect: true,
          step: 10,
          range: { min: FREQ_MIN_LIMIT, max: FREQ_MAX_LIMIT }
        });
      }
      freqSlider = rangeEl.noUiSlider;
      if (!freqSliderBound) {
        freqSliderBound = true;
        freqSlider.on('update', (values) => {
          if (freqSliderLock) return;
          setFreqRange(values[0], values[1], { fromSlider: true });
        });
        freqSlider.on('change', (values) => {
          setFreqRange(values[0], values[1], { fromSlider: true, flush: true });
        });
      }
      updateFreqUI();
      if (freqSliderInitTimer) {
        clearInterval(freqSliderInitTimer);
        freqSliderInitTimer = null;
      }
    }

    if (rangeEl) {
      initFreqSlider();
      if (!freqSlider && !freqSliderInitTimer) {
        let warned = false;
        freqSliderInitTimer = setInterval(() => {
          if (!warned) {
            warned = true;
            appendLog('Aguardando noUiSlider carregar...');
          }
          initFreqSlider();
        }, 300);
      }
    }

    bindFreqInputs();

    if (presetSearch && presetList) {
      presetSearch.addEventListener('input', () => {
        const q = presetSearch.value.trim().toLowerCase();
        const items = Array.from(presetList.querySelectorAll('.dropdown-item'));
        items.forEach((item) => {
          const txt = item.textContent.trim().toLowerCase();
          item.classList.toggle('d-none', q && !txt.includes(q));
        });
      });
    }

    if (presetList) {
      presetList.addEventListener('click', (ev) => {
        const btn = ev.target && ev.target.closest('.dropdown-item');
        if (!btn) return;
        const label = btn.textContent.trim();
        const minHz = parseFloat(btn.getAttribute('data-min'));
        const maxHz = parseFloat(btn.getAttribute('data-max'));
        applyFreqPreset(label, minHz, maxHz);
      });
    }

    const sensInput = $('#audio-collar-sens');
    const sensDec   = $('#audio-collar-sens-dec');
    const sensInc   = $('#audio-collar-sens-inc');

    function setSensDb(val, opts){
      const v = clamp(parseFloat(val) || 0, SENS_DB_MIN, SENS_DB_MAX);
      cfg.sensDb = v;
      LS.set('sensDb', cfg.sensDb);
      if (opts && opts.flush) {
        flushCfgBroadcast('sens');
      } else {
        requestCfgBroadcast('sens');
      }
      updateSensUI();
    }

    if (sensInput){
      sensInput.value = cfg.sensDb.toFixed(0);
      sensInput.addEventListener('change', ()=> setSensDb(sensInput.value, { flush: true }));
    }
    sensDec && sensDec.addEventListener('click', ()=> setSensDb(cfg.sensDb - SENS_DB_STEP));
    sensInc && sensInc.addEventListener('click', ()=> setSensDb(cfg.sensDb + SENS_DB_STEP));

    const bar = $('#audio-collar-bar');
    if (bar){
      let dragging = false;
      const onMove = clientX => {
        const r = bar.getBoundingClientRect();
        let pct = Math.round(((clientX - r.left)/r.width) * 100);
        pct = clamp(pct, 0, 100);
        cfg.thresholdPct = pct;
        LS.set('thresholdPct', pct);
        updateThresholdUI();
        requestCfgBroadcast('threshold');
      };
      bar.addEventListener('pointerdown', ev=>{
        dragging = true;
        bar.setPointerCapture(ev.pointerId);
        onMove(ev.clientX);
      });
      window.addEventListener('pointermove', ev=>{ if (dragging) onMove(ev.clientX); });
      window.addEventListener('pointerup', ev=>{
        if (!dragging) return;
        dragging = false;
        try { bar.releasePointerCapture(ev.pointerId); } catch(_){}
        flushCfgBroadcast('threshold');
      });
    }

    const btnRefresh = $('#audio-collar-refresh-media');
    const btnTab     = $('#audio-collar-capture-tab');
    const btnMic     = $('#audio-collar-mic');
    const btnStop    = $('#audio-collar-stop-source');

    btnRefresh && btnRefresh.addEventListener('click', async ()=>{
      await ensureAudio(true);
      appendLog('Reanalisando elementos <audio>/<video> desta página.');
    });

    btnTab && btnTab.addEventListener('click', async ()=>{
      btnTab.disabled = true;
      try {
        await tryTabCapture();
        appendLog('Captura guia/janela iniciada — selecione a guia/janela com áudio.');
      } catch(e){
        appendLog('Falha captura guia/janela: ' + (e?.name ? `${e.name}: ${e.message||''}` : String(e)));
      } finally {
        btnTab.disabled = false;
      }
    });

    btnMic && btnMic.addEventListener('click', async ()=>{
      btnMic.disabled = true;
      try {
        await tryMicCapture();
        appendLog('Captura de microfone iniciada.');
        await populateMicSelect();
      } catch(e){
        appendLog('Falha captura microfone: ' + (e?.name ? `${e.name}: ${e.message||''}` : String(e)));
      } finally {
        btnMic.disabled = false;
      }
    });

    btnStop && btnStop.addEventListener('click', async ()=>{
      btnStop.disabled = true;
      try {
        stopAllSources();
        desired = { on:false, mode: control.mode, level: 0, ch: desired.ch || control.channel, seq: ++seq };
        lastCommittedSeq = 0;
        sendHoldState(desired, { reason: 'stop' });
      } finally { btnStop.disabled = false; }
    });

    const logToggle = $('#audio-collar-log-toggle');
    const logWrap = $('#audio-collar-log-wrap');
    if (logToggle && logWrap) {
      const setVis = (show) => {
        logWrap.classList.toggle('d-none', !show);
        logToggle.setAttribute('aria-expanded', show ? 'true' : 'false');
      };
      logToggle.addEventListener('click', () => {
        const next = logWrap.classList.contains('d-none');
        setVis(next);
      });
      setVis(false);
    }

    updateThresholdUI();
    updateSensUI();
    updateFreqUI();
    updateSpatialUI();
  }

  function updateSpatialUI(){
    const spatialToggle = $('#audio-collar-spatial');
    const spatialStatus = $('#audio-collar-spatial-status');
    if (spatialToggle) {
      const on = spatialAvailable ? !!cfg.spatialEnabled : false;
      spatialToggle.classList.toggle('active', on);
      spatialToggle.classList.toggle('btn-info', on);
      spatialToggle.classList.toggle('btn-outline-info', false);
      spatialToggle.classList.toggle('btn-outline-secondary', !on);
      spatialToggle.setAttribute('aria-pressed', on ? 'true' : 'false');
      spatialToggle.disabled = !spatialAvailable;
      spatialToggle.setAttribute('aria-disabled', spatialAvailable ? 'false' : 'true');
      const tip = `Espacial (${spatialAvailable ? 'Stereo' : 'Mono'})`;
      spatialToggle.setAttribute('data-bs-title', tip);
      spatialToggle.setAttribute('aria-label', tip);
      if (spatialTooltip && typeof spatialTooltip.setContent === 'function') {
        try { spatialTooltip.setContent({ '.tooltip-inner': tip }); } catch(_){ }
      }
    }
    if (spatialStatus) spatialStatus.textContent = spatialAvailable ? 'Stereo' : 'Mono';
  }

  // ---------- main loops ----------
  async function tickAudio(){
    if (!isMounted()) {
      teardown('unmounted');
      return;
    }
    try { await ensureAudio(false); } catch(e){}
    const { pct, peakPct } = readLevelsInstant();
    let spatial = null;
    if (analyserDetL && analyserDetR) {
      const left = readLevelsFromAnalyser(analyserDetL, 'left');
      const right = readLevelsFromAnalyser(analyserDetR, 'right');
      const pan = computeSpatialPan(left.rawPeakPct, right.rawPeakPct);
      spatial = { pan: pan.smooth, rawPan: pan.raw, left: left.rawPeakPct, right: right.rawPeakPct };
      lastSpatialPan = pan.smooth;
      lastSpatialSeenAt = Date.now();
    }

    broadcastLevel(pct, peakPct);

    let dispPct = pct;
    let dispPeak = peakPct;
    const now = Date.now();
    if (remoteLevel && (now - (remoteLevel.ts || 0)) < 2500) {
      dispPct = Math.max(pct, remoteLevel.pct);
      dispPeak = Math.max(peakPct, remoteLevel.peakPct);
    } else {
      remoteLevel = null;
    }

    const fill    = $('#audio-collar-fill');
    const over    = $('#audio-collar-overdrive');
    const volEl   = $('#audio-collar-vol');
    const peakEl  = $('#audio-collar-peak');
    const peakLbl = $('#audio-collar-peaklbl');
    const spatialLeft = $('#audio-collar-spatial-left');
    const spatialRight = $('#audio-collar-spatial-right');

    const safePeak = clamp(dispPeak, 0, 100);
    const thresholdPct = clamp(cfg.thresholdPct || 0, 0, 100);

    if (fill)    fill.style.width = Math.max(0, 100 - safePeak) + '%'; // mask que revela gradient do bar
    if (volEl)   volEl.textContent = dispPct + '%';
    if (peakEl)  peakEl.style.left = safePeak + '%';
    if (peakLbl) peakLbl.textContent = safePeak + '%';
    if (over) {
      const overflow = Math.max(0, safePeak - thresholdPct);
      const width = Math.min(overflow, Math.max(0, 100 - thresholdPct));
      if (width > 0) {
        over.style.left = thresholdPct + '%';
        over.style.width = width + '%';
        over.classList.add('is-hot');
      } else {
        over.style.width = '0%';
        over.classList.remove('is-hot');
      }
    }

    if (spatialLeft && spatialRight) {
      let pan = spatial ? clamp(spatial.rawPan, -1, 1) : 0;
      const energy = clamp((spatial ? Math.max(spatial.left, spatial.right) : peakPct) / 100, 0, 1);
      const leftStrength = ((1 - pan) / 2) * energy;
      const rightStrength = ((1 + pan) / 2) * energy;
      spatialLeft.style.width = (leftStrength * 100).toFixed(1) + '%';
      spatialRight.style.width = (rightStrength * 100).toFixed(1) + '%';
    }

    updateDesiredFromPeak(peakPct, spatial);
    updateSpectrum();
  }

  function boot(){
    appendLog('Booting Audio→Collar widget...');
    widgetRoot.dataset.audioCollarReady = '1';
    window.__AUDIO_COLLAR_WIDGET_V20__.teardown = teardown;
    makeUIBindings();
    initSpectrumCanvas();
    setControlState({ mode: window.currentMode, channel: window.channel });
    bindControlBus();
    startControlPolling();
    exposeStopper();
    setStatus('pronto', false);
    appendLog('Audio→Collar v2.0 inicializado.');
    appendLog('Modo local: comandos no host; Flowgate apenas para pico (audio.level).');

    populateMicSelect();

    tickTimer = setInterval(tickAudio, POLL_MS);
    startCommitLoop();
  }

  boot();
})();
</script>
